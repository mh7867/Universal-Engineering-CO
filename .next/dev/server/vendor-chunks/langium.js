"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langium";
exports.ids = ["vendor-chunks/langium"];
exports.modules = {

/***/ "(ssr)/./node_modules/langium/lib/default-module.js":
/*!****************************************************!*\
  !*** ./node_modules/langium/lib/default-module.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDefaultCoreModule: () => (/* binding */ createDefaultCoreModule),\n/* harmony export */   createDefaultSharedCoreModule: () => (/* binding */ createDefaultSharedCoreModule)\n/* harmony export */ });\n/* harmony import */ var _languages_grammar_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languages/grammar-config.js */ \"(ssr)/./node_modules/langium/lib/languages/grammar-config.js\");\n/* harmony import */ var _parser_completion_parser_builder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser/completion-parser-builder.js */ \"(ssr)/./node_modules/langium/lib/parser/completion-parser-builder.js\");\n/* harmony import */ var _parser_langium_parser_builder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser/langium-parser-builder.js */ \"(ssr)/./node_modules/langium/lib/parser/langium-parser-builder.js\");\n/* harmony import */ var _parser_token_builder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parser/token-builder.js */ \"(ssr)/./node_modules/langium/lib/parser/token-builder.js\");\n/* harmony import */ var _parser_value_converter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser/value-converter.js */ \"(ssr)/./node_modules/langium/lib/parser/value-converter.js\");\n/* harmony import */ var _references_linker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./references/linker.js */ \"(ssr)/./node_modules/langium/lib/references/linker.js\");\n/* harmony import */ var _references_name_provider_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./references/name-provider.js */ \"(ssr)/./node_modules/langium/lib/references/name-provider.js\");\n/* harmony import */ var _references_references_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./references/references.js */ \"(ssr)/./node_modules/langium/lib/references/references.js\");\n/* harmony import */ var _references_scope_computation_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./references/scope-computation.js */ \"(ssr)/./node_modules/langium/lib/references/scope-computation.js\");\n/* harmony import */ var _references_scope_provider_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./references/scope-provider.js */ \"(ssr)/./node_modules/langium/lib/references/scope-provider.js\");\n/* harmony import */ var _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./serializer/json-serializer.js */ \"(ssr)/./node_modules/langium/lib/serializer/json-serializer.js\");\n/* harmony import */ var _service_registry_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./service-registry.js */ \"(ssr)/./node_modules/langium/lib/service-registry.js\");\n/* harmony import */ var _validation_document_validator_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./validation/document-validator.js */ \"(ssr)/./node_modules/langium/lib/validation/document-validator.js\");\n/* harmony import */ var _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./validation/validation-registry.js */ \"(ssr)/./node_modules/langium/lib/validation/validation-registry.js\");\n/* harmony import */ var _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./workspace/ast-descriptions.js */ \"(ssr)/./node_modules/langium/lib/workspace/ast-descriptions.js\");\n/* harmony import */ var _workspace_ast_node_locator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./workspace/ast-node-locator.js */ \"(ssr)/./node_modules/langium/lib/workspace/ast-node-locator.js\");\n/* harmony import */ var _workspace_configuration_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./workspace/configuration.js */ \"(ssr)/./node_modules/langium/lib/workspace/configuration.js\");\n/* harmony import */ var _workspace_document_builder_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./workspace/document-builder.js */ \"(ssr)/./node_modules/langium/lib/workspace/document-builder.js\");\n/* harmony import */ var _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./workspace/documents.js */ \"(ssr)/./node_modules/langium/lib/workspace/documents.js\");\n/* harmony import */ var _workspace_index_manager_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./workspace/index-manager.js */ \"(ssr)/./node_modules/langium/lib/workspace/index-manager.js\");\n/* harmony import */ var _workspace_workspace_manager_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./workspace/workspace-manager.js */ \"(ssr)/./node_modules/langium/lib/workspace/workspace-manager.js\");\n/* harmony import */ var _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parser/lexer.js */ \"(ssr)/./node_modules/langium/lib/parser/lexer.js\");\n/* harmony import */ var _documentation_documentation_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documentation/documentation-provider.js */ \"(ssr)/./node_modules/langium/lib/documentation/documentation-provider.js\");\n/* harmony import */ var _documentation_comment_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentation/comment-provider.js */ \"(ssr)/./node_modules/langium/lib/documentation/comment-provider.js\");\n/* harmony import */ var _parser_langium_parser_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parser/langium-parser.js */ \"(ssr)/./node_modules/langium/lib/parser/langium-parser.js\");\n/* harmony import */ var _parser_async_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/async-parser.js */ \"(ssr)/./node_modules/langium/lib/parser/async-parser.js\");\n/* harmony import */ var _workspace_workspace_lock_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./workspace/workspace-lock.js */ \"(ssr)/./node_modules/langium/lib/workspace/workspace-lock.js\");\n/* harmony import */ var _serializer_hydrator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./serializer/hydrator.js */ \"(ssr)/./node_modules/langium/lib/serializer/hydrator.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nfunction createDefaultCoreModule(context) {\n    return {\n        documentation: {\n            CommentProvider: (services) => new _documentation_comment_provider_js__WEBPACK_IMPORTED_MODULE_0__.DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new _documentation_documentation_provider_js__WEBPACK_IMPORTED_MODULE_1__.JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new _parser_async_parser_js__WEBPACK_IMPORTED_MODULE_2__.DefaultAsyncParser(services),\n            GrammarConfig: (services) => (0,_languages_grammar_config_js__WEBPACK_IMPORTED_MODULE_3__.createGrammarConfig)(services),\n            LangiumParser: (services) => (0,_parser_langium_parser_builder_js__WEBPACK_IMPORTED_MODULE_4__.createLangiumParser)(services),\n            CompletionParser: (services) => (0,_parser_completion_parser_builder_js__WEBPACK_IMPORTED_MODULE_5__.createCompletionParser)(services),\n            ValueConverter: () => new _parser_value_converter_js__WEBPACK_IMPORTED_MODULE_6__.DefaultValueConverter(),\n            TokenBuilder: () => new _parser_token_builder_js__WEBPACK_IMPORTED_MODULE_7__.DefaultTokenBuilder(),\n            Lexer: (services) => new _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__.DefaultLexer(services),\n            ParserErrorMessageProvider: () => new _parser_langium_parser_js__WEBPACK_IMPORTED_MODULE_9__.LangiumParserErrorMessageProvider(),\n            LexerErrorMessageProvider: () => new _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__.DefaultLexerErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new _workspace_ast_node_locator_js__WEBPACK_IMPORTED_MODULE_10__.DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__.DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__.DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new _references_linker_js__WEBPACK_IMPORTED_MODULE_12__.DefaultLinker(services),\n            NameProvider: () => new _references_name_provider_js__WEBPACK_IMPORTED_MODULE_13__.DefaultNameProvider(),\n            ScopeProvider: (services) => new _references_scope_provider_js__WEBPACK_IMPORTED_MODULE_14__.DefaultScopeProvider(services),\n            ScopeComputation: (services) => new _references_scope_computation_js__WEBPACK_IMPORTED_MODULE_15__.DefaultScopeComputation(services),\n            References: (services) => new _references_references_js__WEBPACK_IMPORTED_MODULE_16__.DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new _serializer_hydrator_js__WEBPACK_IMPORTED_MODULE_17__.DefaultHydrator(services),\n            JsonSerializer: (services) => new _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_18__.DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new _validation_document_validator_js__WEBPACK_IMPORTED_MODULE_19__.DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_20__.ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nfunction createDefaultSharedCoreModule(context) {\n    return {\n        ServiceRegistry: (services) => new _service_registry_js__WEBPACK_IMPORTED_MODULE_21__.DefaultServiceRegistry(services),\n        workspace: {\n            LangiumDocuments: (services) => new _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__.DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__.DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new _workspace_document_builder_js__WEBPACK_IMPORTED_MODULE_23__.DefaultDocumentBuilder(services),\n            IndexManager: (services) => new _workspace_index_manager_js__WEBPACK_IMPORTED_MODULE_24__.DefaultIndexManager(services),\n            WorkspaceManager: (services) => new _workspace_workspace_manager_js__WEBPACK_IMPORTED_MODULE_25__.DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new _workspace_workspace_lock_js__WEBPACK_IMPORTED_MODULE_26__.DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new _workspace_configuration_js__WEBPACK_IMPORTED_MODULE_27__.DefaultConfigurationProvider(services)\n        }\n    };\n}\n//# sourceMappingURL=default-module.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZGVmYXVsdC1tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRTtBQUNXO0FBQ047QUFDVDtBQUNJO0FBQ2I7QUFDYTtBQUNMO0FBQ2E7QUFDTjtBQUNFO0FBQ1Q7QUFDZTtBQUNMO0FBQ2dEO0FBQ2pEO0FBQ0k7QUFDSDtBQUN5QjtBQUMvQjtBQUNRO0FBQ1E7QUFDSTtBQUNWO0FBQ0U7QUFDakI7QUFDTztBQUNWO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsK0NBQStDLHNGQUFzQjtBQUNyRSxxREFBcUQsZ0dBQTBCO0FBQy9FLFNBQVM7QUFDVDtBQUNBLDJDQUEyQyx1RUFBa0I7QUFDN0QseUNBQXlDLGlGQUFtQjtBQUM1RCx5Q0FBeUMsc0ZBQW1CO0FBQzVELDRDQUE0Qyw0RkFBc0I7QUFDbEUsc0NBQXNDLDZFQUFxQjtBQUMzRCxvQ0FBb0MseUVBQW1CO0FBQ3ZELHFDQUFxQywwREFBWTtBQUNqRCxrREFBa0Qsd0ZBQWlDO0FBQ25GLGlEQUFpRCw4RUFBZ0M7QUFDakYsU0FBUztBQUNUO0FBQ0Esc0NBQXNDLGtGQUFxQjtBQUMzRCwwREFBMEQsOEZBQWlDO0FBQzNGLDREQUE0RCxnR0FBbUM7QUFDL0YsU0FBUztBQUNUO0FBQ0Esc0NBQXNDLGlFQUFhO0FBQ25ELG9DQUFvQyw4RUFBbUI7QUFDdkQsNkNBQTZDLGdGQUFvQjtBQUNqRSxnREFBZ0Qsc0ZBQXVCO0FBQ3ZFLDBDQUEwQyx5RUFBaUI7QUFDM0QsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLHFFQUFlO0FBQ3ZELDhDQUE4QyxrRkFBcUI7QUFDbkUsU0FBUztBQUNUO0FBQ0EsaURBQWlELHdGQUF3QjtBQUN6RSxrREFBa0QsbUZBQWtCO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQ0FBMkMseUVBQXNCO0FBQ2pFO0FBQ0EsZ0RBQWdELDZFQUF1QjtBQUN2RSxzREFBc0QsbUZBQTZCO0FBQ25GLCtDQUErQyxtRkFBc0I7QUFDckUsNENBQTRDLDZFQUFtQjtBQUMvRCxnREFBZ0QscUZBQXVCO0FBQ3ZFO0FBQ0EscUNBQXFDLCtFQUFvQjtBQUN6RCxxREFBcUQsc0ZBQTRCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXGRlZmF1bHQtbW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgY3JlYXRlR3JhbW1hckNvbmZpZyB9IGZyb20gJy4vbGFuZ3VhZ2VzL2dyYW1tYXItY29uZmlnLmpzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXBsZXRpb25QYXJzZXIgfSBmcm9tICcuL3BhcnNlci9jb21wbGV0aW9uLXBhcnNlci1idWlsZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxhbmdpdW1QYXJzZXIgfSBmcm9tICcuL3BhcnNlci9sYW5naXVtLXBhcnNlci1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRUb2tlbkJ1aWxkZXIgfSBmcm9tICcuL3BhcnNlci90b2tlbi1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRWYWx1ZUNvbnZlcnRlciB9IGZyb20gJy4vcGFyc2VyL3ZhbHVlLWNvbnZlcnRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0TGlua2VyIH0gZnJvbSAnLi9yZWZlcmVuY2VzL2xpbmtlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0TmFtZVByb3ZpZGVyIH0gZnJvbSAnLi9yZWZlcmVuY2VzL25hbWUtcHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFJlZmVyZW5jZXMgfSBmcm9tICcuL3JlZmVyZW5jZXMvcmVmZXJlbmNlcy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0U2NvcGVDb21wdXRhdGlvbiB9IGZyb20gJy4vcmVmZXJlbmNlcy9zY29wZS1jb21wdXRhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0U2NvcGVQcm92aWRlciB9IGZyb20gJy4vcmVmZXJlbmNlcy9zY29wZS1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SnNvblNlcmlhbGl6ZXIgfSBmcm9tICcuL3NlcmlhbGl6ZXIvanNvbi1zZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRTZXJ2aWNlUmVnaXN0cnkgfSBmcm9tICcuL3NlcnZpY2UtcmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgRGVmYXVsdERvY3VtZW50VmFsaWRhdG9yIH0gZnJvbSAnLi92YWxpZGF0aW9uL2RvY3VtZW50LXZhbGlkYXRvci5qcyc7XG5pbXBvcnQgeyBWYWxpZGF0aW9uUmVnaXN0cnkgfSBmcm9tICcuL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIsIERlZmF1bHRSZWZlcmVuY2VEZXNjcmlwdGlvblByb3ZpZGVyIH0gZnJvbSAnLi93b3Jrc3BhY2UvYXN0LWRlc2NyaXB0aW9ucy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3IgfSBmcm9tICcuL3dvcmtzcGFjZS9hc3Qtbm9kZS1sb2NhdG9yLmpzJztcbmltcG9ydCB7IERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IERlZmF1bHREb2N1bWVudEJ1aWxkZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9kb2N1bWVudC1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMYW5naXVtRG9jdW1lbnRGYWN0b3J5LCBEZWZhdWx0TGFuZ2l1bURvY3VtZW50cyB9IGZyb20gJy4vd29ya3NwYWNlL2RvY3VtZW50cy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SW5kZXhNYW5hZ2VyIH0gZnJvbSAnLi93b3Jrc3BhY2UvaW5kZXgtbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0V29ya3NwYWNlTWFuYWdlciB9IGZyb20gJy4vd29ya3NwYWNlL3dvcmtzcGFjZS1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMZXhlciwgRGVmYXVsdExleGVyRXJyb3JNZXNzYWdlUHJvdmlkZXIgfSBmcm9tICcuL3BhcnNlci9sZXhlci5qcyc7XG5pbXBvcnQgeyBKU0RvY0RvY3VtZW50YXRpb25Qcm92aWRlciB9IGZyb20gJy4vZG9jdW1lbnRhdGlvbi9kb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRDb21tZW50UHJvdmlkZXIgfSBmcm9tICcuL2RvY3VtZW50YXRpb24vY29tbWVudC1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIgfSBmcm9tICcuL3BhcnNlci9sYW5naXVtLXBhcnNlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN5bmNQYXJzZXIgfSBmcm9tICcuL3BhcnNlci9hc3luYy1wYXJzZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFdvcmtzcGFjZUxvY2sgfSBmcm9tICcuL3dvcmtzcGFjZS93b3Jrc3BhY2UtbG9jay5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SHlkcmF0b3IgfSBmcm9tICcuL3NlcmlhbGl6ZXIvaHlkcmF0b3IuanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVwZW5kZW5jeSBpbmplY3Rpb24gbW9kdWxlIGNvbmZpZ3VyaW5nIHRoZSBkZWZhdWx0IGNvcmUgc2VydmljZXMuXG4gKiBUaGlzIGlzIGEgc2V0IG9mIHNlcnZpY2VzIHRoYXQgYXJlIGRlZGljYXRlZCB0byBhIHNwZWNpZmljIGxhbmd1YWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50YXRpb246IHtcbiAgICAgICAgICAgIENvbW1lbnRQcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdENvbW1lbnRQcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBEb2N1bWVudGF0aW9uUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IEpTRG9jRG9jdW1lbnRhdGlvblByb3ZpZGVyKHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZXI6IHtcbiAgICAgICAgICAgIEFzeW5jUGFyc2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0QXN5bmNQYXJzZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgR3JhbW1hckNvbmZpZzogKHNlcnZpY2VzKSA9PiBjcmVhdGVHcmFtbWFyQ29uZmlnKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIExhbmdpdW1QYXJzZXI6IChzZXJ2aWNlcykgPT4gY3JlYXRlTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBDb21wbGV0aW9uUGFyc2VyOiAoc2VydmljZXMpID0+IGNyZWF0ZUNvbXBsZXRpb25QYXJzZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgVmFsdWVDb252ZXJ0ZXI6ICgpID0+IG5ldyBEZWZhdWx0VmFsdWVDb252ZXJ0ZXIoKSxcbiAgICAgICAgICAgIFRva2VuQnVpbGRlcjogKCkgPT4gbmV3IERlZmF1bHRUb2tlbkJ1aWxkZXIoKSxcbiAgICAgICAgICAgIExleGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGV4ZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXI6ICgpID0+IG5ldyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIExleGVyRXJyb3JNZXNzYWdlUHJvdmlkZXI6ICgpID0+IG5ldyBEZWZhdWx0TGV4ZXJFcnJvck1lc3NhZ2VQcm92aWRlcigpXG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtzcGFjZToge1xuICAgICAgICAgICAgQXN0Tm9kZUxvY2F0b3I6ICgpID0+IG5ldyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3IoKSxcbiAgICAgICAgICAgIEFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgUmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdFJlZmVyZW5jZURlc2NyaXB0aW9uUHJvdmlkZXIoc2VydmljZXMpXG4gICAgICAgIH0sXG4gICAgICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgICAgICAgIExpbmtlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdExpbmtlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBOYW1lUHJvdmlkZXI6ICgpID0+IG5ldyBEZWZhdWx0TmFtZVByb3ZpZGVyKCksXG4gICAgICAgICAgICBTY29wZVByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2NvcGVQcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBTY29wZUNvbXB1dGF0aW9uOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2NvcGVDb21wdXRhdGlvbihzZXJ2aWNlcyksXG4gICAgICAgICAgICBSZWZlcmVuY2VzOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0UmVmZXJlbmNlcyhzZXJ2aWNlcylcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplcjoge1xuICAgICAgICAgICAgSHlkcmF0b3I6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRIeWRyYXRvcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBKc29uU2VyaWFsaXplcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdEpzb25TZXJpYWxpemVyKHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgICBEb2N1bWVudFZhbGlkYXRvcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdERvY3VtZW50VmFsaWRhdG9yKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFZhbGlkYXRpb25SZWdpc3RyeTogKHNlcnZpY2VzKSA9PiBuZXcgVmFsaWRhdGlvblJlZ2lzdHJ5KHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICBzaGFyZWQ6ICgpID0+IGNvbnRleHQuc2hhcmVkXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGRlcGVuZGVuY3kgaW5qZWN0aW9uIG1vZHVsZSBjb25maWd1cmluZyB0aGUgZGVmYXVsdCBzaGFyZWQgY29yZSBzZXJ2aWNlcy5cbiAqIFRoaXMgaXMgdGhlIHNldCBvZiBzZXJ2aWNlcyB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBsYW5ndWFnZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2VydmljZVJlZ2lzdHJ5OiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2VydmljZVJlZ2lzdHJ5KHNlcnZpY2VzKSxcbiAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICBMYW5naXVtRG9jdW1lbnRzOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGFuZ2l1bURvY3VtZW50cyhzZXJ2aWNlcyksXG4gICAgICAgICAgICBMYW5naXVtRG9jdW1lbnRGYWN0b3J5OiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGFuZ2l1bURvY3VtZW50RmFjdG9yeShzZXJ2aWNlcyksXG4gICAgICAgICAgICBEb2N1bWVudEJ1aWxkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHREb2N1bWVudEJ1aWxkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgSW5kZXhNYW5hZ2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0SW5kZXhNYW5hZ2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFdvcmtzcGFjZU1hbmFnZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRXb3Jrc3BhY2VNYW5hZ2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIEZpbGVTeXN0ZW1Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBjb250ZXh0LmZpbGVTeXN0ZW1Qcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBXb3Jrc3BhY2VMb2NrOiAoKSA9PiBuZXcgRGVmYXVsdFdvcmtzcGFjZUxvY2soKSxcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb25Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlcihzZXJ2aWNlcylcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LW1vZHVsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/default-module.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/dependency-injection.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/dependency-injection.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Module: () => (/* binding */ Module),\n/* harmony export */   eagerLoad: () => (/* binding */ eagerLoad),\n/* harmony export */   inject: () => (/* binding */ inject)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nvar Module;\n(function (Module) {\n    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nfunction inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n    return _inject(module);\n}\nconst isProxy = Symbol('isProxy');\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nfunction eagerLoad(item) {\n    if (item && item[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: () => false,\n        set: () => {\n            throw new Error('Cannot set property on injected service container');\n        },\n        get: (obj, prop) => {\n            if (prop === isProxy) {\n                return true;\n            }\n            else {\n                return _resolve(obj, prop, module, injector || proxy);\n            }\n        },\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\n        has: (_, prop) => prop in module, // used by ..in..\n        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in\n    });\n    return proxy;\n}\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\n        }\n        return obj[prop];\n    }\n    else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\n        }\n        catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\n                    target[key] = _merge(value1, value2);\n                }\n                else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=dependency-injection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZGVwZW5kZW5jeS1pbmplY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQ0FBK0M7QUFDL0MsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsa0JBQWtCO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXGRlcGVuZGVuY3ktaW5qZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCB2YXIgTW9kdWxlO1xuKGZ1bmN0aW9uIChNb2R1bGUpIHtcbiAgICBNb2R1bGUubWVyZ2UgPSAobTEsIG0yKSA9PiBfbWVyZ2UoX21lcmdlKHt9LCBtMSksIG0yKTtcbn0pKE1vZHVsZSB8fCAoTW9kdWxlID0ge30pKTtcbi8qKlxuICogR2l2ZW4gYSBzZXQgb2YgbW9kdWxlcywgdGhlIGluamVjdCBmdW5jdGlvbiByZXR1cm5zIGEgbGF6aWx5IGV2YWx1YXRlZCBpbmplY3RvclxuICogdGhhdCBpbmplY3RzIGRlcGVuZGVuY2llcyBpbnRvIHRoZSByZXF1ZXN0ZWQgc2VydmljZSB3aGVuIGl0IGlzIHJlcXVlc3RlZCB0aGVcbiAqIGZpcnN0IHRpbWUuIFN1YnNlcXVlbnQgcmVxdWVzdHMgd2lsbCByZXR1cm4gdGhlIHNhbWUgc2VydmljZS5cbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiBjeWNsaWMgZGVwZW5kZW5jaWVzLCBhbiBFcnJvciB3aWxsIGJlIHRocm93bi4gVGhpcyBjYW4gYmUgZml4ZWRcbiAqIGJ5IGluamVjdGluZyBhIHByb3ZpZGVyIGAoKSA9PiBUYCBpbnN0ZWFkIG9mIGEgYFRgLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIGFyZ3VtZW50cyBtYXkgYmUgb2JqZWN0cyBvciBhcnJheXMuIEhvd2V2ZXIsIHRoZSByZXN1bHQgd2lsbFxuICogYmUgYW4gb2JqZWN0LiBVc2luZyBpdCB3aXRoIGZvci4ub2Ygd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAcGFyYW0gbW9kdWxlMSBmaXJzdCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGUyIChvcHRpb25hbCkgc2Vjb25kIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTMgKG9wdGlvbmFsKSB0aGlyZCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU0IChvcHRpb25hbCkgZm91cnRoIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTUgKG9wdGlvbmFsKSBmaWZ0aCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU2IChvcHRpb25hbCkgc2l4dGggTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlNyAob3B0aW9uYWwpIHNldmVudGggTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlOCAob3B0aW9uYWwpIGVpZ2h0aCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU5IChvcHRpb25hbCkgbmludGggTW9kdWxlXG4gKiBAcmV0dXJucyBhIG5ldyBvYmplY3Qgb2YgdHlwZSBJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3QobW9kdWxlMSwgbW9kdWxlMiwgbW9kdWxlMywgbW9kdWxlNCwgbW9kdWxlNSwgbW9kdWxlNiwgbW9kdWxlNywgbW9kdWxlOCwgbW9kdWxlOSkge1xuICAgIGNvbnN0IG1vZHVsZSA9IFttb2R1bGUxLCBtb2R1bGUyLCBtb2R1bGUzLCBtb2R1bGU0LCBtb2R1bGU1LCBtb2R1bGU2LCBtb2R1bGU3LCBtb2R1bGU4LCBtb2R1bGU5XS5yZWR1Y2UoX21lcmdlLCB7fSk7XG4gICAgcmV0dXJuIF9pbmplY3QobW9kdWxlKTtcbn1cbmNvbnN0IGlzUHJveHkgPSBTeW1ib2woJ2lzUHJveHknKTtcbi8qKlxuICogRWFnZXJseSBsb2FkIGFsbCBzZXJ2aWNlcyBpbiB0aGUgZ2l2ZW4gZGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyLiBUaGlzIGlzIHNvbWV0aW1lc1xuICogbmVjZXNzYXJ5IGJlY2F1c2Ugc2VydmljZXMgY2FuIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBpbiB0aGVpciBjb25zdHJ1Y3RvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWdlckxvYWQoaXRlbSkge1xuICAgIGlmIChpdGVtICYmIGl0ZW1baXNQcm94eV0pIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKGl0ZW0pKSB7XG4gICAgICAgICAgICBlYWdlckxvYWQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGluamVjdG9yIGJ5IGNyZWF0aW5nIGEgcHJveHkuXG4gKiBJbnZhcmlhbnQ6IGluamVjdG9yIGlzIG9mIHR5cGUgSS4gSWYgaW5qZWN0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIFQgPSBJLlxuICovXG5mdW5jdGlvbiBfaW5qZWN0KG1vZHVsZSwgaW5qZWN0b3IpIHtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4gZmFsc2UsXG4gICAgICAgIHNldDogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHByb3BlcnR5IG9uIGluamVjdGVkIHNlcnZpY2UgY29udGFpbmVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogKG9iaiwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IGlzUHJveHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzb2x2ZShvYmosIHByb3AsIG1vZHVsZSwgaW5qZWN0b3IgfHwgcHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IChvYmosIHByb3ApID0+IChfcmVzb2x2ZShvYmosIHByb3AsIG1vZHVsZSwgaW5qZWN0b3IgfHwgcHJveHkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkpLCAvLyB1c2VkIGJ5IGZvci4uaW5cbiAgICAgICAgaGFzOiAoXywgcHJvcCkgPT4gcHJvcCBpbiBtb2R1bGUsIC8vIHVzZWQgYnkgLi5pbi4uXG4gICAgICAgIG93bktleXM6ICgpID0+IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2R1bGUpXSAvLyB1c2VkIGJ5IGZvci4uaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcHJveHk7XG59XG4vKipcbiAqIEludGVybmFsbHkgdXNlZCB0byB0YWcgYSByZXF1ZXN0ZWQgZGVwZW5kZW5jeSwgZGlyZWN0bHkgYmVmb3JlIGNhbGxpbmcgdGhlIGZhY3RvcnkuXG4gKiBUaGlzIGFsbG93cyB1cyB0byBmaW5kIGN5Y2xlcyBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24uXG4gKi9cbmNvbnN0IF9fcmVxdWVzdGVkX18gPSBTeW1ib2woKTtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgYG9ialtwcm9wXWAuIElmIHRoZSB2YWx1ZSBkb2VzIG5vdCBleGlzdCwgeWV0LCBpdCBpcyByZXNvbHZlZCBmcm9tXG4gKiB0aGUgbW9kdWxlIGRlc2NyaXB0aW9uLiBUaGUgcmVzdWx0IG9mIHNlcnZpY2UgZmFjdG9yaWVzIGlzIGNhY2hlZC4gR3JvdXBzIGFyZVxuICogcmVjdXJzaXZlbHkgcHJveGllZC5cbiAqXG4gKiBAcGFyYW0gb2JqIGFuIG9iamVjdCBob2xkaW5nIGFsbCBncm91cCBwcm94aWVzIGFuZCBzZXJ2aWNlc1xuICogQHBhcmFtIHByb3AgdGhlIGtleSBvZiBhIHZhbHVlIHdpdGhpbiBvYmpcbiAqIEBwYXJhbSBtb2R1bGUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgZ3JvdXBzIGFuZCBzZXJ2aWNlIGZhY3Rvcmllc1xuICogQHBhcmFtIGluamVjdG9yIHRoZSBmaXJzdCBsZXZlbCBwcm94eSB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBhbGwgdmFsdWVzXG4gKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIHZhbHVlIGBvYmpbcHJvcF1gXG4gKiBAdGhyb3dzIEVycm9yIGlmIGEgZGVwZW5kZW5jeSBjeWNsZSBpcyBkZXRlY3RlZFxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZShvYmosIHByb3AsIG1vZHVsZSwgaW5qZWN0b3IpIHtcbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdGlvbiBmYWlsdXJlLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgeW91ciBkZXBlbmRlbmNpZXMgYXJlIGNvbnN0cnVjdGFibGUuJywgeyBjYXVzZTogb2JqW3Byb3BdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT09IF9fcmVxdWVzdGVkX18pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGUgZGV0ZWN0ZWQuIFBsZWFzZSBtYWtlIFwiJyArIFN0cmluZyhwcm9wKSArICdcIiBsYXp5LiBWaXNpdCBodHRwczovL2xhbmdpdW0ub3JnL2RvY3MvcmVmZXJlbmNlL2NvbmZpZ3VyYXRpb24tc2VydmljZXMvI3Jlc29sdmluZy1jeWNsaWMtZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvcCBpbiBtb2R1bGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtb2R1bGVbcHJvcF07XG4gICAgICAgIG9ialtwcm9wXSA9IF9fcmVxdWVzdGVkX187XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSA/IHZhbHVlKGluamVjdG9yKSA6IF9pbmplY3QodmFsdWUsIGluamVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpbcHJvcF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwLW1lcmdlIG9mIHR3byBtb2R1bGVzIGJ5IHdyaXRpbmcgc291cmNlIGVudHJpZXMgaW50byB0aGUgdGFyZ2V0IG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHRoZSBtb2R1bGUgd2hpY2ggaXMgd3JpdHRlblxuICogQHBhcmFtIHNvdXJjZSB0aGUgbW9kdWxlIHdoaWNoIGlzIHJlYWRcbiAqIEByZXR1cm5zIHRoZSB0YXJnZXQgbW9kdWxlXG4gKi9cbmZ1bmN0aW9uIF9tZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTJdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMSA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZTEgIT09IG51bGwgJiYgdmFsdWUyICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZTEgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZTIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gX21lcmdlKHZhbHVlMSwgdmFsdWUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWUyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW5jeS1pbmplY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/dependency-injection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/documentation/comment-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/documentation/comment-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultCommentProvider: () => (/* binding */ DefaultCommentProvider)\n/* harmony export */ });\n/* harmony import */ var _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serializer/json-serializer.js */ \"(ssr)/./node_modules/langium/lib/serializer/json-serializer.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultCommentProvider {\n    constructor(services) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if ((0,_serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_0__.isAstNodeWithComment)(node)) {\n            return node.$comment;\n        }\n        return (_a = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.findCommentNode)(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n}\n//# sourceMappingURL=comment-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9jb21tZW50LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7QUFDaEI7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRkFBb0I7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQixvRUFBZTtBQUNwQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcZG9jdW1lbnRhdGlvblxcY29tbWVudC1wcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBpc0FzdE5vZGVXaXRoQ29tbWVudCB9IGZyb20gJy4uL3NlcmlhbGl6ZXIvanNvbi1zZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IGZpbmRDb21tZW50Tm9kZSB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdENvbW1lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyQ29uZmlnID0gKCkgPT4gc2VydmljZXMucGFyc2VyLkdyYW1tYXJDb25maWc7XG4gICAgfVxuICAgIGdldENvbW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc0FzdE5vZGVXaXRoQ29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuJGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IGZpbmRDb21tZW50Tm9kZShub2RlLiRjc3ROb2RlLCB0aGlzLmdyYW1tYXJDb25maWcoKS5tdWx0aWxpbmVDb21tZW50UnVsZXMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGV4dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tZW50LXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/documentation/comment-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/documentation/documentation-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langium/lib/documentation/documentation-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSDocDocumentationProvider: () => (/* binding */ JSDocDocumentationProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _jsdoc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsdoc.js */ \"(ssr)/./node_modules/langium/lib/documentation/jsdoc.js\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass JSDocDocumentationProvider {\n    constructor(services) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && (0,_jsdoc_js__WEBPACK_IMPORTED_MODULE_0__.isJSDoc)(comment)) {\n            const parsedJSDoc = (0,_jsdoc_js__WEBPACK_IMPORTED_MODULE_0__.parseJSDoc)(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        }\n        else {\n            return undefined;\n        }\n    }\n    documentationTagRenderer(_node, _tag) {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n        return undefined;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n//# sourceMappingURL=documentation-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9kb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDSDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBTztBQUM5QixnQ0FBZ0MscURBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYyxLQUFLLEdBQUcsVUFBVSxHQUFHO0FBQzFGLHVCQUF1QixRQUFRLElBQUksZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxkb2N1bWVudGF0aW9uXFxkb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IGlzSlNEb2MsIHBhcnNlSlNEb2MgfSBmcm9tICcuL2pzZG9jLmpzJztcbmV4cG9ydCBjbGFzcyBKU0RvY0RvY3VtZW50YXRpb25Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5jb21tZW50UHJvdmlkZXIgPSBzZXJ2aWNlcy5kb2N1bWVudGF0aW9uLkNvbW1lbnRQcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRhdGlvbihub2RlKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLmNvbW1lbnRQcm92aWRlci5nZXRDb21tZW50KG5vZGUpO1xuICAgICAgICBpZiAoY29tbWVudCAmJiBpc0pTRG9jKGNvbW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRKU0RvYyA9IHBhcnNlSlNEb2MoY29tbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkSlNEb2MudG9NYXJrZG93bih7XG4gICAgICAgICAgICAgICAgcmVuZGVyTGluazogKGxpbmssIGRpc3BsYXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRhdGlvbkxpbmtSZW5kZXJlcihub2RlLCBsaW5rLCBkaXNwbGF5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlclRhZzogKHRhZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudGF0aW9uVGFnUmVuZGVyZXIobm9kZSwgdGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkb2N1bWVudGF0aW9uTGlua1JlbmRlcmVyKG5vZGUsIG5hbWUsIGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IChfYSA9IHRoaXMuZmluZE5hbWVJblByZWNvbXB1dGVkU2NvcGVzKG5vZGUsIG5hbWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZpbmROYW1lSW5HbG9iYWxTY29wZShub2RlLCBuYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICYmIGRlc2NyaXB0aW9uLm5hbWVTZWdtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZGVzY3JpcHRpb24ubmFtZVNlZ21lbnQucmFuZ2Uuc3RhcnQubGluZSArIDE7XG4gICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXIgPSBkZXNjcmlwdGlvbi5uYW1lU2VnbWVudC5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgKyAxO1xuICAgICAgICAgICAgY29uc3QgdXJpID0gZGVzY3JpcHRpb24uZG9jdW1lbnRVcmkud2l0aCh7IGZyYWdtZW50OiBgTCR7bGluZX0sJHtjaGFyYWN0ZXJ9YCB9KTtcbiAgICAgICAgICAgIHJldHVybiBgWyR7ZGlzcGxheX1dKCR7dXJpLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50YXRpb25UYWdSZW5kZXJlcihfbm9kZSwgX3RhZykge1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgdGFnIHJlbmRlcmluZ1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kTmFtZUluUHJlY29tcHV0ZWRTY29wZXMobm9kZSwgbmFtZSkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KG5vZGUpO1xuICAgICAgICBjb25zdCBwcmVjb21wdXRlZCA9IGRvY3VtZW50LnByZWNvbXB1dGVkU2NvcGVzO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbERlc2NyaXB0aW9ucyA9IHByZWNvbXB1dGVkLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGFsbERlc2NyaXB0aW9ucy5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuJGNvbnRhaW5lcjtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kTmFtZUluR2xvYmFsU2NvcGUobm9kZSwgbmFtZSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMuaW5kZXhNYW5hZ2VyLmFsbEVsZW1lbnRzKCkuZmluZChlID0+IGUubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/documentation/documentation-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/documentation/jsdoc.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/documentation/jsdoc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isJSDoc: () => (/* binding */ isJSDoc),\n/* harmony export */   parseJSDoc: () => (/* binding */ parseJSDoc)\n/* harmony export */ });\n/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-languageserver-types */ \"(ssr)/./node_modules/vscode-languageserver-types/lib/esm/main.js\");\n/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/regexp-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/regexp-utils.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nfunction parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === 'string') {\n        position = start;\n        opts = options;\n    }\n    else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) {\n        position = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0);\n    }\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\nfunction isJSDoc(node, options) {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\nfunction getLines(node) {\n    let content = '';\n    if (typeof node === 'string') {\n        content = node;\n    }\n    else {\n        content = node.text;\n    }\n    const lines = content.split(_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__.NEWLINE_REGEXP);\n    return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: 'break',\n                    content: '',\n                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(position, position)\n                });\n            }\n        }\n        else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter + index);\n                const end = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: 'tag',\n                    content: value,\n                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\n        return tokens.slice(0, -1);\n    }\n    return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, characterIndex);\n        const end = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: 'text',\n            content: line,\n            range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end)\n        });\n    }\n    else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: 'text',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, matchIndex + characterIndex))\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: 'inline-tag',\n                content: tagName,\n                range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: 'text',\n                    content: value,\n                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            }\n            else {\n                tokens.push({\n                    type: 'text',\n                    content: '',\n                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex))\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: 'text',\n                content: endContent,\n                range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n            });\n        }\n    }\n    return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index;\n    }\n    else {\n        return line.length;\n    }\n}\nfunction lastCharacter(line) {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === 'number') {\n        return match.index;\n    }\n    return undefined;\n}\n// Parsing\nfunction parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(startPosition, startPosition));\n    }\n    const elements = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new JSDocCommentImpl(elements, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end));\n}\nfunction parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === 'tag') {\n        return parseJSDocTag(context, false);\n    }\n    else if (next.type === 'text' || next.type === 'inline-tag') {\n        return parseJSDocText(context);\n    }\n    else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\nfunction appendEmptyLine(token, element) {\n    if (element) {\n        const line = new JSDocLineImpl('', token.range);\n        if ('inlines' in element) {\n            element.inlines.push(line);\n        }\n        else {\n            element.content.inlines.push(line);\n        }\n    }\n}\nfunction parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while (token && token.type !== 'break' && token.type !== 'tag') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === 'inline-tag') {\n        return parseJSDocTag(context, true);\n    }\n    else {\n        return parseJSDocLine(context);\n    }\n}\nfunction parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(tagToken.range.start, docLine.range.end));\n        }\n        else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(name, textDoc, inline, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    }\n    else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\nfunction parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n    if (!options) {\n        return normalizeOptions({\n            start: '/**',\n            end: '*/',\n            line: '*'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\nfunction normalizeOption(option, start) {\n    if (typeof option === 'string' || typeof option === 'object') {\n        const escaped = typeof option === 'string' ? (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegExp)(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        }\n        else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    }\n    else {\n        return option;\n    }\n}\nclass JSDocCommentImpl {\n    constructor(elements, range) {\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find(e => e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e) => 'name' in e);\n    }\n    toString() {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            }\n            else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            }\n            else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\nclass JSDocTagImpl {\n    constructor(name, content, inline, range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === 'string') {\n                return rendered;\n            }\n        }\n        let marker = '';\n        if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {\n            marker = '*';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {\n            marker = '**';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {\n            marker = '***';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text}  ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n}\nfunction renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\n        const index = content.indexOf(' ');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\nfunction renderLinkDefault(content, display) {\n    try {\n        _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(content, true);\n        return `[${display}](${content})`;\n    }\n    catch (_a) {\n        return content;\n    }\n}\nclass JSDocTextImpl {\n    constructor(lines, range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n}\nclass JSDocLineImpl {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n}\nfunction fillNewlines(text) {\n    if (text.endsWith('\\n')) {\n        return '\\n';\n    }\n    else {\n        return '\\n\\n';\n    }\n}\n//# sourceMappingURL=jsdoc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9qc2RvYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDVTtBQUM1QjtBQUNyQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtFQUFjO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQzFDLDBCQUEwQixNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUVBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFLO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFRO0FBQ3RDLDRCQUE0QixpRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOERBQUs7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBUTtBQUM5QixvQkFBb0IsaUVBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFLO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBSyxRQUFRLGlFQUFRLGdEQUFnRCxpRUFBUTtBQUN4RyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFLLFFBQVEsaUVBQVEseURBQXlELGlFQUFRO0FBQzdHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBSyxRQUFRLGlFQUFRLHlEQUF5RCxpRUFBUTtBQUNqSCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBSyxRQUFRLGlFQUFRLHlEQUF5RCxpRUFBUTtBQUNqSCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBSyxRQUFRLGlFQUFRLGdEQUFnRCxpRUFBUTtBQUNwRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVE7QUFDbEM7QUFDQSx3Q0FBd0MsOERBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsOERBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDhEQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsOERBQUs7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDhEQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9FQUFZO0FBQ2pFO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBLHNCQUFzQixNQUFNLEVBQUUsUUFBUTtBQUN0QztBQUNBO0FBQ0Esc0JBQXNCLEtBQUssSUFBSSxRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxHQUFHLFVBQVUsRUFBRSxPQUFPO0FBQ25EO0FBQ0Esc0JBQXNCLE1BQU0sSUFBSSxRQUFRO0FBQ3hDO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxJQUFJLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUUsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBRztBQUNYLG1CQUFtQixRQUFRLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXGRvY3VtZW50YXRpb25cXGpzZG9jLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFBvc2l0aW9uLCBSYW5nZSB9IGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcyc7XG5pbXBvcnQgeyBORVdMSU5FX1JFR0VYUCwgZXNjYXBlUmVnRXhwIH0gZnJvbSAnLi4vdXRpbHMvcmVnZXhwLXV0aWxzLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VKU0RvYyhub2RlLCBzdGFydCwgb3B0aW9ucykge1xuICAgIGxldCBvcHRzO1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICAgIG9wdHMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSBub2RlLnJhbmdlLnN0YXJ0O1xuICAgICAgICBvcHRzID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBQb3NpdGlvbi5jcmVhdGUoMCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gZ2V0TGluZXMobm9kZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdHMpO1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBvcHRpb25zOiBub3JtYWxpemVkT3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZUpTRG9jQ29tbWVudCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNKU0RvYyhub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbmVzID0gZ2V0TGluZXMobm9kZSk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gbGluZXNbMF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGZpcnN0UmVnZXggPSBub3JtYWxpemVkT3B0aW9ucy5zdGFydDtcbiAgICBjb25zdCBsYXN0UmVnZXggPSBub3JtYWxpemVkT3B0aW9ucy5lbmQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oZmlyc3RSZWdleCA9PT0gbnVsbCB8fCBmaXJzdFJlZ2V4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFJlZ2V4LmV4ZWMoZmlyc3QpKSAmJiBCb29sZWFuKGxhc3RSZWdleCA9PT0gbnVsbCB8fCBsYXN0UmVnZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RSZWdleC5leGVjKGxhc3QpKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzKG5vZGUpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudCA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoTkVXTElORV9SRUdFWFApO1xuICAgIHJldHVybiBsaW5lcztcbn1cbmNvbnN0IHRhZ1JlZ2V4ID0gL1xccyooQChbXFxwe0x9XVtcXHB7TH1cXHB7Tn1dKik/KS91eTtcbmNvbnN0IGlubGluZVRhZ1JlZ2V4ID0gL1xceyhAW1xccHtMfV1bXFxwe0x9XFxwe059XSopKFxccyopKFteXFxyXFxufV0rKT9cXH0vZ3U7XG5mdW5jdGlvbiB0b2tlbml6ZShjb250ZXh0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgbGV0IGN1cnJlbnRMaW5lID0gY29udGV4dC5wb3NpdGlvbi5saW5lO1xuICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY29udGV4dC5wb3NpdGlvbi5jaGFyYWN0ZXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0LmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gaSA9PT0gMDtcbiAgICAgICAgY29uc3QgbGFzdCA9IGkgPT09IGNvbnRleHQubGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGxpbmUgPSBjb250ZXh0LmxpbmVzW2ldO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBpZiAoZmlyc3QgJiYgY29udGV4dC5vcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IChfYSA9IGNvbnRleHQub3B0aW9ucy5zdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAoX2IgPSBjb250ZXh0Lm9wdGlvbnMubGluZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IChfYyA9IGNvbnRleHQub3B0aW9ucy5lbmQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5leGVjKGxpbmUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGFzdENoYXJhY3RlcihsaW5lKSk7XG4gICAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbmQgPSBza2lwV2hpdGVzcGFjZShsaW5lLCBpbmRleCk7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlRW5kID49IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIGJyZWFrIHRva2VuIHdoZW4gd2UgYWxyZWFkeSBoYXZlIHByZXZpb3VzIHRva2Vuc1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBQb3NpdGlvbi5jcmVhdGUoY3VycmVudExpbmUsIGN1cnJlbnRDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JyZWFrJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUocG9zaXRpb24sIHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnUmVnZXgubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCB0YWdNYXRjaCA9IHRhZ1JlZ2V4LmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAodGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSB0YWdNYXRjaFswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gUG9zaXRpb24uY3JlYXRlKGN1cnJlbnRMaW5lLCBjdXJyZW50Q2hhcmFjdGVyICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFBvc2l0aW9uLmNyZWF0ZShjdXJyZW50TGluZSwgY3VycmVudENoYXJhY3RlciArIGluZGV4ICsgZnVsbE1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoc3RhcnQsIGVuZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBmdWxsTWF0Y2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2tpcFdoaXRlc3BhY2UobGluZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gbGluZS5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZVRhZ01hdGNoZXMgPSBBcnJheS5mcm9tKHJlc3QubWF0Y2hBbGwoaW5saW5lVGFnUmVnZXgpKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCguLi5idWlsZElubGluZVRva2VucyhpbmxpbmVUYWdNYXRjaGVzLCByZXN0LCBjdXJyZW50TGluZSwgY3VycmVudENoYXJhY3RlciArIGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExpbmUrKztcbiAgICAgICAgY3VycmVudENoYXJhY3RlciA9IDA7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBsYXN0IGJyZWFrIHRva2VuIGlmIHRoZXJlIGlzIG9uZVxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09ICdicmVhaycpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBidWlsZElubGluZVRva2Vucyh0YWdzLCBsaW5lLCBsaW5lSW5kZXgsIGNoYXJhY3RlckluZGV4KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgY2hhcmFjdGVySW5kZXgpO1xuICAgICAgICBjb25zdCBlbmQgPSBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBjaGFyYWN0ZXJJbmRleCArIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgY29udGVudDogbGluZSxcbiAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoc3RhcnQsIGVuZClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0YWdzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBzdGFydENvbnRlbnQgPSBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBtYXRjaEluZGV4ICsgY2hhcmFjdGVySW5kZXgpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0Q29udGVudC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdpbmxpbmUtdGFnJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyB0YWdOYW1lLmxlbmd0aCArIGNoYXJhY3RlckluZGV4KSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRhZ05hbWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsyXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaFszXTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyB2YWx1ZS5sZW5ndGggKyBjaGFyYWN0ZXJJbmRleCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyBjaGFyYWN0ZXJJbmRleCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZENvbnRlbnQgPSBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICBpZiAoZW5kQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVuZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIGNoYXJhY3RlckluZGV4ICsgZW5kQ29udGVudC5sZW5ndGgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbmNvbnN0IG5vbldoaXRlc3BhY2VSZWdleCA9IC9cXFMvO1xuY29uc3Qgd2hpdGVzcGFjZUVuZFJlZ2V4ID0gL1xccyokLztcbmZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKGxpbmUsIGluZGV4KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLnN1YnN0cmluZyhpbmRleCkubWF0Y2gobm9uV2hpdGVzcGFjZVJlZ2V4KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgbWF0Y2guaW5kZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gbGFzdENoYXJhY3RlcihsaW5lKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHdoaXRlc3BhY2VFbmRSZWdleCk7XG4gICAgaWYgKG1hdGNoICYmIHR5cGVvZiBtYXRjaC5pbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gUGFyc2luZ1xuZnVuY3Rpb24gcGFyc2VKU0RvY0NvbW1lbnQoY29udGV4dCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gUG9zaXRpb24uY3JlYXRlKGNvbnRleHQucG9zaXRpb24ubGluZSwgY29udGV4dC5wb3NpdGlvbi5jaGFyYWN0ZXIpO1xuICAgIGlmIChjb250ZXh0LnRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU0RvY0NvbW1lbnRJbXBsKFtdLCBSYW5nZS5jcmVhdGUoc3RhcnRQb3NpdGlvbiwgc3RhcnRQb3NpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHdoaWxlIChjb250ZXh0LmluZGV4IDwgY29udGV4dC50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZUpTRG9jRWxlbWVudChjb250ZXh0LCBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gKF9iID0gKF9hID0gZWxlbWVudHNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yYW5nZS5zdGFydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc3RhcnRQb3NpdGlvbjtcbiAgICBjb25zdCBlbmQgPSAoX2QgPSAoX2MgPSBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJhbmdlLmVuZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc3RhcnRQb3NpdGlvbjtcbiAgICByZXR1cm4gbmV3IEpTRG9jQ29tbWVudEltcGwoZWxlbWVudHMsIFJhbmdlLmNyZWF0ZShzdGFydCwgZW5kKSk7XG59XG5mdW5jdGlvbiBwYXJzZUpTRG9jRWxlbWVudChjb250ZXh0LCBsYXN0KSB7XG4gICAgY29uc3QgbmV4dCA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGlmIChuZXh0LnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUpTRG9jVGFnKGNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dC50eXBlID09PSAndGV4dCcgfHwgbmV4dC50eXBlID09PSAnaW5saW5lLXRhZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NUZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwZW5kRW1wdHlMaW5lKG5leHQsIGxhc3QpO1xuICAgICAgICBjb250ZXh0LmluZGV4Kys7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kRW1wdHlMaW5lKHRva2VuLCBlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBKU0RvY0xpbmVJbXBsKCcnLCB0b2tlbi5yYW5nZSk7XG4gICAgICAgIGlmICgnaW5saW5lcycgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5pbmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbnRlbnQuaW5saW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VKU0RvY1RleHQoY29udGV4dCkge1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0b2tlbjtcbiAgICBsZXQgbGFzdFRva2VuID0gdG9rZW47XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICB3aGlsZSAodG9rZW4gJiYgdG9rZW4udHlwZSAhPT0gJ2JyZWFrJyAmJiB0b2tlbi50eXBlICE9PSAndGFnJykge1xuICAgICAgICBsaW5lcy5wdXNoKHBhcnNlSlNEb2NJbmxpbmUoY29udGV4dCkpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKU0RvY1RleHRJbXBsKGxpbmVzLCBSYW5nZS5jcmVhdGUoZmlyc3RUb2tlbi5yYW5nZS5zdGFydCwgbGFzdFRva2VuLnJhbmdlLmVuZCkpO1xufVxuZnVuY3Rpb24gcGFyc2VKU0RvY0lubGluZShjb250ZXh0KSB7XG4gICAgY29uc3QgdG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2lubGluZS10YWcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUpTRG9jVGFnKGNvbnRleHQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NMaW5lKGNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSlNEb2NUYWcoY29udGV4dCwgaW5saW5lKSB7XG4gICAgY29uc3QgdGFnVG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4KytdO1xuICAgIGNvbnN0IG5hbWUgPSB0YWdUb2tlbi5jb250ZW50LnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICBpZiAoKG5leHRUb2tlbiA9PT0gbnVsbCB8fCBuZXh0VG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHRUb2tlbi50eXBlKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY0xpbmUgPSBwYXJzZUpTRG9jTGluZShjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNEb2NUYWdJbXBsKG5hbWUsIG5ldyBKU0RvY1RleHRJbXBsKFtkb2NMaW5lXSwgZG9jTGluZS5yYW5nZSksIGlubGluZSwgUmFuZ2UuY3JlYXRlKHRhZ1Rva2VuLnJhbmdlLnN0YXJ0LCBkb2NMaW5lLnJhbmdlLmVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dERvYyA9IHBhcnNlSlNEb2NUZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU0RvY1RhZ0ltcGwobmFtZSwgdGV4dERvYywgaW5saW5lLCBSYW5nZS5jcmVhdGUodGFnVG9rZW4ucmFuZ2Uuc3RhcnQsIHRleHREb2MucmFuZ2UuZW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGFnVG9rZW4ucmFuZ2U7XG4gICAgICAgIHJldHVybiBuZXcgSlNEb2NUYWdJbXBsKG5hbWUsIG5ldyBKU0RvY1RleHRJbXBsKFtdLCByYW5nZSksIGlubGluZSwgcmFuZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSlNEb2NMaW5lKGNvbnRleHQpIHtcbiAgICBjb25zdCB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXgrK107XG4gICAgcmV0dXJuIG5ldyBKU0RvY0xpbmVJbXBsKHRva2VuLmNvbnRlbnQsIHRva2VuLnJhbmdlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplT3B0aW9ucyh7XG4gICAgICAgICAgICBzdGFydDogJy8qKicsXG4gICAgICAgICAgICBlbmQ6ICcqLycsXG4gICAgICAgICAgICBsaW5lOiAnKidcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgbGluZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbm9ybWFsaXplT3B0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgZW5kOiBub3JtYWxpemVPcHRpb24oZW5kLCBmYWxzZSksXG4gICAgICAgIGxpbmU6IG5vcm1hbGl6ZU9wdGlvbihsaW5lLCB0cnVlKVxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb24ob3B0aW9uLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgPyBlc2NhcGVSZWdFeHAob3B0aW9uKSA6IG9wdGlvbi5zb3VyY2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxccyoke2VzY2FwZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXFxcXHMqJHtlc2NhcGVkfVxcXFxzKiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG59XG5jbGFzcyBKU0RvY0NvbW1lbnRJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cywgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIGdldFRhZyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRhZ3MoKS5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICB9XG4gICAgZ2V0VGFncyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRhZ3MoKS5maWx0ZXIoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgIH1cbiAgICBnZXRBbGxUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5maWx0ZXIoKGUpID0+ICduYW1lJyBpbiBlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBmaWxsTmV3bGluZXModmFsdWUpICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgICB0b01hcmtkb3duKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50LnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWxlbWVudC50b01hcmtkb3duKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGZpbGxOZXdsaW5lcyh2YWx1ZSkgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NUYWdJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250ZW50LCBpbmxpbmUsIHJhbmdlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuaW5saW5lID0gaW5saW5lO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgdGV4dCA9IGBAJHt0aGlzLm5hbWV9YDtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYCR7dGV4dH0gJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9XFxuJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgdGFncyBhcmUgc3Vycm91bmRlZCBieSBjdXJseSBicmFjZXNcbiAgICAgICAgICAgIHJldHVybiBgeyR7dGV4dH19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvTWFya2Rvd24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbmRlclRhZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMudG9NYXJrZG93bkRlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHRvTWFya2Rvd25EZWZhdWx0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC50b01hcmtkb3duKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkID0gcmVuZGVySW5saW5lVGFnKHRoaXMubmFtZSwgY29udGVudCwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZW5kZXJlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcmtlciA9ICcnO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50YWcpID09PSAnaXRhbGljJyB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRhZykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFya2VyID0gJyonO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGFnKSA9PT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSAnKionO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGFnKSA9PT0gJ2JvbGQtaXRhbGljJykge1xuICAgICAgICAgICAgbWFya2VyID0gJyoqKic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSBgJHttYXJrZXJ9QCR7dGhpcy5uYW1lfSR7bWFya2VyfWA7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaW5saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRleHQgPSBgJHt0ZXh0fSDigJQgJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9XFxuJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgdGFncyBhcmUgc3Vycm91bmRlZCBieSBjdXJseSBicmFjZXNcbiAgICAgICAgICAgIHJldHVybiBgeyR7dGV4dH19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5saW5lVGFnKHRhZywgY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHRhZyA9PT0gJ2xpbmtwbGFpbicgfHwgdGFnID09PSAnbGlua2NvZGUnIHx8IHRhZyA9PT0gJ2xpbmsnKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGVudC5pbmRleE9mKCcgJyk7XG4gICAgICAgIGxldCBkaXNwbGF5ID0gY29udGVudDtcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheVN0YXJ0ID0gc2tpcFdoaXRlc3BhY2UoY29udGVudCwgaW5kZXgpO1xuICAgICAgICAgICAgZGlzcGxheSA9IGNvbnRlbnQuc3Vic3RyaW5nKGRpc3BsYXlTdGFydCk7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09ICdsaW5rY29kZScgfHwgKHRhZyA9PT0gJ2xpbmsnICYmIG9wdGlvbnMubGluayA9PT0gJ2NvZGUnKSkge1xuICAgICAgICAgICAgLy8gU3Vycm91bmQgdGhlIGRpc3BsYXkgdmFsdWUgaW4gYSBtYXJrZG93biBpbmxpbmUgY29kZSBibG9ja1xuICAgICAgICAgICAgZGlzcGxheSA9IGBcXGAke2Rpc3BsYXl9XFxgYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlZExpbmsgPSAoX2IgPSAoX2EgPSBvcHRpb25zLnJlbmRlckxpbmspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGNvbnRlbnQsIGRpc3BsYXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiByZW5kZXJMaW5rRGVmYXVsdChjb250ZW50LCBkaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkTGluaztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckxpbmtEZWZhdWx0KGNvbnRlbnQsIGRpc3BsYXkpIHtcbiAgICB0cnkge1xuICAgICAgICBVUkkucGFyc2UoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBgWyR7ZGlzcGxheX1dKCR7Y29udGVudH0pYDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbn1cbmNsYXNzIEpTRG9jVGV4dEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCByYW5nZSkge1xuICAgICAgICB0aGlzLmlubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IHRoaXMuaW5saW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlubGluZXNbaSArIDFdO1xuICAgICAgICAgICAgdGV4dCArPSBpbmxpbmUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQucmFuZ2Uuc3RhcnQubGluZSA+IGlubGluZS5yYW5nZS5zdGFydC5saW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdG9NYXJrZG93bihvcHRpb25zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmxpbmUgPSB0aGlzLmlubGluZXNbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbmxpbmVzW2kgKyAxXTtcbiAgICAgICAgICAgIHRleHQgKz0gaW5saW5lLnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0LnJhbmdlLnN0YXJ0LmxpbmUgPiBpbmxpbmUucmFuZ2Uuc3RhcnQubGluZSkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NMaW5lSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgdG9NYXJrZG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWxsTmV3bGluZXModGV4dCkge1xuICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcblxcbic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNkb2MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/documentation/jsdoc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/languages/generated/ast.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/languages/generated/ast.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractElement: () => (/* binding */ AbstractElement),\n/* harmony export */   AbstractRule: () => (/* binding */ AbstractRule),\n/* harmony export */   AbstractType: () => (/* binding */ AbstractType),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   Alternatives: () => (/* binding */ Alternatives),\n/* harmony export */   ArrayLiteral: () => (/* binding */ ArrayLiteral),\n/* harmony export */   ArrayType: () => (/* binding */ ArrayType),\n/* harmony export */   Assignment: () => (/* binding */ Assignment),\n/* harmony export */   BooleanLiteral: () => (/* binding */ BooleanLiteral),\n/* harmony export */   CharacterRange: () => (/* binding */ CharacterRange),\n/* harmony export */   Condition: () => (/* binding */ Condition),\n/* harmony export */   Conjunction: () => (/* binding */ Conjunction),\n/* harmony export */   CrossReference: () => (/* binding */ CrossReference),\n/* harmony export */   Disjunction: () => (/* binding */ Disjunction),\n/* harmony export */   EndOfFile: () => (/* binding */ EndOfFile),\n/* harmony export */   Grammar: () => (/* binding */ Grammar),\n/* harmony export */   GrammarImport: () => (/* binding */ GrammarImport),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   InferredType: () => (/* binding */ InferredType),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   Keyword: () => (/* binding */ Keyword),\n/* harmony export */   LangiumGrammarAstReflection: () => (/* binding */ LangiumGrammarAstReflection),\n/* harmony export */   LangiumGrammarTerminals: () => (/* binding */ LangiumGrammarTerminals),\n/* harmony export */   NamedArgument: () => (/* binding */ NamedArgument),\n/* harmony export */   NegatedToken: () => (/* binding */ NegatedToken),\n/* harmony export */   Negation: () => (/* binding */ Negation),\n/* harmony export */   NumberLiteral: () => (/* binding */ NumberLiteral),\n/* harmony export */   Parameter: () => (/* binding */ Parameter),\n/* harmony export */   ParameterReference: () => (/* binding */ ParameterReference),\n/* harmony export */   ParserRule: () => (/* binding */ ParserRule),\n/* harmony export */   ReferenceType: () => (/* binding */ ReferenceType),\n/* harmony export */   RegexToken: () => (/* binding */ RegexToken),\n/* harmony export */   ReturnType: () => (/* binding */ ReturnType),\n/* harmony export */   RuleCall: () => (/* binding */ RuleCall),\n/* harmony export */   SimpleType: () => (/* binding */ SimpleType),\n/* harmony export */   StringLiteral: () => (/* binding */ StringLiteral),\n/* harmony export */   TerminalAlternatives: () => (/* binding */ TerminalAlternatives),\n/* harmony export */   TerminalGroup: () => (/* binding */ TerminalGroup),\n/* harmony export */   TerminalRule: () => (/* binding */ TerminalRule),\n/* harmony export */   TerminalRuleCall: () => (/* binding */ TerminalRuleCall),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   TypeAttribute: () => (/* binding */ TypeAttribute),\n/* harmony export */   TypeDefinition: () => (/* binding */ TypeDefinition),\n/* harmony export */   UnionType: () => (/* binding */ UnionType),\n/* harmony export */   UnorderedGroup: () => (/* binding */ UnorderedGroup),\n/* harmony export */   UntilToken: () => (/* binding */ UntilToken),\n/* harmony export */   ValueLiteral: () => (/* binding */ ValueLiteral),\n/* harmony export */   Wildcard: () => (/* binding */ Wildcard),\n/* harmony export */   isAbstractElement: () => (/* binding */ isAbstractElement),\n/* harmony export */   isAbstractRule: () => (/* binding */ isAbstractRule),\n/* harmony export */   isAbstractType: () => (/* binding */ isAbstractType),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isAlternatives: () => (/* binding */ isAlternatives),\n/* harmony export */   isArrayLiteral: () => (/* binding */ isArrayLiteral),\n/* harmony export */   isArrayType: () => (/* binding */ isArrayType),\n/* harmony export */   isAssignment: () => (/* binding */ isAssignment),\n/* harmony export */   isBooleanLiteral: () => (/* binding */ isBooleanLiteral),\n/* harmony export */   isCharacterRange: () => (/* binding */ isCharacterRange),\n/* harmony export */   isCondition: () => (/* binding */ isCondition),\n/* harmony export */   isConjunction: () => (/* binding */ isConjunction),\n/* harmony export */   isCrossReference: () => (/* binding */ isCrossReference),\n/* harmony export */   isDisjunction: () => (/* binding */ isDisjunction),\n/* harmony export */   isEndOfFile: () => (/* binding */ isEndOfFile),\n/* harmony export */   isFeatureName: () => (/* binding */ isFeatureName),\n/* harmony export */   isGrammar: () => (/* binding */ isGrammar),\n/* harmony export */   isGrammarImport: () => (/* binding */ isGrammarImport),\n/* harmony export */   isGroup: () => (/* binding */ isGroup),\n/* harmony export */   isInferredType: () => (/* binding */ isInferredType),\n/* harmony export */   isInterface: () => (/* binding */ isInterface),\n/* harmony export */   isKeyword: () => (/* binding */ isKeyword),\n/* harmony export */   isNamedArgument: () => (/* binding */ isNamedArgument),\n/* harmony export */   isNegatedToken: () => (/* binding */ isNegatedToken),\n/* harmony export */   isNegation: () => (/* binding */ isNegation),\n/* harmony export */   isNumberLiteral: () => (/* binding */ isNumberLiteral),\n/* harmony export */   isParameter: () => (/* binding */ isParameter),\n/* harmony export */   isParameterReference: () => (/* binding */ isParameterReference),\n/* harmony export */   isParserRule: () => (/* binding */ isParserRule),\n/* harmony export */   isPrimitiveType: () => (/* binding */ isPrimitiveType),\n/* harmony export */   isReferenceType: () => (/* binding */ isReferenceType),\n/* harmony export */   isRegexToken: () => (/* binding */ isRegexToken),\n/* harmony export */   isReturnType: () => (/* binding */ isReturnType),\n/* harmony export */   isRuleCall: () => (/* binding */ isRuleCall),\n/* harmony export */   isSimpleType: () => (/* binding */ isSimpleType),\n/* harmony export */   isStringLiteral: () => (/* binding */ isStringLiteral),\n/* harmony export */   isTerminalAlternatives: () => (/* binding */ isTerminalAlternatives),\n/* harmony export */   isTerminalGroup: () => (/* binding */ isTerminalGroup),\n/* harmony export */   isTerminalRule: () => (/* binding */ isTerminalRule),\n/* harmony export */   isTerminalRuleCall: () => (/* binding */ isTerminalRuleCall),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isTypeAttribute: () => (/* binding */ isTypeAttribute),\n/* harmony export */   isTypeDefinition: () => (/* binding */ isTypeDefinition),\n/* harmony export */   isUnionType: () => (/* binding */ isUnionType),\n/* harmony export */   isUnorderedGroup: () => (/* binding */ isUnorderedGroup),\n/* harmony export */   isUntilToken: () => (/* binding */ isUntilToken),\n/* harmony export */   isValueLiteral: () => (/* binding */ isValueLiteral),\n/* harmony export */   isWildcard: () => (/* binding */ isWildcard),\n/* harmony export */   reflection: () => (/* binding */ reflection)\n/* harmony export */ });\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/******************************************************************************\n * This file was generated by langium-cli 3.3.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nconst LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\nconst AbstractRule = 'AbstractRule';\nfunction isAbstractRule(item) {\n    return reflection.isInstance(item, AbstractRule);\n}\nconst AbstractType = 'AbstractType';\nfunction isAbstractType(item) {\n    return reflection.isInstance(item, AbstractType);\n}\nconst Condition = 'Condition';\nfunction isCondition(item) {\n    return reflection.isInstance(item, Condition);\n}\nfunction isFeatureName(item) {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\nfunction isPrimitiveType(item) {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\nconst TypeDefinition = 'TypeDefinition';\nfunction isTypeDefinition(item) {\n    return reflection.isInstance(item, TypeDefinition);\n}\nconst ValueLiteral = 'ValueLiteral';\nfunction isValueLiteral(item) {\n    return reflection.isInstance(item, ValueLiteral);\n}\nconst AbstractElement = 'AbstractElement';\nfunction isAbstractElement(item) {\n    return reflection.isInstance(item, AbstractElement);\n}\nconst ArrayLiteral = 'ArrayLiteral';\nfunction isArrayLiteral(item) {\n    return reflection.isInstance(item, ArrayLiteral);\n}\nconst ArrayType = 'ArrayType';\nfunction isArrayType(item) {\n    return reflection.isInstance(item, ArrayType);\n}\nconst BooleanLiteral = 'BooleanLiteral';\nfunction isBooleanLiteral(item) {\n    return reflection.isInstance(item, BooleanLiteral);\n}\nconst Conjunction = 'Conjunction';\nfunction isConjunction(item) {\n    return reflection.isInstance(item, Conjunction);\n}\nconst Disjunction = 'Disjunction';\nfunction isDisjunction(item) {\n    return reflection.isInstance(item, Disjunction);\n}\nconst Grammar = 'Grammar';\nfunction isGrammar(item) {\n    return reflection.isInstance(item, Grammar);\n}\nconst GrammarImport = 'GrammarImport';\nfunction isGrammarImport(item) {\n    return reflection.isInstance(item, GrammarImport);\n}\nconst InferredType = 'InferredType';\nfunction isInferredType(item) {\n    return reflection.isInstance(item, InferredType);\n}\nconst Interface = 'Interface';\nfunction isInterface(item) {\n    return reflection.isInstance(item, Interface);\n}\nconst NamedArgument = 'NamedArgument';\nfunction isNamedArgument(item) {\n    return reflection.isInstance(item, NamedArgument);\n}\nconst Negation = 'Negation';\nfunction isNegation(item) {\n    return reflection.isInstance(item, Negation);\n}\nconst NumberLiteral = 'NumberLiteral';\nfunction isNumberLiteral(item) {\n    return reflection.isInstance(item, NumberLiteral);\n}\nconst Parameter = 'Parameter';\nfunction isParameter(item) {\n    return reflection.isInstance(item, Parameter);\n}\nconst ParameterReference = 'ParameterReference';\nfunction isParameterReference(item) {\n    return reflection.isInstance(item, ParameterReference);\n}\nconst ParserRule = 'ParserRule';\nfunction isParserRule(item) {\n    return reflection.isInstance(item, ParserRule);\n}\nconst ReferenceType = 'ReferenceType';\nfunction isReferenceType(item) {\n    return reflection.isInstance(item, ReferenceType);\n}\nconst ReturnType = 'ReturnType';\nfunction isReturnType(item) {\n    return reflection.isInstance(item, ReturnType);\n}\nconst SimpleType = 'SimpleType';\nfunction isSimpleType(item) {\n    return reflection.isInstance(item, SimpleType);\n}\nconst StringLiteral = 'StringLiteral';\nfunction isStringLiteral(item) {\n    return reflection.isInstance(item, StringLiteral);\n}\nconst TerminalRule = 'TerminalRule';\nfunction isTerminalRule(item) {\n    return reflection.isInstance(item, TerminalRule);\n}\nconst Type = 'Type';\nfunction isType(item) {\n    return reflection.isInstance(item, Type);\n}\nconst TypeAttribute = 'TypeAttribute';\nfunction isTypeAttribute(item) {\n    return reflection.isInstance(item, TypeAttribute);\n}\nconst UnionType = 'UnionType';\nfunction isUnionType(item) {\n    return reflection.isInstance(item, UnionType);\n}\nconst Action = 'Action';\nfunction isAction(item) {\n    return reflection.isInstance(item, Action);\n}\nconst Alternatives = 'Alternatives';\nfunction isAlternatives(item) {\n    return reflection.isInstance(item, Alternatives);\n}\nconst Assignment = 'Assignment';\nfunction isAssignment(item) {\n    return reflection.isInstance(item, Assignment);\n}\nconst CharacterRange = 'CharacterRange';\nfunction isCharacterRange(item) {\n    return reflection.isInstance(item, CharacterRange);\n}\nconst CrossReference = 'CrossReference';\nfunction isCrossReference(item) {\n    return reflection.isInstance(item, CrossReference);\n}\nconst EndOfFile = 'EndOfFile';\nfunction isEndOfFile(item) {\n    return reflection.isInstance(item, EndOfFile);\n}\nconst Group = 'Group';\nfunction isGroup(item) {\n    return reflection.isInstance(item, Group);\n}\nconst Keyword = 'Keyword';\nfunction isKeyword(item) {\n    return reflection.isInstance(item, Keyword);\n}\nconst NegatedToken = 'NegatedToken';\nfunction isNegatedToken(item) {\n    return reflection.isInstance(item, NegatedToken);\n}\nconst RegexToken = 'RegexToken';\nfunction isRegexToken(item) {\n    return reflection.isInstance(item, RegexToken);\n}\nconst RuleCall = 'RuleCall';\nfunction isRuleCall(item) {\n    return reflection.isInstance(item, RuleCall);\n}\nconst TerminalAlternatives = 'TerminalAlternatives';\nfunction isTerminalAlternatives(item) {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\nconst TerminalGroup = 'TerminalGroup';\nfunction isTerminalGroup(item) {\n    return reflection.isInstance(item, TerminalGroup);\n}\nconst TerminalRuleCall = 'TerminalRuleCall';\nfunction isTerminalRuleCall(item) {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\nconst UnorderedGroup = 'UnorderedGroup';\nfunction isUnorderedGroup(item) {\n    return reflection.isInstance(item, UnorderedGroup);\n}\nconst UntilToken = 'UntilToken';\nfunction isUntilToken(item) {\n    return reflection.isInstance(item, UntilToken);\n}\nconst Wildcard = 'Wildcard';\nfunction isWildcard(item) {\n    return reflection.isInstance(item, Wildcard);\n}\nclass LangiumGrammarAstReflection extends _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.AbstractAstReflection {\n    getAllTypes() {\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n    getTypeMetaData(type) {\n        switch (type) {\n            case AbstractElement: {\n                return {\n                    name: AbstractElement,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case ArrayLiteral: {\n                return {\n                    name: ArrayLiteral,\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case ArrayType: {\n                return {\n                    name: ArrayType,\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case BooleanLiteral: {\n                return {\n                    name: BooleanLiteral,\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case Conjunction: {\n                return {\n                    name: Conjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Disjunction: {\n                return {\n                    name: Disjunction,\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case Grammar: {\n                return {\n                    name: Grammar,\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case GrammarImport: {\n                return {\n                    name: GrammarImport,\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case InferredType: {\n                return {\n                    name: InferredType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case Interface: {\n                return {\n                    name: Interface,\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case NamedArgument: {\n                return {\n                    name: NamedArgument,\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Negation: {\n                return {\n                    name: Negation,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NumberLiteral: {\n                return {\n                    name: NumberLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case Parameter: {\n                return {\n                    name: Parameter,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case ParameterReference: {\n                return {\n                    name: ParameterReference,\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case ParserRule: {\n                return {\n                    name: ParserRule,\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case ReferenceType: {\n                return {\n                    name: ReferenceType,\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case ReturnType: {\n                return {\n                    name: ReturnType,\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case SimpleType: {\n                return {\n                    name: SimpleType,\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case StringLiteral: {\n                return {\n                    name: StringLiteral,\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case TerminalRule: {\n                return {\n                    name: TerminalRule,\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Type: {\n                return {\n                    name: Type,\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case TypeAttribute: {\n                return {\n                    name: TypeAttribute,\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case UnionType: {\n                return {\n                    name: UnionType,\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case Action: {\n                return {\n                    name: Action,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case Alternatives: {\n                return {\n                    name: Alternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Assignment: {\n                return {\n                    name: Assignment,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case CharacterRange: {\n                return {\n                    name: CharacterRange,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case CrossReference: {\n                return {\n                    name: CrossReference,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case EndOfFile: {\n                return {\n                    name: EndOfFile,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Group: {\n                return {\n                    name: Group,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case Keyword: {\n                return {\n                    name: Keyword,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case NegatedToken: {\n                return {\n                    name: NegatedToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case RegexToken: {\n                return {\n                    name: RegexToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case RuleCall: {\n                return {\n                    name: RuleCall,\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case TerminalAlternatives: {\n                return {\n                    name: TerminalAlternatives,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalGroup: {\n                return {\n                    name: TerminalGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case TerminalRuleCall: {\n                return {\n                    name: TerminalRuleCall,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case UnorderedGroup: {\n                return {\n                    name: UnorderedGroup,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case UntilToken: {\n                return {\n                    name: UntilToken,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case Wildcard: {\n                return {\n                    name: Wildcard,\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\nconst reflection = new LangiumGrammarAstReflection();\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPLDBDQUEwQyxrRUFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCLEdBQUcsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFrRDtBQUM1RSwwQkFBMEIsd0NBQXdDO0FBQ2xFLDBCQUEwQixtQ0FBbUM7QUFDN0QsMEJBQTBCLHNDQUFzQztBQUNoRSwwQkFBMEIseUNBQXlDO0FBQ25FLDBCQUEwQixjQUFjO0FBQ3hDLDBCQUEwQixpQ0FBaUM7QUFDM0QsMEJBQTBCLGlDQUFpQztBQUMzRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0NBQXNDO0FBQ2hFLDBCQUEwQixjQUFjO0FBQ3hDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBMkM7QUFDckUsMEJBQTBCLG1CQUFtQjtBQUM3QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDLDBCQUEwQixrREFBa0Q7QUFDNUUsMEJBQTBCLG9CQUFvQjtBQUM5QywwQkFBMEIsb0NBQW9DO0FBQzlELDBCQUEwQix1Q0FBdUM7QUFDakUsMEJBQTBCLHdDQUF3QztBQUNsRSwwQkFBMEIsc0JBQXNCO0FBQ2hELDBCQUEwQixjQUFjO0FBQ3hDLDBCQUEwQixzQ0FBc0M7QUFDaEUsMEJBQTBCLG9CQUFvQjtBQUM5QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pELDBCQUEwQixvQkFBb0I7QUFDOUMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QywwQkFBMEIsdUNBQXVDO0FBQ2pFLDBCQUEwQixxQ0FBcUM7QUFDL0QsMEJBQTBCLGNBQWM7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRCwwQkFBMEIseUNBQXlDO0FBQ25FLDBCQUEwQixjQUFjO0FBQ3hDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLGlCQUFpQjtBQUMzQywwQkFBMEIsc0JBQXNCO0FBQ2hELDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQixvQ0FBb0M7QUFDOUQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEIsaUJBQWlCO0FBQzNDLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQixjQUFjO0FBQ3hDLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEIsK0NBQStDO0FBQ3pFLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEIsd0JBQXdCO0FBQ2xELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLG1CQUFtQjtBQUM3QywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQ0FBcUM7QUFDL0QsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQixvQ0FBb0M7QUFDOUQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEIsbUJBQW1CO0FBQzdDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0MsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DLDBCQUEwQixtQkFBbUI7QUFDN0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxsYW5ndWFnZXNcXGdlbmVyYXRlZFxcYXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxhbmdpdW0tY2xpIDMuMy4wLlxuICogRE8gTk9UIEVESVQgTUFOVUFMTFkhXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIH0gZnJvbSAnLi4vLi4vc3ludGF4LXRyZWUuanMnO1xuZXhwb3J0IGNvbnN0IExhbmdpdW1HcmFtbWFyVGVybWluYWxzID0ge1xuICAgIElEOiAvXFxeP1tfYS16QS1aXVtcXHdfXSovLFxuICAgIFNUUklORzogL1wiKFxcXFwufFteXCJcXFxcXSkqXCJ8JyhcXFxcLnxbXidcXFxcXSkqJy8sXG4gICAgTlVNQkVSOiAvTmFOfC0/KChcXGQqXFwuXFxkK3xcXGQrKShbRWVdWystXT9cXGQrKT98SW5maW5pdHkpLyxcbiAgICBSZWdleExpdGVyYWw6IC9cXC8oPyFbKis/XSkoPzpbXlxcclxcblxcWy9cXFxcXXxcXFxcLnxcXFsoPzpbXlxcclxcblxcXVxcXFxdfFxcXFwuKSpcXF0pK1xcL1thLXpdKi8sXG4gICAgV1M6IC9cXHMrLyxcbiAgICBNTF9DT01NRU5UOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgU0xfQ09NTUVOVDogL1xcL1xcL1teXFxuXFxyXSovLFxufTtcbmV4cG9ydCBjb25zdCBBYnN0cmFjdFJ1bGUgPSAnQWJzdHJhY3RSdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0UnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBYnN0cmFjdFJ1bGUpO1xufVxuZXhwb3J0IGNvbnN0IEFic3RyYWN0VHlwZSA9ICdBYnN0cmFjdFR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWJzdHJhY3RUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFic3RyYWN0VHlwZSk7XG59XG5leHBvcnQgY29uc3QgQ29uZGl0aW9uID0gJ0NvbmRpdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNDb25kaXRpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29uZGl0aW9uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZlYXR1cmVOYW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gaXNQcmltaXRpdmVUeXBlKGl0ZW0pIHx8IGl0ZW0gPT09ICdjdXJyZW50JyB8fCBpdGVtID09PSAnZW50cnknIHx8IGl0ZW0gPT09ICdleHRlbmRzJyB8fCBpdGVtID09PSAnZmFsc2UnIHx8IGl0ZW0gPT09ICdmcmFnbWVudCcgfHwgaXRlbSA9PT0gJ2dyYW1tYXInIHx8IGl0ZW0gPT09ICdoaWRkZW4nIHx8IGl0ZW0gPT09ICdpbXBvcnQnIHx8IGl0ZW0gPT09ICdpbnRlcmZhY2UnIHx8IGl0ZW0gPT09ICdyZXR1cm5zJyB8fCBpdGVtID09PSAndGVybWluYWwnIHx8IGl0ZW0gPT09ICd0cnVlJyB8fCBpdGVtID09PSAndHlwZScgfHwgaXRlbSA9PT0gJ2luZmVyJyB8fCBpdGVtID09PSAnaW5mZXJzJyB8fCBpdGVtID09PSAnd2l0aCcgfHwgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiAoL1xcXj9bX2EtekEtWl1bXFx3X10qLy50ZXN0KGl0ZW0pKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSA9PT0gJ3N0cmluZycgfHwgaXRlbSA9PT0gJ251bWJlcicgfHwgaXRlbSA9PT0gJ2Jvb2xlYW4nIHx8IGl0ZW0gPT09ICdEYXRlJyB8fCBpdGVtID09PSAnYmlnaW50Jztcbn1cbmV4cG9ydCBjb25zdCBUeXBlRGVmaW5pdGlvbiA9ICdUeXBlRGVmaW5pdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlRGVmaW5pdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUeXBlRGVmaW5pdGlvbik7XG59XG5leHBvcnQgY29uc3QgVmFsdWVMaXRlcmFsID0gJ1ZhbHVlTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWx1ZUxpdGVyYWwoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVmFsdWVMaXRlcmFsKTtcbn1cbmV4cG9ydCBjb25zdCBBYnN0cmFjdEVsZW1lbnQgPSAnQWJzdHJhY3RFbGVtZW50JztcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0RWxlbWVudChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBYnN0cmFjdEVsZW1lbnQpO1xufVxuZXhwb3J0IGNvbnN0IEFycmF5TGl0ZXJhbCA9ICdBcnJheUxpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaXRlcmFsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFycmF5TGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgQXJyYXlUeXBlID0gJ0FycmF5VHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheVR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQXJyYXlUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBCb29sZWFuTGl0ZXJhbCA9ICdCb29sZWFuTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBCb29sZWFuTGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgQ29uanVuY3Rpb24gPSAnQ29uanVuY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uanVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29uanVuY3Rpb24pO1xufVxuZXhwb3J0IGNvbnN0IERpc2p1bmN0aW9uID0gJ0Rpc2p1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2p1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIERpc2p1bmN0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBHcmFtbWFyID0gJ0dyYW1tYXInO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JhbW1hcihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcmFtbWFyKTtcbn1cbmV4cG9ydCBjb25zdCBHcmFtbWFySW1wb3J0ID0gJ0dyYW1tYXJJbXBvcnQnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JhbW1hckltcG9ydChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcmFtbWFySW1wb3J0KTtcbn1cbmV4cG9ydCBjb25zdCBJbmZlcnJlZFR5cGUgPSAnSW5mZXJyZWRUeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0luZmVycmVkVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBJbmZlcnJlZFR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IEludGVyZmFjZSA9ICdJbnRlcmZhY2UnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZXJmYWNlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEludGVyZmFjZSk7XG59XG5leHBvcnQgY29uc3QgTmFtZWRBcmd1bWVudCA9ICdOYW1lZEFyZ3VtZW50JztcbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVkQXJndW1lbnQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmFtZWRBcmd1bWVudCk7XG59XG5leHBvcnQgY29uc3QgTmVnYXRpb24gPSAnTmVnYXRpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmVnYXRpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmVnYXRpb24pO1xufVxuZXhwb3J0IGNvbnN0IE51bWJlckxpdGVyYWwgPSAnTnVtYmVyTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIE51bWJlckxpdGVyYWwpO1xufVxuZXhwb3J0IGNvbnN0IFBhcmFtZXRlciA9ICdQYXJhbWV0ZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyYW1ldGVyKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBhcmFtZXRlcik7XG59XG5leHBvcnQgY29uc3QgUGFyYW1ldGVyUmVmZXJlbmNlID0gJ1BhcmFtZXRlclJlZmVyZW5jZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbWV0ZXJSZWZlcmVuY2UoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUGFyYW1ldGVyUmVmZXJlbmNlKTtcbn1cbmV4cG9ydCBjb25zdCBQYXJzZXJSdWxlID0gJ1BhcnNlclJ1bGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyc2VyUnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQYXJzZXJSdWxlKTtcbn1cbmV4cG9ydCBjb25zdCBSZWZlcmVuY2VUeXBlID0gJ1JlZmVyZW5jZVR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZWZlcmVuY2VUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBSZXR1cm5UeXBlID0gJ1JldHVyblR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmV0dXJuVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZXR1cm5UeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBTaW1wbGVUeXBlID0gJ1NpbXBsZVR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2ltcGxlVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBTaW1wbGVUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBTdHJpbmdMaXRlcmFsID0gJ1N0cmluZ0xpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nTGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBTdHJpbmdMaXRlcmFsKTtcbn1cbmV4cG9ydCBjb25zdCBUZXJtaW5hbFJ1bGUgPSAnVGVybWluYWxSdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Rlcm1pbmFsUnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUZXJtaW5hbFJ1bGUpO1xufVxuZXhwb3J0IGNvbnN0IFR5cGUgPSAnVHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IFR5cGVBdHRyaWJ1dGUgPSAnVHlwZUF0dHJpYnV0ZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlQXR0cmlidXRlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFR5cGVBdHRyaWJ1dGUpO1xufVxuZXhwb3J0IGNvbnN0IFVuaW9uVHlwZSA9ICdVbmlvblR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5pb25UeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFVuaW9uVHlwZSk7XG59XG5leHBvcnQgY29uc3QgQWN0aW9uID0gJ0FjdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNBY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQWN0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBBbHRlcm5hdGl2ZXMgPSAnQWx0ZXJuYXRpdmVzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FsdGVybmF0aXZlcyhpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBbHRlcm5hdGl2ZXMpO1xufVxuZXhwb3J0IGNvbnN0IEFzc2lnbm1lbnQgPSAnQXNzaWdubWVudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNBc3NpZ25tZW50KGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFzc2lnbm1lbnQpO1xufVxuZXhwb3J0IGNvbnN0IENoYXJhY3RlclJhbmdlID0gJ0NoYXJhY3RlclJhbmdlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0NoYXJhY3RlclJhbmdlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIENoYXJhY3RlclJhbmdlKTtcbn1cbmV4cG9ydCBjb25zdCBDcm9zc1JlZmVyZW5jZSA9ICdDcm9zc1JlZmVyZW5jZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNDcm9zc1JlZmVyZW5jZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBDcm9zc1JlZmVyZW5jZSk7XG59XG5leHBvcnQgY29uc3QgRW5kT2ZGaWxlID0gJ0VuZE9mRmlsZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNFbmRPZkZpbGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgRW5kT2ZGaWxlKTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cCA9ICdHcm91cCc7XG5leHBvcnQgZnVuY3Rpb24gaXNHcm91cChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcm91cCk7XG59XG5leHBvcnQgY29uc3QgS2V5d29yZCA9ICdLZXl3b3JkJztcbmV4cG9ydCBmdW5jdGlvbiBpc0tleXdvcmQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgS2V5d29yZCk7XG59XG5leHBvcnQgY29uc3QgTmVnYXRlZFRva2VuID0gJ05lZ2F0ZWRUb2tlbic7XG5leHBvcnQgZnVuY3Rpb24gaXNOZWdhdGVkVG9rZW4oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmVnYXRlZFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBSZWdleFRva2VuID0gJ1JlZ2V4VG9rZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnZXhUb2tlbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZWdleFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBSdWxlQ2FsbCA9ICdSdWxlQ2FsbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNSdWxlQ2FsbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSdWxlQ2FsbCk7XG59XG5leHBvcnQgY29uc3QgVGVybWluYWxBbHRlcm5hdGl2ZXMgPSAnVGVybWluYWxBbHRlcm5hdGl2ZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGVybWluYWxBbHRlcm5hdGl2ZXMoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVGVybWluYWxBbHRlcm5hdGl2ZXMpO1xufVxuZXhwb3J0IGNvbnN0IFRlcm1pbmFsR3JvdXAgPSAnVGVybWluYWxHcm91cCc7XG5leHBvcnQgZnVuY3Rpb24gaXNUZXJtaW5hbEdyb3VwKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFRlcm1pbmFsR3JvdXApO1xufVxuZXhwb3J0IGNvbnN0IFRlcm1pbmFsUnVsZUNhbGwgPSAnVGVybWluYWxSdWxlQ2FsbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNUZXJtaW5hbFJ1bGVDYWxsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFRlcm1pbmFsUnVsZUNhbGwpO1xufVxuZXhwb3J0IGNvbnN0IFVub3JkZXJlZEdyb3VwID0gJ1Vub3JkZXJlZEdyb3VwJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Vub3JkZXJlZEdyb3VwKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFVub3JkZXJlZEdyb3VwKTtcbn1cbmV4cG9ydCBjb25zdCBVbnRpbFRva2VuID0gJ1VudGlsVG9rZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW50aWxUb2tlbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBVbnRpbFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBXaWxkY2FyZCA9ICdXaWxkY2FyZCc7XG5leHBvcnQgZnVuY3Rpb24gaXNXaWxkY2FyZChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBXaWxkY2FyZCk7XG59XG5leHBvcnQgY2xhc3MgTGFuZ2l1bUdyYW1tYXJBc3RSZWZsZWN0aW9uIGV4dGVuZHMgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIHtcbiAgICBnZXRBbGxUeXBlcygpIHtcbiAgICAgICAgcmV0dXJuIFtBYnN0cmFjdEVsZW1lbnQsIEFic3RyYWN0UnVsZSwgQWJzdHJhY3RUeXBlLCBBY3Rpb24sIEFsdGVybmF0aXZlcywgQXJyYXlMaXRlcmFsLCBBcnJheVR5cGUsIEFzc2lnbm1lbnQsIEJvb2xlYW5MaXRlcmFsLCBDaGFyYWN0ZXJSYW5nZSwgQ29uZGl0aW9uLCBDb25qdW5jdGlvbiwgQ3Jvc3NSZWZlcmVuY2UsIERpc2p1bmN0aW9uLCBFbmRPZkZpbGUsIEdyYW1tYXIsIEdyYW1tYXJJbXBvcnQsIEdyb3VwLCBJbmZlcnJlZFR5cGUsIEludGVyZmFjZSwgS2V5d29yZCwgTmFtZWRBcmd1bWVudCwgTmVnYXRlZFRva2VuLCBOZWdhdGlvbiwgTnVtYmVyTGl0ZXJhbCwgUGFyYW1ldGVyLCBQYXJhbWV0ZXJSZWZlcmVuY2UsIFBhcnNlclJ1bGUsIFJlZmVyZW5jZVR5cGUsIFJlZ2V4VG9rZW4sIFJldHVyblR5cGUsIFJ1bGVDYWxsLCBTaW1wbGVUeXBlLCBTdHJpbmdMaXRlcmFsLCBUZXJtaW5hbEFsdGVybmF0aXZlcywgVGVybWluYWxHcm91cCwgVGVybWluYWxSdWxlLCBUZXJtaW5hbFJ1bGVDYWxsLCBUeXBlLCBUeXBlQXR0cmlidXRlLCBUeXBlRGVmaW5pdGlvbiwgVW5pb25UeXBlLCBVbm9yZGVyZWRHcm91cCwgVW50aWxUb2tlbiwgVmFsdWVMaXRlcmFsLCBXaWxkY2FyZF07XG4gICAgfVxuICAgIGNvbXB1dGVJc1N1YnR5cGUoc3VidHlwZSwgc3VwZXJ0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICAgICAgY2FzZSBBY3Rpb246XG4gICAgICAgICAgICBjYXNlIEFsdGVybmF0aXZlczpcbiAgICAgICAgICAgIGNhc2UgQXNzaWdubWVudDpcbiAgICAgICAgICAgIGNhc2UgQ2hhcmFjdGVyUmFuZ2U6XG4gICAgICAgICAgICBjYXNlIENyb3NzUmVmZXJlbmNlOlxuICAgICAgICAgICAgY2FzZSBFbmRPZkZpbGU6XG4gICAgICAgICAgICBjYXNlIEdyb3VwOlxuICAgICAgICAgICAgY2FzZSBLZXl3b3JkOlxuICAgICAgICAgICAgY2FzZSBOZWdhdGVkVG9rZW46XG4gICAgICAgICAgICBjYXNlIFJlZ2V4VG9rZW46XG4gICAgICAgICAgICBjYXNlIFJ1bGVDYWxsOlxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbEFsdGVybmF0aXZlczpcbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxHcm91cDpcbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxSdWxlQ2FsbDpcbiAgICAgICAgICAgIGNhc2UgVW5vcmRlcmVkR3JvdXA6XG4gICAgICAgICAgICBjYXNlIFVudGlsVG9rZW46XG4gICAgICAgICAgICBjYXNlIFdpbGRjYXJkOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEFic3RyYWN0RWxlbWVudCwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQXJyYXlMaXRlcmFsOlxuICAgICAgICAgICAgY2FzZSBOdW1iZXJMaXRlcmFsOlxuICAgICAgICAgICAgY2FzZSBTdHJpbmdMaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKFZhbHVlTGl0ZXJhbCwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQXJyYXlUeXBlOlxuICAgICAgICAgICAgY2FzZSBSZWZlcmVuY2VUeXBlOlxuICAgICAgICAgICAgY2FzZSBTaW1wbGVUeXBlOlxuICAgICAgICAgICAgY2FzZSBVbmlvblR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoVHlwZURlZmluaXRpb24sIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW5MaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKENvbmRpdGlvbiwgc3VwZXJ0eXBlKSB8fCB0aGlzLmlzU3VidHlwZShWYWx1ZUxpdGVyYWwsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbmp1bmN0aW9uOlxuICAgICAgICAgICAgY2FzZSBEaXNqdW5jdGlvbjpcbiAgICAgICAgICAgIGNhc2UgTmVnYXRpb246XG4gICAgICAgICAgICBjYXNlIFBhcmFtZXRlclJlZmVyZW5jZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShDb25kaXRpb24sIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEluZmVycmVkVHlwZTpcbiAgICAgICAgICAgIGNhc2UgSW50ZXJmYWNlOlxuICAgICAgICAgICAgY2FzZSBUeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEFic3RyYWN0VHlwZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUGFyc2VyUnVsZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShBYnN0cmFjdFJ1bGUsIHN1cGVydHlwZSkgfHwgdGhpcy5pc1N1YnR5cGUoQWJzdHJhY3RUeXBlLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbFJ1bGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQWJzdHJhY3RSdWxlLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWZlcmVuY2VUeXBlKHJlZkluZm8pIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSWQgPSBgJHtyZWZJbmZvLmNvbnRhaW5lci4kdHlwZX06JHtyZWZJbmZvLnByb3BlcnR5fWA7XG4gICAgICAgIHN3aXRjaCAocmVmZXJlbmNlSWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FjdGlvbjp0eXBlJzpcbiAgICAgICAgICAgIGNhc2UgJ0Nyb3NzUmVmZXJlbmNlOnR5cGUnOlxuICAgICAgICAgICAgY2FzZSAnSW50ZXJmYWNlOnN1cGVyVHlwZXMnOlxuICAgICAgICAgICAgY2FzZSAnUGFyc2VyUnVsZTpyZXR1cm5UeXBlJzpcbiAgICAgICAgICAgIGNhc2UgJ1NpbXBsZVR5cGU6dHlwZVJlZic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnR3JhbW1hcjpoaWRkZW5Ub2tlbnMnOlxuICAgICAgICAgICAgY2FzZSAnUGFyc2VyUnVsZTpoaWRkZW5Ub2tlbnMnOlxuICAgICAgICAgICAgY2FzZSAnUnVsZUNhbGw6cnVsZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RSdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnR3JhbW1hcjp1c2VkR3JhbW1hcnMnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyYW1tYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdOYW1lZEFyZ3VtZW50OnBhcmFtZXRlcic6XG4gICAgICAgICAgICBjYXNlICdQYXJhbWV0ZXJSZWZlcmVuY2U6cGFyYW1ldGVyJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbWV0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUZXJtaW5hbFJ1bGVDYWxsOnJ1bGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlcm1pbmFsUnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVmZXJlbmNlSWR9IGlzIG5vdCBhIHZhbGlkIHJlZmVyZW5jZSBpZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlTWV0YURhdGEodHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQWJzdHJhY3RFbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQWJzdHJhY3RFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQXJyYXlMaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQXJyYXlMaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQXJyYXlUeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQXJyYXlUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50VHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbkxpdGVyYWw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBCb29sZWFuTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHJ1ZScsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29uanVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBDb25qdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbGVmdCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0JyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBEaXNqdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IERpc2p1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsZWZ0JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmlnaHQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyYW1tYXI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBHcmFtbWFyLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbmVzSGlkZGVuVG9rZW5zJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaGlkZGVuVG9rZW5zJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaW1wb3J0cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ludGVyZmFjZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdpc0RlY2xhcmVkJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3J1bGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd1c2VkR3JhbW1hcnMnLCBkZWZhdWx0VmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyYW1tYXJJbXBvcnQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBHcmFtbWFySW1wb3J0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXRoJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJbmZlcnJlZFR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBJbmZlcnJlZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEludGVyZmFjZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEludGVyZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYXR0cmlidXRlcycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzdXBlclR5cGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBOYW1lZEFyZ3VtZW50OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogTmFtZWRBcmd1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FsbGVkQnlOYW1lJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGFyYW1ldGVyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5lZ2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogTmVnYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbHVlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBOdW1iZXJMaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogTnVtYmVyTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBhcmFtZXRlcjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUGFyYW1ldGVyUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogUGFyYW1ldGVyUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXJhbWV0ZXInIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBhcnNlclJ1bGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBQYXJzZXJSdWxlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkYXRhVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlZmluZXNIaWRkZW5Ub2tlbnMnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbml0aW9uJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZW50cnknLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmcmFnbWVudCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2hpZGRlblRva2VucycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luZmVycmVkVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXJhbWV0ZXJzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmV0dXJuVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3dpbGRjYXJkJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBSZWZlcmVuY2VUeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogUmVmZXJlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmVmZXJlbmNlVHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUmV0dXJuVHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFJldHVyblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNpbXBsZVR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBTaW1wbGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwcmltaXRpdmVUeXBlJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc3RyaW5nVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGVSZWYnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFN0cmluZ0xpdGVyYWw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBTdHJpbmdMaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2YWx1ZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxSdWxlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogVGVybWluYWxSdWxlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbml0aW9uJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZnJhZ21lbnQnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdoaWRkZW4nLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUeXBlQXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogVHlwZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGVmYXVsdFZhbHVlJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaXNPcHRpb25hbCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBVbmlvblR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBVbmlvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBY3Rpb246IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBBY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZmVhdHVyZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luZmVycmVkVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ29wZXJhdG9yJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQWx0ZXJuYXRpdmVzOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQWx0ZXJuYXRpdmVzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VsZW1lbnRzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBc3NpZ25tZW50OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmZWF0dXJlJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnb3BlcmF0b3InIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0ZXJtaW5hbCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ2hhcmFjdGVyUmFuZ2U6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBDaGFyYWN0ZXJSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsZWZ0JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmlnaHQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENyb3NzUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQ3Jvc3NSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGVwcmVjYXRlZFN5bnRheCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlcm1pbmFsJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW5kT2ZGaWxlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogRW5kT2ZGaWxlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JvdXA6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2d1YXJkQ29uZGl0aW9uJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBLZXl3b3JkOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogS2V5d29yZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2YWx1ZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTmVnYXRlZFRva2VuOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogTmVnYXRlZFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlcm1pbmFsJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBSZWdleFRva2VuOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogUmVnZXhUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdyZWdleCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUnVsZUNhbGw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBSdWxlQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYXJndW1lbnRzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdydWxlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbEFsdGVybmF0aXZlczoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFRlcm1pbmFsQWx0ZXJuYXRpdmVzLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VsZW1lbnRzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbEdyb3VwOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogVGVybWluYWxHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxSdWxlQ2FsbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFRlcm1pbmFsUnVsZUNhbGwsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncnVsZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVW5vcmRlcmVkR3JvdXA6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBVbm9yZGVyZWRHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVW50aWxUb2tlbjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFVudGlsVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGVybWluYWwnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFdpbGRjYXJkOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogV2lsZGNhcmQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCByZWZsZWN0aW9uID0gbmV3IExhbmdpdW1HcmFtbWFyQXN0UmVmbGVjdGlvbigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/languages/generated/ast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/languages/grammar-config.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/languages/grammar-config.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGrammarConfig: () => (/* binding */ createGrammarConfig)\n/* harmony export */ });\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/regexp-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/regexp-utils.js\");\n/* harmony import */ var _generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nfunction createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if ((0,_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule)(rule) && (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.isCommentTerminal)(rule) && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.isMultilineComment)((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.terminalRegex)(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_3__.DefaultNameRegexp\n    };\n}\n//# sourceMappingURL=grammar-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvbGFuZ3VhZ2VzL2dyYW1tYXItY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRDtBQUNtQjtBQUNmO0FBQ1Y7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQWMsVUFBVSwwRUFBaUIsVUFBVSwwRUFBa0IsQ0FBQyxzRUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFpQjtBQUNyQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcbGFuZ3VhZ2VzXFxncmFtbWFyLWNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBEZWZhdWx0TmFtZVJlZ2V4cCB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpc0NvbW1lbnRUZXJtaW5hbCwgdGVybWluYWxSZWdleCB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNNdWx0aWxpbmVDb21tZW50IH0gZnJvbSAnLi4vdXRpbHMvcmVnZXhwLXV0aWxzLmpzJztcbmltcG9ydCB7IGlzVGVybWluYWxSdWxlIH0gZnJvbSAnLi9nZW5lcmF0ZWQvYXN0LmpzJztcbi8qKlxuICogQ3JlYXRlIHRoZSBkZWZhdWx0IGdyYW1tYXIgY29uZmlndXJhdGlvbiAodXNlZCBieSBgY3JlYXRlRGVmYXVsdE1vZHVsZWApLiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGluIGFcbiAqIGxhbmd1YWdlLXNwZWNpZmljIG1vZHVsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyYW1tYXJDb25maWcoc2VydmljZXMpIHtcbiAgICBjb25zdCBydWxlcyA9IFtdO1xuICAgIGNvbnN0IGdyYW1tYXIgPSBzZXJ2aWNlcy5HcmFtbWFyO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBncmFtbWFyLnJ1bGVzKSB7XG4gICAgICAgIGlmIChpc1Rlcm1pbmFsUnVsZShydWxlKSAmJiBpc0NvbW1lbnRUZXJtaW5hbChydWxlKSAmJiBpc011bHRpbGluZUNvbW1lbnQodGVybWluYWxSZWdleChydWxlKSkpIHtcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gocnVsZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdWx0aWxpbmVDb21tZW50UnVsZXM6IHJ1bGVzLFxuICAgICAgICBuYW1lUmVnZXhwOiBEZWZhdWx0TmFtZVJlZ2V4cFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFtbWFyLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/languages/grammar-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/async-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/parser/async-parser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractThreadedAsyncParser: () => (/* binding */ AbstractThreadedAsyncParser),\n/* harmony export */   DefaultAsyncParser: () => (/* binding */ DefaultAsyncParser),\n/* harmony export */   ParserWorker: () => (/* binding */ ParserWorker)\n/* harmony export */ });\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/event.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/events.js\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Default implementation of the async parser which simply wraps the sync parser in a promise.\n *\n * @remarks\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nclass DefaultAsyncParser {\n    constructor(services) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text, _cancelToken) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n}\nclass AbstractThreadedAsyncParser {\n    constructor(services) {\n        /**\n         * The thread count determines how many threads are used to parse files in parallel.\n         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n         */\n        this.threadCount = 8;\n        /**\n         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n         * The default value is 200(ms).\n         */\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        let timeout;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n}\nclass ParserWorker {\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate) {\n        this.onReadyEmitter = new _utils_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter();\n        this.deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) {\n            throw new Error('Parser worker is busy');\n        }\n        this._parsing = true;\n        this.deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n//# sourceMappingURL=async-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2FzeW5jLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUU7QUFDN0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUVBQWtCO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQU87QUFDekMsNEJBQTRCLDZEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHBhcnNlclxcYXN5bmMtcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IERlZmVycmVkLCBPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi91dGlscy9ldmVudC5qcyc7XG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFzeW5jIHBhcnNlciB3aGljaCBzaW1wbHkgd3JhcHMgdGhlIHN5bmMgcGFyc2VyIGluIGEgcHJvbWlzZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSByZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIGNyZWF0ZSB3b3JrZXIgdGhyZWFkcyBvciB3ZWIgd29ya2VycyB0byBvZmZsb2FkIHRoZSBwYXJzaW5nIHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0QXN5bmNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuc3luY1BhcnNlciA9IHNlcnZpY2VzLnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIH1cbiAgICBwYXJzZSh0ZXh0LCBfY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnN5bmNQYXJzZXIucGFyc2UodGV4dCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFRocmVhZGVkQXN5bmNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGhyZWFkIGNvdW50IGRldGVybWluZXMgaG93IG1hbnkgdGhyZWFkcyBhcmUgdXNlZCB0byBwYXJzZSBmaWxlcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgOC4gRGVjcmVhc2luZyB0aGlzIHZhbHVlIGluY3JlYXNlcyBzdGFydHVwIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2VzIHBhcmFsbGVsIHBhcnNpbmcgcGVyZm9ybWFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRocmVhZENvdW50ID0gODtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXJtaW5hdGlvbiBkZWxheSBkZXRlcm1pbmVzIGhvdyBsb25nIHRoZSBwYXJzZXIgd2FpdHMgZm9yIGEgdGhyZWFkIHRvIGZpbmlzaCBhZnRlciBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0LlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAyMDAobXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXJtaW5hdGlvbkRlbGF5ID0gMjAwO1xuICAgICAgICB0aGlzLndvcmtlclBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmh5ZHJhdG9yID0gc2VydmljZXMuc2VyaWFsaXplci5IeWRyYXRvcjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVdvcmtlcnMoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy50aHJlYWRDb3VudCkge1xuICAgICAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy5jcmVhdGVXb3JrZXIoKTtcbiAgICAgICAgICAgIHdvcmtlci5vblJlYWR5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5sb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHdvcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5hY3F1aXJlUGFyc2VyV29ya2VyKGNhbmNlbFRva2VuKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIC8vIElmIHRoZSBjYW5jZWxsYXRpb24gdG9rZW4gaXMgcmVxdWVzdGVkLCB3ZSB3YWl0IGZvciBhIGNlcnRhaW4gdGltZSBiZWZvcmUgdGVybWluYXRpbmcgdGhlIHdvcmtlci5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNhbmNlbGxhdGlvbiB0b2tlbiBsaXZlcyBsb25nZXIgdGhhbiB0aGUgcGFyc2luZyBwcm9jZXNzLCB3ZSBuZWVkIHRvIGRpc3Bvc2UgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG1pZ2h0IGFjY2lkZW50YWxseSB0ZXJtaW5hdGUgdGhlIHdvcmtlciBhZnRlciB0aGUgcGFyc2luZyBwcm9jZXNzIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uID0gY2FuY2VsVG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlV29ya2VyKHdvcmtlcik7XG4gICAgICAgICAgICB9LCB0aGlzLnRlcm1pbmF0aW9uRGVsYXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyLnBhcnNlKHRleHQpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkID0gdGhpcy5oeWRyYXRvci5oeWRyYXRlKHJlc3VsdCk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGh5ZHJhdGVkKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgdGVybWluYXRlV29ya2VyKHdvcmtlcikge1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy53b3JrZXJQb29sLmluZGV4T2Yod29ya2VyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUG9vbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGFjcXVpcmVQYXJzZXJXb3JrZXIoY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplV29ya2VycygpO1xuICAgICAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiB0aGlzLndvcmtlclBvb2wpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIucmVhZHkpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgY2FuY2VsVG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YoZGVmZXJyZWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoT3BlcmF0aW9uQ2FuY2VsbGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChkZWZlcnJlZCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYXJzZXJXb3JrZXIge1xuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgIH1cbiAgICBnZXQgb25SZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25SZWFkeUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNlbmRNZXNzYWdlLCBvbk1lc3NhZ2UsIG9uRXJyb3IsIHRlcm1pbmF0ZSkge1xuICAgICAgICB0aGlzLm9uUmVhZHlFbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGUgPSB0ZXJtaW5hdGU7XG4gICAgICAgIG9uTWVzc2FnZShyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlc29sdmUocGFyc2VSZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy51bmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy51bmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoT3BlcmF0aW9uQ2FuY2VsbGVkKTtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlKCk7XG4gICAgfVxuICAgIGxvY2soKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHVubG9jaygpIHtcbiAgICAgICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMub25SZWFkeUVtaXR0ZXIuZmlyZSgpO1xuICAgIH1cbiAgICBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciB3b3JrZXIgaXMgYnVzeScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnNpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/async-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/completion-parser-builder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langium/lib/parser/completion-parser-builder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCompletionParser: () => (/* binding */ createCompletionParser)\n/* harmony export */ });\n/* harmony import */ var _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langium-parser.js */ \"(ssr)/./node_modules/langium/lib/parser/langium-parser.js\");\n/* harmony import */ var _parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser-builder-base.js */ \"(ssr)/./node_modules/langium/lib/parser/parser-builder-base.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nfunction createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__.LangiumCompletionParser(services);\n    (0,_parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__.createParser)(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n//# sourceMappingURL=completion-parser-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2NvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUNOO0FBQ2pEO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qix1RUFBdUI7QUFDOUMsSUFBSSxxRUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxwYXJzZXJcXGNvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgTGFuZ2l1bUNvbXBsZXRpb25QYXJzZXIgfSBmcm9tICcuL2xhbmdpdW0tcGFyc2VyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gJy4vcGFyc2VyLWJ1aWxkZXItYmFzZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGxldGlvblBhcnNlcihzZXJ2aWNlcykge1xuICAgIGNvbnN0IGdyYW1tYXIgPSBzZXJ2aWNlcy5HcmFtbWFyO1xuICAgIGNvbnN0IGxleGVyID0gc2VydmljZXMucGFyc2VyLkxleGVyO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBMYW5naXVtQ29tcGxldGlvblBhcnNlcihzZXJ2aWNlcyk7XG4gICAgY3JlYXRlUGFyc2VyKGdyYW1tYXIsIHBhcnNlciwgbGV4ZXIuZGVmaW5pdGlvbik7XG4gICAgcGFyc2VyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHBhcnNlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/completion-parser-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/cst-node-builder.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/parser/cst-node-builder.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractCstNode: () => (/* binding */ AbstractCstNode),\n/* harmony export */   CompositeCstNodeImpl: () => (/* binding */ CompositeCstNodeImpl),\n/* harmony export */   CstNodeBuilder: () => (/* binding */ CstNodeBuilder),\n/* harmony export */   LeafCstNodeImpl: () => (/* binding */ LeafCstNodeImpl),\n/* harmony export */   RootCstNodeImpl: () => (/* binding */ RootCstNodeImpl)\n/* harmony export */ });\n/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-languageserver-types */ \"(ssr)/./node_modules/vscode-languageserver-types/lib/esm/main.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass CstNodeBuilder {\n    constructor() {\n        this.nodeStack = [];\n    }\n    get current() {\n        var _a;\n        return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;\n    }\n    buildRootNode(input) {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenToRange)(token), token.tokenType, !feature);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n    addHiddenNodes(tokens) {\n        const nodes = [];\n        for (const token of tokens) {\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenToRange)(token), token.tokenType, true);\n            leafNode.root = this.rootNode;\n            nodes.push(leafNode);\n        }\n        let current = this.current;\n        let added = false;\n        // If we are within a composite node, we add the hidden nodes to the content\n        if (current.content.length > 0) {\n            current.content.push(...nodes);\n            return;\n        }\n        // Otherwise we are at a newly created node\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\n        while (current.container) {\n            const index = current.container.content.indexOf(current);\n            if (index > 0) {\n                // Add the hidden nodes before the current node\n                current.container.content.splice(index, 0, ...nodes);\n                added = true;\n                break;\n            }\n            current = current.container;\n        }\n        // If we arrive at the root node, we add the hidden nodes at the beginning\n        // This is the case if the hidden nodes are the first nodes in the tree\n        if (!added) {\n            this.rootNode.content.unshift(...nodes);\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === 'string') {\n            this.current.astNode = item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n            this.removeNode(node);\n        }\n    }\n}\nclass AbstractCstNode {\n    /** @deprecated use `container` instead. */\n    get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */\n    get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) {\n            throw new Error('This node has no associated AST element');\n        }\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */\n    get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\nclass LeafCstNodeImpl extends AbstractCstNode {\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\nclass CompositeCstNodeImpl extends AbstractCstNode {\n    constructor() {\n        super(...arguments);\n        this.content = new CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */\n    get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        }\n        else {\n            return { start: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0), end: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0) };\n        }\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\nclass CstNodeContainer extends Array {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items) {\n            item.container = this.parent;\n        }\n    }\n}\nclass RootCstNodeImpl extends CompositeCstNodeImpl {\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input) {\n        super();\n        this._text = '';\n        this._text = input !== null && input !== void 0 ? input : '';\n    }\n}\n//# sourceMappingURL=cst-node-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2NzdC1ub2RlLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDRjtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlFQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsaUVBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsd0JBQXdCLG1CQUFtQjtBQUMzQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxpRUFBUSxvQkFBb0IsaUVBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHBhcnNlclxcY3N0LW5vZGUtYnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcyc7XG5pbXBvcnQgeyB0b2tlblRvUmFuZ2UgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIENzdE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJvb3ROb2RlO1xuICAgIH1cbiAgICBidWlsZFJvb3ROb2RlKGlucHV0KSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSBuZXcgUm9vdENzdE5vZGVJbXBsKGlucHV0KTtcbiAgICAgICAgdGhpcy5yb290Tm9kZS5yb290ID0gdGhpcy5yb290Tm9kZTtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbdGhpcy5yb290Tm9kZV07XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlO1xuICAgIH1cbiAgICBidWlsZENvbXBvc2l0ZU5vZGUoZmVhdHVyZSkge1xuICAgICAgICBjb25zdCBjb21wb3NpdGVOb2RlID0gbmV3IENvbXBvc2l0ZUNzdE5vZGVJbXBsKCk7XG4gICAgICAgIGNvbXBvc2l0ZU5vZGUuZ3JhbW1hclNvdXJjZSA9IGZlYXR1cmU7XG4gICAgICAgIGNvbXBvc2l0ZU5vZGUucm9vdCA9IHRoaXMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMuY3VycmVudC5jb250ZW50LnB1c2goY29tcG9zaXRlTm9kZSk7XG4gICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2goY29tcG9zaXRlTm9kZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVOb2RlO1xuICAgIH1cbiAgICBidWlsZExlYWZOb2RlKHRva2VuLCBmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbmV3IExlYWZDc3ROb2RlSW1wbCh0b2tlbi5zdGFydE9mZnNldCwgdG9rZW4uaW1hZ2UubGVuZ3RoLCB0b2tlblRvUmFuZ2UodG9rZW4pLCB0b2tlbi50b2tlblR5cGUsICFmZWF0dXJlKTtcbiAgICAgICAgbGVhZk5vZGUuZ3JhbW1hclNvdXJjZSA9IGZlYXR1cmU7XG4gICAgICAgIGxlYWZOb2RlLnJvb3QgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICB0aGlzLmN1cnJlbnQuY29udGVudC5wdXNoKGxlYWZOb2RlKTtcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmNvbnRlbnQuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbnRlbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIaWRkZW5Ob2Rlcyh0b2tlbnMpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbmV3IExlYWZDc3ROb2RlSW1wbCh0b2tlbi5zdGFydE9mZnNldCwgdG9rZW4uaW1hZ2UubGVuZ3RoLCB0b2tlblRvUmFuZ2UodG9rZW4pLCB0b2tlbi50b2tlblR5cGUsIHRydWUpO1xuICAgICAgICAgICAgbGVhZk5vZGUucm9vdCA9IHRoaXMucm9vdE5vZGU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGxlYWZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlIGFyZSB3aXRoaW4gYSBjb21wb3NpdGUgbm9kZSwgd2UgYWRkIHRoZSBoaWRkZW4gbm9kZXMgdG8gdGhlIGNvbnRlbnRcbiAgICAgICAgaWYgKGN1cnJlbnQuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50LmNvbnRlbnQucHVzaCguLi5ub2Rlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBhdCBhIG5ld2x5IGNyZWF0ZWQgbm9kZVxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGFkZGluZyB0aGUgaGlkZGVuIG5vZGVzIGhlcmUsIHdlIHNlYXJjaCBmb3IgdGhlIGZpcnN0IHBhcmVudCBub2RlIHdpdGggY29udGVudFxuICAgICAgICB3aGlsZSAoY3VycmVudC5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudC5jb250YWluZXIuY29udGVudC5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGlkZGVuIG5vZGVzIGJlZm9yZSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudC5jb250YWluZXIuY29udGVudC5zcGxpY2UoaW5kZXgsIDAsIC4uLm5vZGVzKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJyaXZlIGF0IHRoZSByb290IG5vZGUsIHdlIGFkZCB0aGUgaGlkZGVuIG5vZGVzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSBpZiB0aGUgaGlkZGVuIG5vZGVzIGFyZSB0aGUgZmlyc3Qgbm9kZXMgaW4gdGhlIHRyZWVcbiAgICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZS5jb250ZW50LnVuc2hpZnQoLi4ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIC8vIFRoZSBzcGVjaWZpZWQgaXRlbSBjb3VsZCBiZSBhIGRhdGF0eXBlICgkdHlwZSBpcyBzeW1ib2wpIG9yIGEgZnJhZ21lbnQgKCR0eXBlIGlzIHVuZGVmaW5lZClcbiAgICAgICAgLy8gT25seSBpZiB0aGUgJHR5cGUgaXMgYSBzdHJpbmcsIHdlIGFjdHVhbGx5IGFzc2lnbiB0aGUgZWxlbWVudFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uJHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXN0Tm9kZSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS4kY3N0Tm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gRW1wdHkgY29tcG9zaXRlIG5vZGVzIGFyZSBub3QgdmFsaWRcbiAgICAgICAgLy8gU2ltcGx5IHJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlXG4gICAgICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNvbnRlbnQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q3N0Tm9kZSB7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgY29udGFpbmVyYCBpbnN0ZWFkLiAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgZ3JhbW1hclNvdXJjZWAgaW5zdGVhZC4gKi9cbiAgICBnZXQgZmVhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbW1hclNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgYXN0Tm9kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHR5cGVvZiAoKF9hID0gdGhpcy5fYXN0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLiR0eXBlKSA9PT0gJ3N0cmluZycgPyB0aGlzLl9hc3ROb2RlIDogKF9iID0gdGhpcy5jb250YWluZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hc3ROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGhhcyBubyBhc3NvY2lhdGVkIEFTVCBlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHNldCBhc3ROb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FzdE5vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgYXN0Tm9kZWAgaW5zdGVhZC4gKi9cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0Tm9kZTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZnVsbFRleHQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLmVuZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExlYWZDc3ROb2RlSW1wbCBleHRlbmRzIEFic3RyYWN0Q3N0Tm9kZSB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCArIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgZ2V0IHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuVHlwZTtcbiAgICB9XG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCByYW5nZSwgdG9rZW5UeXBlLCBoaWRkZW4gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSBoaWRkZW47XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5fdG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbXBvc2l0ZUNzdE5vZGVJbXBsIGV4dGVuZHMgQWJzdHJhY3RDc3ROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENzdE5vZGVDb250YWluZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGNvbnRlbnRgIGluc3RlYWQuICovXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5maXJzdE5vbkhpZGRlbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vZmZzZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZCAtIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sYXN0Tm9uSGlkZGVuTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICB9XG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9uSGlkZGVuTm9kZTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb25IaWRkZW5Ob2RlO1xuICAgICAgICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmFuZ2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZTogZmlyc3RSYW5nZSB9ID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2U6IGxhc3RSYW5nZSB9ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VDYWNoZSA9IHsgc3RhcnQ6IGZpcnN0UmFuZ2Uuc3RhcnQsIGVuZDogbGFzdFJhbmdlLmVuZC5saW5lIDwgZmlyc3RSYW5nZS5zdGFydC5saW5lID8gZmlyc3RSYW5nZS5zdGFydCA6IGxhc3RSYW5nZS5lbmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZSgwLCAwKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUoMCwgMCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3ROb25IaWRkZW5Ob2RlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXTtcbiAgICB9XG4gICAgZ2V0IGxhc3ROb25IaWRkZW5Ob2RlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGlmICghY2hpbGQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIH1cbn1cbmNsYXNzIENzdE5vZGVDb250YWluZXIgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ3N0Tm9kZUNvbnRhaW5lci5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBwdXNoKC4uLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuYWRkUGFyZW50cyhpdGVtcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5wdXNoKC4uLml0ZW1zKTtcbiAgICB9XG4gICAgdW5zaGlmdCguLi5pdGVtcykge1xuICAgICAgICB0aGlzLmFkZFBhcmVudHMoaXRlbXMpO1xuICAgICAgICByZXR1cm4gc3VwZXIudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgfVxuICAgIHNwbGljZShzdGFydCwgY291bnQsIC4uLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuYWRkUGFyZW50cyhpdGVtcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5zcGxpY2Uoc3RhcnQsIGNvdW50LCAuLi5pdGVtcyk7XG4gICAgfVxuICAgIGFkZFBhcmVudHMoaXRlbXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpdGVtLmNvbnRhaW5lciA9IHRoaXMucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJvb3RDc3ROb2RlSW1wbCBleHRlbmRzIENvbXBvc2l0ZUNzdE5vZGVJbXBsIHtcbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLmVuZCk7XG4gICAgfVxuICAgIGdldCBmdWxsVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSAnJztcbiAgICAgICAgdGhpcy5fdGV4dCA9IGlucHV0ICE9PSBudWxsICYmIGlucHV0ICE9PSB2b2lkIDAgPyBpbnB1dCA6ICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdC1ub2RlLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/cst-node-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/langium-parser-builder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langium/lib/parser/langium-parser-builder.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLangiumParser: () => (/* binding */ createLangiumParser),\n/* harmony export */   prepareLangiumParser: () => (/* binding */ prepareLangiumParser)\n/* harmony export */ });\n/* harmony import */ var _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langium-parser.js */ \"(ssr)/./node_modules/langium/lib/parser/langium-parser.js\");\n/* harmony import */ var _parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser-builder-base.js */ \"(ssr)/./node_modules/langium/lib/parser/parser-builder-base.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nfunction createLangiumParser(services) {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nfunction prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__.LangiumParser(services);\n    return (0,_parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__.createParser)(grammar, parser, lexer.definition);\n}\n//# sourceMappingURL=langium-parser-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2xhbmdpdW0tcGFyc2VyLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qiw2REFBYTtBQUNwQyxXQUFXLHFFQUFZO0FBQ3ZCO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccGFyc2VyXFxsYW5naXVtLXBhcnNlci1idWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IExhbmdpdW1QYXJzZXIgfSBmcm9tICcuL2xhbmdpdW0tcGFyc2VyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gJy4vcGFyc2VyLWJ1aWxkZXItYmFzZS5qcyc7XG4vKipcbiAqIENyZWF0ZSBhbmQgZmluYWxpemUgYSBMYW5naXVtIHBhcnNlci4gVGhlIHBhcnNlciBydWxlcyBhcmUgZGVyaXZlZCBmcm9tIHRoZSBncmFtbWFyLCB3aGljaCBpc1xuICogYXZhaWxhYmxlIGF0IGBzZXJ2aWNlcy5HcmFtbWFyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhbmdpdW1QYXJzZXIoc2VydmljZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBwcmVwYXJlTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcyk7XG4gICAgcGFyc2VyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHBhcnNlcjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgTGFuZ2l1bSBwYXJzZXIgd2l0aG91dCBmaW5hbGl6aW5nIGl0LiBUaGlzIGlzIHVzZWQgdG8gZXh0cmFjdCBtb3JlIGRldGFpbGVkIGVycm9yXG4gKiBpbmZvcm1hdGlvbiB3aGVuIHRoZSBwYXJzZXIgaXMgaW5pdGlhbGx5IHZhbGlkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVMYW5naXVtUGFyc2VyKHNlcnZpY2VzKSB7XG4gICAgY29uc3QgZ3JhbW1hciA9IHNlcnZpY2VzLkdyYW1tYXI7XG4gICAgY29uc3QgbGV4ZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGV4ZXI7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IExhbmdpdW1QYXJzZXIoc2VydmljZXMpO1xuICAgIHJldHVybiBjcmVhdGVQYXJzZXIoZ3JhbW1hciwgcGFyc2VyLCBsZXhlci5kZWZpbml0aW9uKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdpdW0tcGFyc2VyLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/langium-parser-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/langium-parser.js":
/*!***********************************************************!*\
  !*** ./node_modules/langium/lib/parser/langium-parser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractLangiumParser: () => (/* binding */ AbstractLangiumParser),\n/* harmony export */   AbstractParserErrorMessageProvider: () => (/* binding */ AbstractParserErrorMessageProvider),\n/* harmony export */   DatatypeSymbol: () => (/* binding */ DatatypeSymbol),\n/* harmony export */   LangiumCompletionParser: () => (/* binding */ LangiumCompletionParser),\n/* harmony export */   LangiumParser: () => (/* binding */ LangiumParser),\n/* harmony export */   LangiumParserErrorMessageProvider: () => (/* binding */ LangiumParserErrorMessageProvider)\n/* harmony export */ });\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/* harmony import */ var chevrotain_allstar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chevrotain-allstar */ \"(ssr)/./node_modules/chevrotain-allstar/lib/index.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _cst_node_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cst-node-builder.js */ \"(ssr)/./node_modules/langium/lib/parser/cst-node-builder.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nconst DatatypeSymbol = Symbol('Datatype');\nfunction isDataTypeNode(node) {\n    return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = '\\u200B';\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nclass AbstractLangiumParser {\n    constructor(services) {\n        this._unorderedGroups = new Map();\n        this.allRules = new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    getRule(name) {\n        return this.allRules.get(name);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\nclass LangiumParser extends AbstractLangiumParser {\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services) {\n        super(services);\n        this.nodeBuilder = new _cst_node_builder_js__WEBPACK_IMPORTED_MODULE_2__.CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = this.computeRuleType(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    computeRuleType(rule) {\n        if (rule.fragment) {\n            return undefined;\n        }\n        else if ((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__.isDataTypeRule)(rule)) {\n            return DatatypeSymbol;\n        }\n        else {\n            const explicit = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__.getExplicitRuleType)(rule);\n            return explicit !== null && explicit !== void 0 ? explicit : rule.name;\n        }\n    }\n    parse(input, options = {}) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\n        if (!ruleMethod) {\n            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');\n        }\n        const result = ruleMethod.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        this.lexerResult = undefined;\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            lexerReport: lexerResult.report,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args) => {\n            // Only create a new AST node in case the calling rule is not a fragment rule\n            const createNode = !this.isRecording() && $type !== undefined;\n            if (createNode) {\n                const node = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = '';\n                }\n            }\n            let result;\n            try {\n                result = implementation(args);\n            }\n            catch (err) {\n                result = undefined;\n            }\n            if (result === undefined && createNode) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n    extractHiddenTokens(token) {\n        const hiddenTokens = this.lexerResult.hidden;\n        if (!hiddenTokens.length) {\n            return [];\n        }\n        const offset = token.startOffset;\n        for (let i = 0; i < hiddenTokens.length; i++) {\n            const token = hiddenTokens[i];\n            if (token.startOffset > offset) {\n                return hiddenTokens.splice(0, i);\n            }\n        }\n        return hiddenTokens.splice(0, hiddenTokens.length);\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const hiddenTokens = this.extractHiddenTokens(token);\n            this.nodeBuilder.addHiddenNodes(hiddenTokens);\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword)(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            }\n            else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!(0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword)(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        let cstNode;\n        if (!this.isRecording() && !fragment) {\n            // We only want to create a new CST node if the subrule actually creates a new AST node.\n            // In other cases like calls of fragment rules the current CST/AST is populated further.\n            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.\n            // This is intended, as fragment rules only enrich the current AST node\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        }\n        else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            }\n            else if (typeof result === 'object' && result) {\n                const object = this.assignWithoutOverride(result, current);\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            if (action.feature && action.operator) {\n                last = this.construct();\n                this.nodeBuilder.removeNode(last.$cstNode);\n                const node = this.nodeBuilder.buildCompositeNode(action);\n                node.content.push(last.$cstNode);\n                const newItem = { $type };\n                this.stack.push(newItem);\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n            else {\n                last.$type = $type;\n            }\n        }\n    }\n    construct() {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.linkContentToContainer)(obj);\n        this.nodeBuilder.construct(obj);\n        this.stack.pop();\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        }\n        else {\n            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.assignMandatoryProperties)(this.astReflection, obj);\n        }\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.getContainerOfType)(feature, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isCrossReference)(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === 'string') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        }\n        else {\n            item = value;\n        }\n        switch (operator) {\n            case '=': {\n                obj[feature] = item;\n                break;\n            }\n            case '?=': {\n                obj[feature] = true;\n                break;\n            }\n            case '+=': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            }\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        // The target was parsed from a unassigned subrule\n        // After the subrule construction, it received a cst node\n        // This CST node will later be overriden by the cst node builder\n        // To prevent references to stale AST nodes in the CST,\n        // we need to remove the reference here\n        const targetCstNode = target.$cstNode;\n        if (targetCstNode) {\n            targetCstNode.astNode = undefined;\n            target.$cstNode = undefined;\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n}\nclass AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage(options) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\nclass LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage({ expected, actual }) {\n        const expectedMsg = expected.LABEL\n            ? '`' + expected.LABEL + '`'\n            : expected.name.endsWith(':KW')\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\n                : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\nclass LangiumCompletionParser extends AbstractLangiumParser {\n    constructor() {\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {\n        // NOOP\n    }\n    construct() {\n        // NOOP\n        return undefined;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input, { mode: 'partial' });\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        this.allRules.set(rule.name, ruleMethod);\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            }\n            finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, fragment, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n}\nconst defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: 'full',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends chevrotain__WEBPACK_IMPORTED_MODULE_0__.EmbeddedActionsParser {\n    constructor(tokens, config) {\n        const useDefaultLookahead = config && 'maxLookahead' in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead\n                ? new chevrotain__WEBPACK_IMPORTED_MODULE_0__.LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new chevrotain_allstar__WEBPACK_IMPORTED_MODULE_1__.LLStarLookaheadStrategy({\n                    // If validations are skipped, don't log the lookahead warnings\n                    logging: config.skipValidations ? () => { } : undefined\n                }) }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n}\n//# sourceMappingURL=langium-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2xhbmdpdW0tcGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUc7QUFDeEM7QUFDNkI7QUFDVjtBQUM4QjtBQUN2RDtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixtQ0FBbUMsK0ZBQStGO0FBQ3JOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUVBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRFQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0EsdUNBQXVDLHNFQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNFQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkVBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEVBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWtCLFVBQVUscUVBQVk7QUFDdkU7QUFDQTtBQUNBLHlDQUF5Qyw2RUFBZ0I7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSxrRUFBMEI7QUFDekM7QUFDQTtBQUNBLGVBQWUsa0VBQTBCO0FBQ3pDO0FBQ0E7QUFDQSxlQUFlLGtFQUEwQjtBQUN6QztBQUNBO0FBQ0EsZUFBZSxrRUFBMEI7QUFDekM7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQXFEO0FBQ25GLG9DQUFvQyxjQUFjO0FBQ2xELDRCQUE0QixhQUFhLGNBQWMsYUFBYTtBQUNwRTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQsb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxrRUFBa0Usb0JBQW9CO0FBQ3RGLHNCQUFzQiw0REFBb0IsR0FBRyxtQ0FBbUM7QUFDaEYsc0JBQXNCLHVFQUF1QjtBQUM3QztBQUNBLGdFQUFnRTtBQUNoRSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccGFyc2VyXFxsYW5naXVtLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciwgRW1iZWRkZWRBY3Rpb25zUGFyc2VyLCBMTGtMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuaW1wb3J0IHsgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3kgfSBmcm9tICdjaGV2cm90YWluLWFsbHN0YXInO1xuaW1wb3J0IHsgaXNBc3NpZ25tZW50LCBpc0Nyb3NzUmVmZXJlbmNlLCBpc0tleXdvcmQgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBnZXRFeHBsaWNpdFJ1bGVUeXBlLCBpc0RhdGFUeXBlUnVsZSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgYXNzaWduTWFuZGF0b3J5UHJvcGVydGllcywgZ2V0Q29udGFpbmVyT2ZUeXBlLCBsaW5rQ29udGVudFRvQ29udGFpbmVyIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IENzdE5vZGVCdWlsZGVyIH0gZnJvbSAnLi9jc3Qtbm9kZS1idWlsZGVyLmpzJztcbmV4cG9ydCBjb25zdCBEYXRhdHlwZVN5bWJvbCA9IFN5bWJvbCgnRGF0YXR5cGUnKTtcbmZ1bmN0aW9uIGlzRGF0YVR5cGVOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS4kdHlwZSA9PT0gRGF0YXR5cGVTeW1ib2w7XG59XG5jb25zdCBydWxlU3VmZml4ID0gJ1xcdTIwMEInO1xuY29uc3Qgd2l0aFJ1bGVTdWZmaXggPSAobmFtZSkgPT4gbmFtZS5lbmRzV2l0aChydWxlU3VmZml4KSA/IG5hbWUgOiBuYW1lICsgcnVsZVN1ZmZpeDtcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdExhbmdpdW1QYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuX3Vub3JkZXJlZEdyb3VwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxSdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sZXhlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlcjtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5sZXhlci5kZWZpbml0aW9uO1xuICAgICAgICBjb25zdCBwcm9kdWN0aW9uID0gc2VydmljZXMuTGFuZ3VhZ2VNZXRhRGF0YS5tb2RlID09PSAncHJvZHVjdGlvbic7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IG5ldyBDaGV2cm90YWluV3JhcHBlcih0b2tlbnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmljZXMucGFyc2VyLlBhcnNlckNvbmZpZyksIHsgc2tpcFZhbGlkYXRpb25zOiBwcm9kdWN0aW9uLCBlcnJvck1lc3NhZ2VQcm92aWRlcjogc2VydmljZXMucGFyc2VyLlBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIH0pKTtcbiAgICB9XG4gICAgYWx0ZXJuYXRpdmVzKGlkeCwgY2hvaWNlcykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE9yKGlkeCwgY2hvaWNlcyk7XG4gICAgfVxuICAgIG9wdGlvbmFsKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLndyYXBPcHRpb24oaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG1hbnkoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE1hbnkoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcEF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldFJ1bGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSdWxlcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIGlzUmVjb3JkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLklTX1JFQ09SRElORztcbiAgICB9XG4gICAgZ2V0IHVub3JkZXJlZEdyb3VwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Vub3JkZXJlZEdyb3VwcztcbiAgICB9XG4gICAgZ2V0UnVsZVN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLlJVTEVfU1RBQ0s7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcFNlbGZBbmFseXNpcygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RMYW5naXVtUGFyc2VyIHtcbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgc3VwZXIoc2VydmljZXMpO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyID0gbmV3IENzdE5vZGVCdWlsZGVyKCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmtlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IHNlcnZpY2VzLnBhcnNlci5WYWx1ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5hc3RSZWZsZWN0aW9uID0gc2VydmljZXMuc2hhcmVkLkFzdFJlZmxlY3Rpb247XG4gICAgfVxuICAgIHJ1bGUocnVsZSwgaW1wbCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5jb21wdXRlUnVsZVR5cGUocnVsZSk7XG4gICAgICAgIGNvbnN0IHJ1bGVNZXRob2QgPSB0aGlzLndyYXBwZXIuREVGSU5FX1JVTEUod2l0aFJ1bGVTdWZmaXgocnVsZS5uYW1lKSwgdGhpcy5zdGFydEltcGxlbWVudGF0aW9uKHR5cGUsIGltcGwpLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFsbFJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGVNZXRob2QpO1xuICAgICAgICBpZiAocnVsZS5lbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tYWluUnVsZSA9IHJ1bGVNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVNZXRob2Q7XG4gICAgfVxuICAgIGNvbXB1dGVSdWxlVHlwZShydWxlKSB7XG4gICAgICAgIGlmIChydWxlLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0YVR5cGVSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YXR5cGVTeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHBsaWNpdCA9IGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbGljaXQgIT09IG51bGwgJiYgZXhwbGljaXQgIT09IHZvaWQgMCA/IGV4cGxpY2l0IDogcnVsZS5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5idWlsZFJvb3ROb2RlKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGV4ZXJSZXN1bHQgPSB0aGlzLmxleGVyUmVzdWx0ID0gdGhpcy5sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5pbnB1dCA9IGxleGVyUmVzdWx0LnRva2VucztcbiAgICAgICAgY29uc3QgcnVsZU1ldGhvZCA9IG9wdGlvbnMucnVsZSA/IHRoaXMuYWxsUnVsZXMuZ2V0KG9wdGlvbnMucnVsZSkgOiB0aGlzLm1haW5SdWxlO1xuICAgICAgICBpZiAoIXJ1bGVNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnJ1bGUgPyBgTm8gcnVsZSBmb3VuZCB3aXRoIG5hbWUgJyR7b3B0aW9ucy5ydWxlfSdgIDogJ05vIG1haW4gcnVsZSBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcnVsZU1ldGhvZC5jYWxsKHRoaXMud3JhcHBlciwge30pO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLmFkZEhpZGRlbk5vZGVzKGxleGVyUmVzdWx0LmhpZGRlbik7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkR3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMubGV4ZXJSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgbGV4ZXJFcnJvcnM6IGxleGVyUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIGxleGVyUmVwb3J0OiBsZXhlclJlc3VsdC5yZXBvcnQsXG4gICAgICAgICAgICBwYXJzZXJFcnJvcnM6IHRoaXMud3JhcHBlci5lcnJvcnNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhcnRJbXBsZW1lbnRhdGlvbigkdHlwZSwgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyBBU1Qgbm9kZSBpbiBjYXNlIHRoZSBjYWxsaW5nIHJ1bGUgaXMgbm90IGEgZnJhZ21lbnQgcnVsZVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlTm9kZSA9ICF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgJHR5cGUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjcmVhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgJHR5cGUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlID09PSBEYXRhdHlwZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW1wbGVtZW50YXRpb24oYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGNyZWF0ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN0cnVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXh0cmFjdEhpZGRlblRva2Vucyh0b2tlbikge1xuICAgICAgICBjb25zdCBoaWRkZW5Ub2tlbnMgPSB0aGlzLmxleGVyUmVzdWx0LmhpZGRlbjtcbiAgICAgICAgaWYgKCFoaWRkZW5Ub2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4uc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlkZGVuVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGhpZGRlblRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydE9mZnNldCA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRkZW5Ub2tlbnMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5Ub2tlbnMuc3BsaWNlKDAsIGhpZGRlblRva2Vucy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdW1lKGlkeCwgdG9rZW5UeXBlLCBmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy53cmFwcGVyLndyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgdGhpcy5pc1ZhbGlkVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5Ub2tlbnMgPSB0aGlzLmV4dHJhY3RIaWRkZW5Ub2tlbnModG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5hZGRIaWRkZW5Ob2RlcyhoaWRkZW5Ub2tlbnMpO1xuICAgICAgICAgICAgY29uc3QgbGVhZk5vZGUgPSB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkTGVhZk5vZGUodG9rZW4sIGZlYXR1cmUpO1xuICAgICAgICAgICAgY29uc3QgeyBhc3NpZ25tZW50LCBpc0Nyb3NzUmVmIH0gPSB0aGlzLmdldEFzc2lnbm1lbnQoZmVhdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGlzS2V5d29yZChmZWF0dXJlKSA/IHRva2VuLmltYWdlIDogdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0b2tlbi5pbWFnZSwgbGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFzc2lnbm1lbnQub3BlcmF0b3IsIGFzc2lnbm1lbnQuZmVhdHVyZSwgY29udmVydGVkVmFsdWUsIGxlYWZOb2RlLCBpc0Nyb3NzUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YVR5cGVOb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB0b2tlbi5pbWFnZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzS2V5d29yZChmZWF0dXJlKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0ZXh0LCBsZWFmTm9kZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC52YWx1ZSArPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3QgY29uc3VtZWQgcGFyc2VyIHRva2VucyBhcmUgdmFsaWQuIEhvd2V2ZXIgdGhlcmUgYXJlIHR3byBjYXNlcyBpbiB3aGljaCB0aGV5IGFyZSBub3QgdmFsaWQ6XG4gICAgICpcbiAgICAgKiAxLiBUaGV5IHdlcmUgaW5zZXJ0ZWQgZHVyaW5nIGVycm9yIHJlY292ZXJ5IGJ5IHRoZSBwYXJzZXIuIFRoZXNlIHRva2VucyBkb24ndCByZWFsbHkgZXhpc3QgYW5kIHNob3VsZCBub3QgYmUgZnVydGhlciBwcm9jZXNzZWRcbiAgICAgKiAyLiBUaGV5IGNvbnRhaW4gaW52YWxpZCB0b2tlbiByYW5nZXMuIFRoaXMgbWlnaHQgaW5jbHVkZSB0aGUgc3BlY2lhbCBFT0YgdG9rZW4sIG9yIG90aGVyIHRva2VucyBwcm9kdWNlZCBieSBpbnZhbGlkIHRva2VuIGJ1aWxkZXJzLlxuICAgICAqL1xuICAgIGlzVmFsaWRUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gIXRva2VuLmlzSW5zZXJ0ZWRJblJlY292ZXJ5ICYmICFpc05hTih0b2tlbi5zdGFydE9mZnNldCkgJiYgdHlwZW9mIHRva2VuLmVuZE9mZnNldCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHRva2VuLmVuZE9mZnNldCk7XG4gICAgfVxuICAgIHN1YnJ1bGUoaWR4LCBydWxlLCBmcmFnbWVudCwgZmVhdHVyZSwgYXJncykge1xuICAgICAgICBsZXQgY3N0Tm9kZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgIWZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gY3JlYXRlIGEgbmV3IENTVCBub2RlIGlmIHRoZSBzdWJydWxlIGFjdHVhbGx5IGNyZWF0ZXMgYSBuZXcgQVNUIG5vZGUuXG4gICAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyBsaWtlIGNhbGxzIG9mIGZyYWdtZW50IHJ1bGVzIHRoZSBjdXJyZW50IENTVC9BU1QgaXMgcG9wdWxhdGVkIGZ1cnRoZXIuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgc2tpcHBpbmcgdGhpcyBpbml0aWFsaXphdGlvbiBhbmQgbGVhdmluZyBjc3ROb2RlIHVuYXNzaWduZWQgYWxzbyBza2lwcyB0aGUgc3VicnVsZSBhc3NpZ25tZW50IGxhdGVyIG9uLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbmRlZCwgYXMgZnJhZ21lbnQgcnVsZXMgb25seSBlbnJpY2ggdGhlIGN1cnJlbnQgQVNUIG5vZGVcbiAgICAgICAgICAgIGNzdE5vZGUgPSB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkQ29tcG9zaXRlTm9kZShmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJydWxlUmVzdWx0ID0gdGhpcy53cmFwcGVyLndyYXBTdWJydWxlKGlkeCwgcnVsZSwgYXJncyk7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpICYmIGNzdE5vZGUgJiYgY3N0Tm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1TdWJydWxlQXNzaWdubWVudChzdWJydWxlUmVzdWx0LCBmZWF0dXJlLCBjc3ROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZXJmb3JtU3VicnVsZUFzc2lnbm1lbnQocmVzdWx0LCBmZWF0dXJlLCBjc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHsgYXNzaWdubWVudCwgaXNDcm9zc1JlZiB9ID0gdGhpcy5nZXRBc3NpZ25tZW50KGZlYXR1cmUpO1xuICAgICAgICBpZiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24oYXNzaWdubWVudC5vcGVyYXRvciwgYXNzaWdubWVudC5mZWF0dXJlLCByZXN1bHQsIGNzdE5vZGUsIGlzQ3Jvc3NSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYWxsIGEgc3VicnVsZSB3aXRob3V0IGFuIGFzc2lnbm1lbnQgd2UgZWl0aGVyOlxuICAgICAgICAgICAgLy8gMS4gYXBwZW5kIHRoZSByZXN1bHQgb2YgdGhlIHN1YnJ1bGUgKGRhdGEgdHlwZSBydWxlKVxuICAgICAgICAgICAgLy8gMi4gb3ZlcnJpZGUgdGhlIGN1cnJlbnQgb2JqZWN0IHdpdGggdGhlIG5ld2x5IHBhcnNlZCBvYmplY3RcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYW4gQVNUIG5vZGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIHN1YnJ1bGVcbiAgICAgICAgICAgIC8vIGlzIGEgZGF0YSB0eXBlIHJ1bGUsIHdlIGNhbiBzYWZlbHkgZGlzY2FyZCB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNEYXRhVHlwZU5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnZhbHVlICs9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5hc3NpZ25XaXRob3V0T3ZlcnJpZGUocmVzdWx0LCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGlvbigkdHlwZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZmVhdHVyZSAmJiBhY3Rpb24ub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdGhpcy5jb25zdHJ1Y3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLnJlbW92ZU5vZGUobGFzdC4kY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUJ1aWxkZXIuYnVpbGRDb21wb3NpdGVOb2RlKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50LnB1c2gobGFzdC4kY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IHsgJHR5cGUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ24oYWN0aW9uLm9wZXJhdG9yLCBhY3Rpb24uZmVhdHVyZSwgbGFzdCwgbGFzdC4kY3N0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdC4kdHlwZSA9ICR0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGxpbmtDb250ZW50VG9Db250YWluZXIob2JqKTtcbiAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5jb25zdHJ1Y3Qob2JqKTtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGlzRGF0YVR5cGVOb2RlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRlci5jb252ZXJ0KG9iai52YWx1ZSwgb2JqLiRjc3ROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbk1hbmRhdG9yeVByb3BlcnRpZXModGhpcy5hc3RSZWZsZWN0aW9uLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGdldEFzc2lnbm1lbnQoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXNzaWdubWVudE1hcC5oYXMoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBnZXRDb250YWluZXJPZlR5cGUoZmVhdHVyZSwgaXNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudE1hcC5zZXQoZmVhdHVyZSwge1xuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQ6IGFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgaXNDcm9zc1JlZjogYXNzaWdubWVudCA/IGlzQ3Jvc3NSZWZlcmVuY2UoYXNzaWdubWVudC50ZXJtaW5hbCkgOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzaWdubWVudE1hcC5nZXQoZmVhdHVyZSk7XG4gICAgfVxuICAgIGFzc2lnbihvcGVyYXRvciwgZmVhdHVyZSwgdmFsdWUsIGNzdE5vZGUsIGlzQ3Jvc3NSZWYpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKGlzQ3Jvc3NSZWYgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMubGlua2VyLmJ1aWxkUmVmZXJlbmNlKG9iaiwgZmVhdHVyZSwgY3N0Tm9kZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgICAgICAgICAgb2JqW2ZlYXR1cmVdID0gaXRlbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJz89Jzoge1xuICAgICAgICAgICAgICAgIG9ialtmZWF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICcrPSc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2ZlYXR1cmVdKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmVhdHVyZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqW2ZlYXR1cmVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduV2l0aG91dE92ZXJyaWRlKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGV4aXN0aW5nVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBleGlzdGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCguLi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gZXhpc3RpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHdhcyBwYXJzZWQgZnJvbSBhIHVuYXNzaWduZWQgc3VicnVsZVxuICAgICAgICAvLyBBZnRlciB0aGUgc3VicnVsZSBjb25zdHJ1Y3Rpb24sIGl0IHJlY2VpdmVkIGEgY3N0IG5vZGVcbiAgICAgICAgLy8gVGhpcyBDU1Qgbm9kZSB3aWxsIGxhdGVyIGJlIG92ZXJyaWRlbiBieSB0aGUgY3N0IG5vZGUgYnVpbGRlclxuICAgICAgICAvLyBUbyBwcmV2ZW50IHJlZmVyZW5jZXMgdG8gc3RhbGUgQVNUIG5vZGVzIGluIHRoZSBDU1QsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgaGVyZVxuICAgICAgICBjb25zdCB0YXJnZXRDc3ROb2RlID0gdGFyZ2V0LiRjc3ROb2RlO1xuICAgICAgICBpZiAodGFyZ2V0Q3N0Tm9kZSkge1xuICAgICAgICAgICAgdGFyZ2V0Q3N0Tm9kZS5hc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGFyZ2V0LiRjc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGdldCBkZWZpbml0aW9uRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmRlZmluaXRpb25FcnJvcnM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0UGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIge1xuICAgIGJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZShvcHRpb25zKTtcbiAgICB9XG4gICAgYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgfVxuICAgIGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLmJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBidWlsZEVhcmx5RXhpdE1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIgZXh0ZW5kcyBBYnN0cmFjdFBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIHtcbiAgICBidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHsgZXhwZWN0ZWQsIGFjdHVhbCB9KSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTXNnID0gZXhwZWN0ZWQuTEFCRUxcbiAgICAgICAgICAgID8gJ2AnICsgZXhwZWN0ZWQuTEFCRUwgKyAnYCdcbiAgICAgICAgICAgIDogZXhwZWN0ZWQubmFtZS5lbmRzV2l0aCgnOktXJylcbiAgICAgICAgICAgICAgICA/IGBrZXl3b3JkICcke2V4cGVjdGVkLm5hbWUuc3Vic3RyaW5nKDAsIGV4cGVjdGVkLm5hbWUubGVuZ3RoIC0gMyl9J2BcbiAgICAgICAgICAgICAgICA6IGB0b2tlbiBvZiB0eXBlICcke2V4cGVjdGVkLm5hbWV9J2A7XG4gICAgICAgIHJldHVybiBgRXhwZWN0aW5nICR7ZXhwZWN0ZWRNc2d9IGJ1dCBmb3VuZCBcXGAke2FjdHVhbC5pbWFnZX1cXGAuYDtcbiAgICB9XG4gICAgYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2UoeyBmaXJzdFJlZHVuZGFudCB9KSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0aW5nIGVuZCBvZiBmaWxlIGJ1dCBmb3VuZCBcXGAke2ZpcnN0UmVkdW5kYW50LmltYWdlfVxcYC5gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtQ29tcGxldGlvblBhcnNlciBleHRlbmRzIEFic3RyYWN0TGFuZ2l1bVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgIH1cbiAgICBhY3Rpb24oKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICB9XG4gICAgY29uc3RydWN0KCkge1xuICAgICAgICAvLyBOT09QXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmxleGVyLnRva2VuaXplKGlucHV0LCB7IG1vZGU6ICdwYXJ0aWFsJyB9KTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnMudG9rZW5zO1xuICAgICAgICB0aGlzLndyYXBwZXIuaW5wdXQgPSBbLi4udGhpcy50b2tlbnNdO1xuICAgICAgICB0aGlzLm1haW5SdWxlLmNhbGwodGhpcy53cmFwcGVyLCB7fSk7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkR3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IHRoaXMudG9rZW5zLFxuICAgICAgICAgICAgZWxlbWVudFN0YWNrOiBbLi4udGhpcy5sYXN0RWxlbWVudFN0YWNrXSxcbiAgICAgICAgICAgIHRva2VuSW5kZXg6IHRoaXMubmV4dFRva2VuSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVsZShydWxlLCBpbXBsKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVNZXRob2QgPSB0aGlzLndyYXBwZXIuREVGSU5FX1JVTEUod2l0aFJ1bGVTdWZmaXgocnVsZS5uYW1lKSwgdGhpcy5zdGFydEltcGxlbWVudGF0aW9uKGltcGwpLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFsbFJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGVNZXRob2QpO1xuICAgICAgICBpZiAocnVsZS5lbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tYWluUnVsZSA9IHJ1bGVNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVNZXRob2Q7XG4gICAgfVxuICAgIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgIH1cbiAgICBzdGFydEltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMua2VlcFN0YWNrU2l6ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbihhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdGFja1NpemUoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbW92ZVVuZXhwZWN0ZWRFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuc3RhY2tTaXplKTtcbiAgICB9XG4gICAga2VlcFN0YWNrU2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgcmVzZXRTdGFja1NpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVVuZXhwZWN0ZWRFbGVtZW50cygpO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGNvbnN1bWUoaWR4LCB0b2tlblR5cGUsIGZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLndyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFsuLi50aGlzLmVsZW1lbnRTdGFjaywgZmVhdHVyZV07XG4gICAgICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gdGhpcy5jdXJySWR4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJydWxlKGlkeCwgcnVsZSwgZnJhZ21lbnQsIGZlYXR1cmUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5iZWZvcmUoZmVhdHVyZSk7XG4gICAgICAgIHRoaXMud3JhcHBlci53cmFwU3VicnVsZShpZHgsIHJ1bGUsIGFyZ3MpO1xuICAgICAgICB0aGlzLmFmdGVyKGZlYXR1cmUpO1xuICAgIH1cbiAgICBiZWZvcmUoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZnRlcihlbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZWxlbWVudFN0YWNrLmxhc3RJbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRTdGFjay5zcGxpY2UoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJySWR4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmN1cnJJZHg7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICByZWNvdmVyeUVuYWJsZWQ6IHRydWUsXG4gICAgbm9kZUxvY2F0aW9uVHJhY2tpbmc6ICdmdWxsJyxcbiAgICBza2lwVmFsaWRhdGlvbnM6IHRydWUsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IG5ldyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIoKVxufTtcbi8qKlxuICogVGhpcyBjbGFzcyB3cmFwcyB0aGUgZW1iZWRkZWQgYWN0aW9ucyBwYXJzZXIgb2YgY2hldnJvdGFpbiBhbmQgZXhwb3NlcyBwcm90ZWN0ZWQgbWV0aG9kcy5cbiAqIFRoaXMgd2F5LCB3ZSBjYW4gYnVpbGQgdGhlIGBMYW5naXVtUGFyc2VyYCBhcyBhIGNvbXBvc2l0aW9uLlxuICovXG5jbGFzcyBDaGV2cm90YWluV3JhcHBlciBleHRlbmRzIEVtYmVkZGVkQWN0aW9uc1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgdXNlRGVmYXVsdExvb2thaGVhZCA9IGNvbmZpZyAmJiAnbWF4TG9va2FoZWFkJyBpbiBjb25maWc7XG4gICAgICAgIHN1cGVyKHRva2VucywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCB7IGxvb2thaGVhZFN0cmF0ZWd5OiB1c2VEZWZhdWx0TG9va2FoZWFkXG4gICAgICAgICAgICAgICAgPyBuZXcgTExrTG9va2FoZWFkU3RyYXRlZ3koeyBtYXhMb29rYWhlYWQ6IGNvbmZpZy5tYXhMb29rYWhlYWQgfSlcbiAgICAgICAgICAgICAgICA6IG5ldyBMTFN0YXJMb29rYWhlYWRTdHJhdGVneSh7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHZhbGlkYXRpb25zIGFyZSBza2lwcGVkLCBkb24ndCBsb2cgdGhlIGxvb2thaGVhZCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nOiBjb25maWcuc2tpcFZhbGlkYXRpb25zID8gKCkgPT4geyB9IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSkgfSksIGNvbmZpZykpO1xuICAgIH1cbiAgICBnZXQgSVNfUkVDT1JESU5HKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5SRUNPUkRJTkdfUEhBU0U7XG4gICAgfVxuICAgIERFRklORV9SVUxFKG5hbWUsIGltcGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUlVMRShuYW1lLCBpbXBsKTtcbiAgICB9XG4gICAgd3JhcFNlbGZBbmFseXNpcygpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gICAgfVxuICAgIHdyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWUoaWR4LCB0b2tlblR5cGUpO1xuICAgIH1cbiAgICB3cmFwU3VicnVsZShpZHgsIHJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZShpZHgsIHJ1bGUsIHtcbiAgICAgICAgICAgIEFSR1M6IFthcmdzXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JhcE9yKGlkeCwgY2hvaWNlcykge1xuICAgICAgICB0aGlzLm9yKGlkeCwgY2hvaWNlcyk7XG4gICAgfVxuICAgIHdyYXBPcHRpb24oaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9wdGlvbihpZHgsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JhcE1hbnkoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hbnkoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHdyYXBBdExlYXN0T25lKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lKGlkeCwgY2FsbGJhY2spO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdpdW0tcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/langium-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/lexer.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/parser/lexer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TOKENIZE_OPTIONS: () => (/* binding */ DEFAULT_TOKENIZE_OPTIONS),\n/* harmony export */   DefaultLexer: () => (/* binding */ DefaultLexer),\n/* harmony export */   DefaultLexerErrorMessageProvider: () => (/* binding */ DefaultLexerErrorMessageProvider),\n/* harmony export */   isIMultiModeLexerDefinition: () => (/* binding */ isIMultiModeLexerDefinition),\n/* harmony export */   isTokenTypeArray: () => (/* binding */ isTokenTypeArray),\n/* harmony export */   isTokenTypeDictionary: () => (/* binding */ isTokenTypeDictionary)\n/* harmony export */ });\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nclass DefaultLexerErrorMessageProvider {\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\n    }\n    buildUnableToPopLexerModeMessage(token) {\n        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\n    }\n}\nconst DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };\nclass DefaultLexer {\n    constructor(services) {\n        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\n        this.tokenBuilder = services.parser.TokenBuilder;\n        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        const production = services.LanguageMetaData.mode === 'production';\n        this.chevrotainLexer = new chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer(lexerTokens, {\n            positionTracking: 'full',\n            skipValidations: production,\n            errorMessageProvider: this.errorMessageProvider\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {\n        var _a, _b, _c;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : [],\n            report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if (isTokenTypeDictionary(buildTokens))\n            return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nfunction isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\n}\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nfunction isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nfunction isTokenTypeDictionary(tokenVocabulary) {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n//# sourceMappingURL=lexer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2xleGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lGO0FBQzFFO0FBQ1A7QUFDQSxlQUFlLGlFQUF5QjtBQUN4QztBQUNBO0FBQ0EsZUFBZSxpRUFBeUI7QUFDeEM7QUFDQTtBQUNPLG1DQUFtQztBQUNuQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccGFyc2VyXFxsZXhlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBMZXhlciBhcyBDaGV2cm90YWluTGV4ZXIsIGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgfSBmcm9tICdjaGV2cm90YWluJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0TGV4ZXJFcnJvck1lc3NhZ2VQcm92aWRlciB7XG4gICAgYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2UoZnVsbFRleHQsIHN0YXJ0T2Zmc2V0LCBsZW5ndGgsIGxpbmUsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZGVmYXVsdExleGVyRXJyb3JQcm92aWRlci5idWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZShmdWxsVGV4dCwgc3RhcnRPZmZzZXQsIGxlbmd0aCwgbGluZSwgY29sdW1uKTtcbiAgICB9XG4gICAgYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIuYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UodG9rZW4pO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPS0VOSVpFX09QVElPTlMgPSB7IG1vZGU6ICdmdWxsJyB9O1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMZXhlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlckVycm9yTWVzc2FnZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLnRva2VuQnVpbGRlciA9IHNlcnZpY2VzLnBhcnNlci5Ub2tlbkJ1aWxkZXI7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMudG9rZW5CdWlsZGVyLmJ1aWxkVG9rZW5zKHNlcnZpY2VzLkdyYW1tYXIsIHtcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogc2VydmljZXMuTGFuZ3VhZ2VNZXRhRGF0YS5jYXNlSW5zZW5zaXRpdmVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlcyA9IHRoaXMudG9Ub2tlblR5cGVEaWN0aW9uYXJ5KHRva2Vucyk7XG4gICAgICAgIGNvbnN0IGxleGVyVG9rZW5zID0gaXNUb2tlblR5cGVEaWN0aW9uYXJ5KHRva2VucykgPyBPYmplY3QudmFsdWVzKHRva2VucykgOiB0b2tlbnM7XG4gICAgICAgIGNvbnN0IHByb2R1Y3Rpb24gPSBzZXJ2aWNlcy5MYW5ndWFnZU1ldGFEYXRhLm1vZGUgPT09ICdwcm9kdWN0aW9uJztcbiAgICAgICAgdGhpcy5jaGV2cm90YWluTGV4ZXIgPSBuZXcgQ2hldnJvdGFpbkxleGVyKGxleGVyVG9rZW5zLCB7XG4gICAgICAgICAgICBwb3NpdGlvblRyYWNraW5nOiAnZnVsbCcsXG4gICAgICAgICAgICBza2lwVmFsaWRhdGlvbnM6IHByb2R1Y3Rpb24sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VQcm92aWRlcjogdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuVHlwZXM7XG4gICAgfVxuICAgIHRva2VuaXplKHRleHQsIF9vcHRpb25zID0gREVGQVVMVF9UT0tFTklaRV9PUFRJT05TKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBjaGV2cm90YWluUmVzdWx0ID0gdGhpcy5jaGV2cm90YWluTGV4ZXIudG9rZW5pemUodGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IGNoZXZyb3RhaW5SZXN1bHQudG9rZW5zLFxuICAgICAgICAgICAgZXJyb3JzOiBjaGV2cm90YWluUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIGhpZGRlbjogKF9hID0gY2hldnJvdGFpblJlc3VsdC5ncm91cHMuaGlkZGVuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIHJlcG9ydDogKF9jID0gKF9iID0gdGhpcy50b2tlbkJ1aWxkZXIpLmZsdXNoTGV4aW5nUmVwb3J0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgdGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9Ub2tlblR5cGVEaWN0aW9uYXJ5KGJ1aWxkVG9rZW5zKSB7XG4gICAgICAgIGlmIChpc1Rva2VuVHlwZURpY3Rpb25hcnkoYnVpbGRUb2tlbnMpKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkVG9rZW5zO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBpc0lNdWx0aU1vZGVMZXhlckRlZmluaXRpb24oYnVpbGRUb2tlbnMpID8gT2JqZWN0LnZhbHVlcyhidWlsZFRva2Vucy5tb2RlcykuZmxhdCgpIDogYnVpbGRUb2tlbnM7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiByZXNbdG9rZW4ubmFtZV0gPSB0b2tlbik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gVG9rZW5Wb2NhYnVsYXJ5IGlzIFRva2VuVHlwZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGVBcnJheSh0b2tlblZvY2FidWxhcnkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0b2tlblZvY2FidWxhcnkpICYmICh0b2tlblZvY2FidWxhcnkubGVuZ3RoID09PSAwIHx8ICduYW1lJyBpbiB0b2tlblZvY2FidWxhcnlbMF0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gVG9rZW5Wb2NhYnVsYXJ5IGlzIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvbih0b2tlblZvY2FidWxhcnkpIHtcbiAgICByZXR1cm4gdG9rZW5Wb2NhYnVsYXJ5ICYmICdtb2RlcycgaW4gdG9rZW5Wb2NhYnVsYXJ5ICYmICdkZWZhdWx0TW9kZScgaW4gdG9rZW5Wb2NhYnVsYXJ5O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gVG9rZW5Wb2NhYnVsYXJ5IGlzIFRva2VuVHlwZURpY3Rpb25hcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5UeXBlRGljdGlvbmFyeSh0b2tlblZvY2FidWxhcnkpIHtcbiAgICByZXR1cm4gIWlzVG9rZW5UeXBlQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSAmJiAhaXNJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uKHRva2VuVm9jYWJ1bGFyeSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/parser-builder-base.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/parser/parser-builder-base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createParser: () => (/* binding */ createParser)\n/* harmony export */ });\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/errors.js */ \"(ssr)/./node_modules/langium/lib/utils/errors.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nfunction createParser(grammar, parser, tokens) {\n    const parserContext = {\n        parser,\n        tokens,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\nfunction buildRules(parserContext, grammar) {\n    const reachable = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getAllReachableRules)(grammar, false);\n    const parserRules = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(grammar.rules).filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n    }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isKeyword)(element)) {\n        method = buildKeyword(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAction)(element)) {\n        method = buildAction(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAssignment)(element)) {\n        method = buildElement(ctx, element.terminal);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isCrossReference)(element)) {\n        method = buildCrossReference(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(element)) {\n        method = buildRuleCall(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAlternatives)(element)) {\n        method = buildAlternatives(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isUnorderedGroup)(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(element)) {\n        method = buildGroup(ctx, element);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isEndOfFile)(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, chevrotain__WEBPACK_IMPORTED_MODULE_0__.EOF, element);\n    }\n    else {\n        throw new _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n    const actionType = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTypeName)(action);\n    return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(rule)) {\n        const idx = ctx.subrule++;\n        const fragment = rule.fragment;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isTerminalRule)(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    }\n    else if (!rule) {\n        throw new _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n    }\n    else {\n        (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(rule);\n    }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\nfunction buildPredicate(condition) {\n    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isDisjunction)(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isConjunction)(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isNegation)(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParameterReference)(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args) => args !== undefined && args[name] === true;\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isBooleanLiteral)(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    }\n    else {\n        const methods = [];\n        for (const element of alternatives.elements) {\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\nfunction buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods = [];\n    for (const element of group.elements) {\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = (groupIdx, lParser) => {\n        const stackId = lParser.getRuleStack().join('-');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key);\n                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        }\n        else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\nfunction buildGroup(ctx, group) {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n        }\n        const assignment = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.findNameAssignment)(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) {\n            throw new Error('Could not find name assignment for type: ' + (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTypeName)(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(terminal) && (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(terminal.rule.ref)) {\n        // The terminal is a data type rule here. Everything else will result in a validation error.\n        const rule = terminal.rule.ref;\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(terminal) && (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isTerminalRule)(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    }\n    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isKeyword)(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error('Could not build cross reference parser');\n    }\n}\nfunction buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error('Could not find token for keyword: ' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n    const gate = guard && buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ALT)(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return method;\n        }\n    }\n    if (cardinality === '*') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else if (cardinality === '+') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ALT)(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    }\n    else if (cardinality === '?') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else {\n        (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(cardinality);\n    }\n}\nfunction getRule(ctx, element) {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.parser.getRule(name);\n    if (!rule)\n        throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\nfunction getRuleName(ctx, element) {\n    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(element)) {\n        return element.name;\n    }\n    else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element);\n    }\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while (!(0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(parent)) {\n            if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(parent) || (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAlternatives)(parent) || (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isUnorderedGroup)(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + ':' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + ':' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\nfunction getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token)\n        throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n//# sourceMappingURL=parser-builder-base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL3BhcnNlci1idWlsZGVyLWJhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM0TztBQUM5TTtBQUM5QjtBQUNzRDtBQUMzRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2RUFBb0I7QUFDMUMsd0JBQXdCLHdEQUFNLHVCQUF1QixxRUFBWTtBQUNqRTtBQUNBLGtEQUFrRCxvQkFBb0IscURBQXFEO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFTO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLHFFQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLHlFQUFZO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhLDZFQUFnQjtBQUM3QjtBQUNBO0FBQ0EsYUFBYSx1RUFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSwyRUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSw2RUFBZ0I7QUFDN0I7QUFDQTtBQUNBLGFBQWEsb0VBQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsd0VBQVc7QUFDeEI7QUFDQSwrQ0FBK0MsMkNBQUc7QUFDbEQ7QUFDQTtBQUNBLGtCQUFrQiwrREFBaUIsK0NBQStDLGNBQWM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFZO0FBQ3BCO0FBQ0E7QUFDQSxzSEFBc0g7QUFDdEg7QUFDQTtBQUNBLGFBQWEsMkVBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBaUIsdUNBQXVDLHVCQUF1QjtBQUNqRztBQUNBO0FBQ0EsUUFBUSxtRUFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEVBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVFQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUZBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkVBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUyxHQUFHLFFBQVE7QUFDN0M7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkVBQWtCO0FBQzdDO0FBQ0E7QUFDQSwwRUFBMEUsb0VBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1RUFBVSxjQUFjLHlFQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVFQUFVLGNBQWMsMkVBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNFQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLG1FQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBWTtBQUM1QixnQkFBZ0Isb0VBQU8sWUFBWSwyRUFBYyxZQUFZLDZFQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccGFyc2VyXFxwYXJzZXItYnVpbGRlci1iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IEVNUFRZX0FMVCwgRU9GIH0gZnJvbSAnY2hldnJvdGFpbic7XG5pbXBvcnQgeyBpc0FjdGlvbiwgaXNBbHRlcm5hdGl2ZXMsIGlzRW5kT2ZGaWxlLCBpc0Fzc2lnbm1lbnQsIGlzQ29uanVuY3Rpb24sIGlzQ3Jvc3NSZWZlcmVuY2UsIGlzRGlzanVuY3Rpb24sIGlzR3JvdXAsIGlzS2V5d29yZCwgaXNOZWdhdGlvbiwgaXNQYXJhbWV0ZXJSZWZlcmVuY2UsIGlzUGFyc2VyUnVsZSwgaXNSdWxlQ2FsbCwgaXNUZXJtaW5hbFJ1bGUsIGlzVW5vcmRlcmVkR3JvdXAsIGlzQm9vbGVhbkxpdGVyYWwgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBhc3NlcnRVbnJlYWNoYWJsZSwgRXJyb3JXaXRoTG9jYXRpb24gfSBmcm9tICcuLi91dGlscy9lcnJvcnMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IGZpbmROYW1lQXNzaWdubWVudCwgZ2V0QWxsUmVhY2hhYmxlUnVsZXMsIGdldFR5cGVOYW1lIH0gZnJvbSAnLi4vdXRpbHMvZ3JhbW1hci11dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGdyYW1tYXIsIHBhcnNlciwgdG9rZW5zKSB7XG4gICAgY29uc3QgcGFyc2VyQ29udGV4dCA9IHtcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHJ1bGVOYW1lczogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpO1xuICAgIHJldHVybiBwYXJzZXI7XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByZWFjaGFibGUgPSBnZXRBbGxSZWFjaGFibGVSdWxlcyhncmFtbWFyLCBmYWxzZSk7XG4gICAgY29uc3QgcGFyc2VyUnVsZXMgPSBzdHJlYW0oZ3JhbW1hci5ydWxlcykuZmlsdGVyKGlzUGFyc2VyUnVsZSkuZmlsdGVyKHJ1bGUgPT4gcmVhY2hhYmxlLmhhcyhydWxlKSk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHBhcnNlclJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VyQ29udGV4dCksIHsgY29uc3VtZTogMSwgb3B0aW9uYWw6IDEsIHN1YnJ1bGU6IDEsIG1hbnk6IDEsIG9yOiAxIH0pO1xuICAgICAgICBwYXJzZXJDb250ZXh0LnBhcnNlci5ydWxlKHJ1bGUsIGJ1aWxkRWxlbWVudChjdHgsIHJ1bGUuZGVmaW5pdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQsIGlnbm9yZUd1YXJkID0gZmFsc2UpIHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGlmIChpc0tleXdvcmQoZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRLZXl3b3JkKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkQWN0aW9uKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzaWdubWVudChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEVsZW1lbnQoY3R4LCBlbGVtZW50LnRlcm1pbmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDcm9zc1JlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZENyb3NzUmVmZXJlbmNlKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUnVsZUNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRSdWxlQ2FsbChjdHgsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FsdGVybmF0aXZlcyhlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEFsdGVybmF0aXZlcyhjdHgsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1Vub3JkZXJlZEdyb3VwKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkVW5vcmRlcmVkR3JvdXAoY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNHcm91cChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEdyb3VwKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRW5kT2ZGaWxlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5jb25zdW1lKys7XG4gICAgICAgIG1ldGhvZCA9ICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIEVPRiwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoTG9jYXRpb24oZWxlbWVudC4kY3N0Tm9kZSwgYFVuZXhwZWN0ZWQgZWxlbWVudCB0eXBlOiAke2VsZW1lbnQuJHR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKGN0eCwgaWdub3JlR3VhcmQgPyB1bmRlZmluZWQgOiBnZXRHdWFyZENvbmRpdGlvbihlbGVtZW50KSwgbWV0aG9kLCBlbGVtZW50LmNhcmRpbmFsaXR5KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWN0aW9uKGN0eCwgYWN0aW9uKSB7XG4gICAgY29uc3QgYWN0aW9uVHlwZSA9IGdldFR5cGVOYW1lKGFjdGlvbik7XG4gICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuYWN0aW9uKGFjdGlvblR5cGUsIGFjdGlvbik7XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVDYWxsKGN0eCwgcnVsZUNhbGwpIHtcbiAgICBjb25zdCBydWxlID0gcnVsZUNhbGwucnVsZS5yZWY7XG4gICAgaWYgKGlzUGFyc2VyUnVsZShydWxlKSkge1xuICAgICAgICBjb25zdCBpZHggPSBjdHguc3VicnVsZSsrO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHJ1bGUuZnJhZ21lbnQ7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHJ1bGVDYWxsLmFyZ3VtZW50cy5sZW5ndGggPiAwID8gYnVpbGRSdWxlQ2FsbFByZWRpY2F0ZShydWxlLCBydWxlQ2FsbC5hcmd1bWVudHMpIDogKCkgPT4gKHt9KTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLnN1YnJ1bGUoaWR4LCBnZXRSdWxlKGN0eCwgcnVsZSksIGZyYWdtZW50LCBydWxlQ2FsbCwgcHJlZGljYXRlKGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNUZXJtaW5hbFJ1bGUocnVsZSkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gZ2V0VG9rZW4oY3R4LCBydWxlLm5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY3R4LnBhcnNlci5jb25zdW1lKGlkeCwgbWV0aG9kLCBydWxlQ2FsbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFydWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhMb2NhdGlvbihydWxlQ2FsbC4kY3N0Tm9kZSwgYFVuZGVmaW5lZCBydWxlOiAke3J1bGVDYWxsLnJ1bGUuJHJlZlRleHR9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShydWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVDYWxsUHJlZGljYXRlKHJ1bGUsIG5hbWVkQXJncykge1xuICAgIGNvbnN0IHByZWRpY2F0ZXMgPSBuYW1lZEFyZ3MubWFwKGUgPT4gYnVpbGRQcmVkaWNhdGUoZS52YWx1ZSkpO1xuICAgIHJldHVybiAoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBydWxlQXJncyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWRpY2F0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVUYXJnZXQgPSBydWxlLnBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2ldO1xuICAgICAgICAgICAgcnVsZUFyZ3NbcnVsZVRhcmdldC5uYW1lXSA9IHByZWRpY2F0ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZUFyZ3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbikge1xuICAgIGlmIChpc0Rpc2p1bmN0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi5sZWZ0KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZFByZWRpY2F0ZShjb25kaXRpb24ucmlnaHQpO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IChsZWZ0KGFyZ3MpIHx8IHJpZ2h0KGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb25qdW5jdGlvbihjb25kaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZFByZWRpY2F0ZShjb25kaXRpb24ubGVmdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRQcmVkaWNhdGUoY29uZGl0aW9uLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiAobGVmdChhcmdzKSAmJiByaWdodChhcmdzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmVnYXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi52YWx1ZSk7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gIXZhbHVlKGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhcmFtZXRlclJlZmVyZW5jZShjb25kaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb25kaXRpb24ucGFyYW1ldGVyLnJlZi5uYW1lO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IGFyZ3MgIT09IHVuZGVmaW5lZCAmJiBhcmdzW25hbWVdID09PSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5MaXRlcmFsKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCb29sZWFuKGNvbmRpdGlvbi50cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHZhbHVlO1xuICAgIH1cbiAgICBhc3NlcnRVbnJlYWNoYWJsZShjb25kaXRpb24pO1xufVxuZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXMoY3R4LCBhbHRlcm5hdGl2ZXMpIHtcbiAgICBpZiAoYWx0ZXJuYXRpdmVzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVpbGRFbGVtZW50KGN0eCwgYWx0ZXJuYXRpdmVzLmVsZW1lbnRzWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFsdGVybmF0aXZlcy5lbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlZE1ldGhvZCA9IHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBoYW5kbGUgdGhlIGd1YXJkIGNvbmRpdGlvbiBpbiB0aGUgYWx0ZXJuYXRpdmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdGhlIGdyb3VwIGd1YXJkIGNvbmRpdGlvbiBpbnNpZGVcbiAgICAgICAgICAgICAgICBBTFQ6IGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBnZXRHdWFyZENvbmRpdGlvbihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChndWFyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY2F0ZWRNZXRob2QuR0FURSA9IGJ1aWxkUHJlZGljYXRlKGd1YXJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcmVkaWNhdGVkTWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBjdHgub3IrKztcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhpZHgsIG1ldGhvZHMubWFwKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHQgPSB7XG4gICAgICAgICAgICAgICAgQUxUOiAoKSA9PiBtZXRob2QuQUxUKGFyZ3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZ2F0ZSA9IG1ldGhvZC5HQVRFO1xuICAgICAgICAgICAgaWYgKGdhdGUpIHtcbiAgICAgICAgICAgICAgICBhbHQuR0FURSA9ICgpID0+IGdhdGUoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRVbm9yZGVyZWRHcm91cChjdHgsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVpbGRFbGVtZW50KGN0eCwgZ3JvdXAuZWxlbWVudHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2RzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGdyb3VwLmVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZWRNZXRob2QgPSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBoYW5kbGUgdGhlIGd1YXJkIGNvbmRpdGlvbiBpbiB0aGUgYWx0ZXJuYXRpdmUgYWxyZWFkeVxuICAgICAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGUgZ3JvdXAgZ3VhcmQgY29uZGl0aW9uIGluc2lkZVxuICAgICAgICAgICAgQUxUOiBidWlsZEVsZW1lbnQoY3R4LCBlbGVtZW50LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBndWFyZCA9IGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZ3VhcmQpIHtcbiAgICAgICAgICAgIHByZWRpY2F0ZWRNZXRob2QuR0FURSA9IGJ1aWxkUHJlZGljYXRlKGd1YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2RzLnB1c2gocHJlZGljYXRlZE1ldGhvZCk7XG4gICAgfVxuICAgIGNvbnN0IG9ySWR4ID0gY3R4Lm9yKys7XG4gICAgY29uc3QgaWRGdW5jID0gKGdyb3VwSWR4LCBsUGFyc2VyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YWNrSWQgPSBsUGFyc2VyLmdldFJ1bGVTdGFjaygpLmpvaW4oJy0nKTtcbiAgICAgICAgcmV0dXJuIGB1R3JvdXBfJHtncm91cElkeH1fJHtzdGFja0lkfWA7XG4gICAgfTtcbiAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSAoYXJncykgPT4gY3R4LnBhcnNlci5hbHRlcm5hdGl2ZXMob3JJZHgsIG1ldGhvZHMubWFwKChtZXRob2QsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBhbHQgPSB7IEFMVDogKCkgPT4gdHJ1ZSB9O1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBjdHgucGFyc2VyO1xuICAgICAgICBhbHQuQUxUID0gKCkgPT4ge1xuICAgICAgICAgICAgbWV0aG9kLkFMVChhcmdzKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VyLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpZEZ1bmMob3JJZHgsIHBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIudW5vcmRlcmVkR3JvdXBzLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXQgYWZ0ZXIgY2xlYXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnVub3JkZXJlZEdyb3Vwcy5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwU3RhdGUgPSBwYXJzZXIudW5vcmRlcmVkR3JvdXBzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGdyb3VwU3RhdGUgPT09IG51bGwgfHwgZ3JvdXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBTdGF0ZVtpZHhdKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjY2Vzc2VkIHlldFxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXRlW2lkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2F0ZSA9IG1ldGhvZC5HQVRFO1xuICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgYWx0LkdBVEUgPSAoKSA9PiBnYXRlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWx0LkdBVEUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZEFsdGVybmF0aXZlcyA9IHBhcnNlci51bm9yZGVyZWRHcm91cHMuZ2V0KGlkRnVuYyhvcklkeCwgcGFyc2VyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3cgPSAhKHRyYWNrZWRBbHRlcm5hdGl2ZXMgPT09IG51bGwgfHwgdHJhY2tlZEFsdGVybmF0aXZlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tlZEFsdGVybmF0aXZlc1tpZHhdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgfSkpO1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwKGN0eCwgZ2V0R3VhcmRDb25kaXRpb24oZ3JvdXApLCBhbHRlcm5hdGl2ZXMsICcqJyk7XG4gICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgIHdyYXBwZWQoYXJncyk7XG4gICAgICAgIGlmICghY3R4LnBhcnNlci5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBjdHgucGFyc2VyLnVub3JkZXJlZEdyb3Vwcy5kZWxldGUoaWRGdW5jKG9ySWR4LCBjdHgucGFyc2VyKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cChjdHgsIGdyb3VwKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IGdyb3VwLmVsZW1lbnRzLm1hcChlID0+IGJ1aWxkRWxlbWVudChjdHgsIGUpKTtcbiAgICByZXR1cm4gKGFyZ3MpID0+IG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4gbWV0aG9kKGFyZ3MpKTtcbn1cbmZ1bmN0aW9uIGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoaXNHcm91cChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5ndWFyZENvbmRpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ3Jvc3NSZWZlcmVuY2UoY3R4LCBjcm9zc1JlZiwgdGVybWluYWwgPSBjcm9zc1JlZi50ZXJtaW5hbCkge1xuICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgaWYgKCFjcm9zc1JlZi50eXBlLnJlZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgdG8gdHlwZTogJyArIGNyb3NzUmVmLnR5cGUuJHJlZlRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBmaW5kTmFtZUFzc2lnbm1lbnQoY3Jvc3NSZWYudHlwZS5yZWYpO1xuICAgICAgICBjb25zdCBhc3NpZ25UZXJtaW5hbCA9IGFzc2lnbm1lbnQgPT09IG51bGwgfHwgYXNzaWdubWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXNzaWdubWVudC50ZXJtaW5hbDtcbiAgICAgICAgaWYgKCFhc3NpZ25UZXJtaW5hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBuYW1lIGFzc2lnbm1lbnQgZm9yIHR5cGU6ICcgKyBnZXRUeXBlTmFtZShjcm9zc1JlZi50eXBlLnJlZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZENyb3NzUmVmZXJlbmNlKGN0eCwgY3Jvc3NSZWYsIGFzc2lnblRlcm1pbmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSdWxlQ2FsbCh0ZXJtaW5hbCkgJiYgaXNQYXJzZXJSdWxlKHRlcm1pbmFsLnJ1bGUucmVmKSkge1xuICAgICAgICAvLyBUaGUgdGVybWluYWwgaXMgYSBkYXRhIHR5cGUgcnVsZSBoZXJlLiBFdmVyeXRoaW5nIGVsc2Ugd2lsbCByZXN1bHQgaW4gYSB2YWxpZGF0aW9uIGVycm9yLlxuICAgICAgICBjb25zdCBydWxlID0gdGVybWluYWwucnVsZS5yZWY7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5zdWJydWxlKys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5zdWJydWxlKGlkeCwgZ2V0UnVsZShjdHgsIHJ1bGUpLCBmYWxzZSwgY3Jvc3NSZWYsIGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bGVDYWxsKHRlcm1pbmFsKSAmJiBpc1Rlcm1pbmFsUnVsZSh0ZXJtaW5hbC5ydWxlLnJlZikpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgY29uc3QgdGVybWluYWxSdWxlID0gZ2V0VG9rZW4oY3R4LCB0ZXJtaW5hbC5ydWxlLnJlZi5uYW1lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIHRlcm1pbmFsUnVsZSwgY3Jvc3NSZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0tleXdvcmQodGVybWluYWwpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5jb25zdW1lKys7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSBnZXRUb2tlbihjdHgsIHRlcm1pbmFsLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIGtleXdvcmQsIGNyb3NzUmVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGJ1aWxkIGNyb3NzIHJlZmVyZW5jZSBwYXJzZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEtleXdvcmQoY3R4LCBrZXl3b3JkKSB7XG4gICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICBjb25zdCB0b2tlbiA9IGN0eC50b2tlbnNba2V5d29yZC52YWx1ZV07XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRva2VuIGZvciBrZXl3b3JkOiAnICsga2V5d29yZC52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjdHgucGFyc2VyLmNvbnN1bWUoaWR4LCB0b2tlbiwga2V5d29yZCk7XG59XG5mdW5jdGlvbiB3cmFwKGN0eCwgZ3VhcmQsIG1ldGhvZCwgY2FyZGluYWxpdHkpIHtcbiAgICBjb25zdCBnYXRlID0gZ3VhcmQgJiYgYnVpbGRQcmVkaWNhdGUoZ3VhcmQpO1xuICAgIGlmICghY2FyZGluYWxpdHkpIHtcbiAgICAgICAgaWYgKGdhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGN0eC5vcisrO1xuICAgICAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhpZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICBHQVRFOiAoKSA9PiBnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogRU1QVFlfQUxUKCksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+ICFnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJkaW5hbGl0eSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5tYW55Kys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5tYW55KGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICcrJykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgubWFueSsrO1xuICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgY29uc3Qgb3JJZHggPSBjdHgub3IrKztcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgZ3VhcmQgY29uZGl0aW9uIGZvciB0aGUgYCtgIGdyb3VwXG4gICAgICAgICAgICAvLyBXZSBjb21iaW5lIGl0IHdpdGggYW4gZW1wdHkgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25kaXRpb24gcmV0dXJucyB0cnVlLCBpdCBuZWVkcyB0byBwYXJzZSBhdCBsZWFzdCBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICAgIC8vIElmIGl0cyBmYWxzZSwgaXQgaXMgbm90IGFsbG93ZWQgdG8gcGFyc2UgYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hbHRlcm5hdGl2ZXMob3JJZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncylcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+IGdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgQUxUOiBFTVBUWV9BTFQoKSxcbiAgICAgICAgICAgICAgICAgICAgR0FURTogKCkgPT4gIWdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgIERFRjogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICc/Jykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgub3B0aW9uYWwrKztcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLm9wdGlvbmFsKGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFVucmVhY2hhYmxlKGNhcmRpbmFsaXR5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSdWxlKGN0eCwgZWxlbWVudCkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRSdWxlTmFtZShjdHgsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHJ1bGUgPSBjdHgucGFyc2VyLmdldFJ1bGUobmFtZSk7XG4gICAgaWYgKCFydWxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bGUgXCIke25hbWV9XCIgbm90IGZvdW5kLlwiYCk7XG4gICAgcmV0dXJuIHJ1bGU7XG59XG5mdW5jdGlvbiBnZXRSdWxlTmFtZShjdHgsIGVsZW1lbnQpIHtcbiAgICBpZiAoaXNQYXJzZXJSdWxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC5ydWxlTmFtZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjdHgucnVsZU5hbWVzLmdldChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBpdGVtID0gZWxlbWVudDtcbiAgICAgICAgbGV0IHBhcmVudCA9IGl0ZW0uJGNvbnRhaW5lcjtcbiAgICAgICAgbGV0IHJ1bGVOYW1lID0gZWxlbWVudC4kdHlwZTtcbiAgICAgICAgd2hpbGUgKCFpc1BhcnNlclJ1bGUocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGlzR3JvdXAocGFyZW50KSB8fCBpc0FsdGVybmF0aXZlcyhwYXJlbnQpIHx8IGlzVW5vcmRlcmVkR3JvdXAocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmVsZW1lbnRzLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBpbmRleC50b1N0cmluZygpICsgJzonICsgcnVsZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiRjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVsZSA9IHBhcmVudDtcbiAgICAgICAgcnVsZU5hbWUgPSBydWxlLm5hbWUgKyAnOicgKyBydWxlTmFtZTtcbiAgICAgICAgY3R4LnJ1bGVOYW1lcy5zZXQoZWxlbWVudCwgcnVsZU5hbWUpO1xuICAgICAgICByZXR1cm4gcnVsZU5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VG9rZW4oY3R4LCBuYW1lKSB7XG4gICAgY29uc3QgdG9rZW4gPSBjdHgudG9rZW5zW25hbWVdO1xuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gXCIke25hbWV9XCIgbm90IGZvdW5kLlwiYCk7XG4gICAgcmV0dXJuIHRva2VuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLWJ1aWxkZXItYmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/parser-builder-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/token-builder.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/parser/token-builder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTokenBuilder: () => (/* binding */ DefaultTokenBuilder)\n/* harmony export */ });\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/regexp-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/regexp-utils.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultTokenBuilder {\n    constructor() {\n        /**\n         * The list of diagnostics stored during the lexing process of a single text.\n         */\n        this.diagnostics = [];\n    }\n    buildTokens(grammar, options) {\n        const reachableRules = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_1__.stream)((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.getAllReachableRules)(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.isWhitespace)(pattern)) {\n                tokens.unshift(terminalToken);\n            }\n            else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don't need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flushLexingReport(text) {\n        return { diagnostics: this.popDiagnostics() };\n    }\n    popDiagnostics() {\n        const diagnostics = [...this.diagnostics];\n        this.diagnostics = [];\n        return diagnostics;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.terminalRegex)(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n        };\n        if (typeof pattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.isWhitespace)(regex) ? chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer.SKIPPED : 'hidden';\n        }\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes('u') || regex.flags.includes('s')) {\n            // Unicode and dotall regexes are not supported by Chevrotain.\n            return true;\n        }\n        else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isParserRule)\n            .flatMap(rule => (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.streamAllContents)(rule).filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\n        const tokenType = {\n            name: keyword.value,\n            PATTERN: keywordPattern,\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n        if (typeof keywordPattern === 'function') {\n            tokenType.LINE_BREAKS = true;\n        }\n        return tokenType;\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ?\n            new RegExp((0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCaseInsensitivePattern)(keyword.value)) :\n            keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token) => {\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.partialMatches)('^' + pattern.source + '$', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n//# sourceMappingURL=token-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL3Rva2VuLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUM7QUFDcUQ7QUFDOUI7QUFDc0I7QUFDbUI7QUFDdkQ7QUFDckM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBTSxDQUFDLDZFQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxvRUFBWTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1RUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0VBQVksVUFBVSw2Q0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUVBQVk7QUFDaEMsNkJBQTZCLHNFQUFpQixjQUFjLGtFQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlGQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHNFQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccGFyc2VyXFx0b2tlbi1idWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IExleGVyIH0gZnJvbSAnY2hldnJvdGFpbic7XG5pbXBvcnQgeyBpc0tleXdvcmQsIGlzUGFyc2VyUnVsZSwgaXNUZXJtaW5hbFJ1bGUgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBzdHJlYW1BbGxDb250ZW50cyB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRBbGxSZWFjaGFibGVSdWxlcywgdGVybWluYWxSZWdleCB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0Q2FzZUluc2Vuc2l0aXZlUGF0dGVybiwgaXNXaGl0ZXNwYWNlLCBwYXJ0aWFsTWF0Y2hlcyB9IGZyb20gJy4uL3V0aWxzL3JlZ2V4cC11dGlscy5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRUb2tlbkJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgZGlhZ25vc3RpY3Mgc3RvcmVkIGR1cmluZyB0aGUgbGV4aW5nIHByb2Nlc3Mgb2YgYSBzaW5nbGUgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBbXTtcbiAgICB9XG4gICAgYnVpbGRUb2tlbnMoZ3JhbW1hciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZWFjaGFibGVSdWxlcyA9IHN0cmVhbShnZXRBbGxSZWFjaGFibGVSdWxlcyhncmFtbWFyLCBmYWxzZSkpO1xuICAgICAgICBjb25zdCB0ZXJtaW5hbFRva2VucyA9IHRoaXMuYnVpbGRUZXJtaW5hbFRva2VucyhyZWFjaGFibGVSdWxlcyk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuYnVpbGRLZXl3b3JkVG9rZW5zKHJlYWNoYWJsZVJ1bGVzLCB0ZXJtaW5hbFRva2Vucywgb3B0aW9ucyk7XG4gICAgICAgIHRlcm1pbmFsVG9rZW5zLmZvckVhY2godGVybWluYWxUb2tlbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGVybWluYWxUb2tlbi5QQVRURVJOO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnb2JqZWN0JyAmJiBwYXR0ZXJuICYmICd0ZXN0JyBpbiBwYXR0ZXJuICYmIGlzV2hpdGVzcGFjZShwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHRva2Vucy51bnNoaWZ0KHRlcm1pbmFsVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGVybWluYWxUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGFkZCB0aGUgRU9GIHRva2VuIGV4cGxpY2l0bHkuXG4gICAgICAgIC8vIEl0IGlzIGF1dG9tYXRpY2FsbHkgYXZhaWxhYmxlIGF0IHRoZSBlbmQgb2YgdGhlIHRva2VuIHN0cmVhbS5cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGZsdXNoTGV4aW5nUmVwb3J0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgZGlhZ25vc3RpY3M6IHRoaXMucG9wRGlhZ25vc3RpY3MoKSB9O1xuICAgIH1cbiAgICBwb3BEaWFnbm9zdGljcygpIHtcbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSBbLi4udGhpcy5kaWFnbm9zdGljc107XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgIH1cbiAgICBidWlsZFRlcm1pbmFsVG9rZW5zKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiBydWxlcy5maWx0ZXIoaXNUZXJtaW5hbFJ1bGUpLmZpbHRlcihlID0+ICFlLmZyYWdtZW50KVxuICAgICAgICAgICAgLm1hcCh0ZXJtaW5hbCA9PiB0aGlzLmJ1aWxkVGVybWluYWxUb2tlbih0ZXJtaW5hbCkpLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgYnVpbGRUZXJtaW5hbFRva2VuKHRlcm1pbmFsKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gdGVybWluYWxSZWdleCh0ZXJtaW5hbCk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnJlcXVpcmVzQ3VzdG9tUGF0dGVybihyZWdleCkgPyB0aGlzLnJlZ2V4UGF0dGVybkZ1bmN0aW9uKHJlZ2V4KSA6IHJlZ2V4O1xuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB7XG4gICAgICAgICAgICBuYW1lOiB0ZXJtaW5hbC5uYW1lLFxuICAgICAgICAgICAgUEFUVEVSTjogcGF0dGVybixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b2tlblR5cGUuTElORV9CUkVBS1MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hbC5oaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2tpcCB0b2tlbnMgdGhhdCBhcmUgYWJsZSB0byBhY2NlcHQgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdG9rZW5UeXBlLkdST1VQID0gaXNXaGl0ZXNwYWNlKHJlZ2V4KSA/IExleGVyLlNLSVBQRUQgOiAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgIH1cbiAgICByZXF1aXJlc0N1c3RvbVBhdHRlcm4ocmVnZXgpIHtcbiAgICAgICAgaWYgKHJlZ2V4LmZsYWdzLmluY2x1ZGVzKCd1JykgfHwgcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3MnKSkge1xuICAgICAgICAgICAgLy8gVW5pY29kZSBhbmQgZG90YWxsIHJlZ2V4ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgQ2hldnJvdGFpbi5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZ2V4LnNvdXJjZS5pbmNsdWRlcygnPzw9JykgfHwgcmVnZXguc291cmNlLmluY2x1ZGVzKCc/PCEnKSkge1xuICAgICAgICAgICAgLy8gTmVnYXRpdmUgYW5kIHBvc2l0aXZlIGxvb2tiZWhpbmQgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgQ2hldnJvdGFpbiB5ZXQuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdleFBhdHRlcm5GdW5jdGlvbihyZWdleCkge1xuICAgICAgICBjb25zdCBzdGlja3lSZWdleCA9IG5ldyBSZWdFeHAocmVnZXgsIHJlZ2V4LmZsYWdzICsgJ3knKTtcbiAgICAgICAgcmV0dXJuICh0ZXh0LCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHN0aWNreVJlZ2V4Lmxhc3RJbmRleCA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWNSZXN1bHQgPSBzdGlja3lSZWdleC5leGVjKHRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWNSZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkS2V5d29yZFRva2VucyhydWxlcywgdGVybWluYWxUb2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGVzXG4gICAgICAgICAgICAvLyBXZSBmaWx0ZXIgYnkgcGFyc2VyIHJ1bGVzLCBzaW5jZSBrZXl3b3JkcyBpbiB0ZXJtaW5hbCBydWxlcyBnZXQgdHJhbnNmb3JtZWQgaW50byByZWdleCBhbmQgYXJlIG5vdCBhY3R1YWwgdG9rZW5zXG4gICAgICAgICAgICAuZmlsdGVyKGlzUGFyc2VyUnVsZSlcbiAgICAgICAgICAgIC5mbGF0TWFwKHJ1bGUgPT4gc3RyZWFtQWxsQ29udGVudHMocnVsZSkuZmlsdGVyKGlzS2V5d29yZCkpXG4gICAgICAgICAgICAuZGlzdGluY3QoZSA9PiBlLnZhbHVlKS50b0FycmF5KClcbiAgICAgICAgICAgIC8vIFNvcnQga2V5d29yZHMgYnkgZGVzY2VuZGluZyBsZW5ndGhcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnZhbHVlLmxlbmd0aCAtIGEudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgLm1hcChrZXl3b3JkID0+IHRoaXMuYnVpbGRLZXl3b3JkVG9rZW4oa2V5d29yZCwgdGVybWluYWxUb2tlbnMsIEJvb2xlYW4ob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSkpKTtcbiAgICB9XG4gICAgYnVpbGRLZXl3b3JkVG9rZW4oa2V5d29yZCwgdGVybWluYWxUb2tlbnMsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkUGF0dGVybiA9IHRoaXMuYnVpbGRLZXl3b3JkUGF0dGVybihrZXl3b3JkLCBjYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBrZXl3b3JkLnZhbHVlLFxuICAgICAgICAgICAgUEFUVEVSTjoga2V5d29yZFBhdHRlcm4sXG4gICAgICAgICAgICBMT05HRVJfQUxUOiB0aGlzLmZpbmRMb25nZXJBbHQoa2V5d29yZCwgdGVybWluYWxUb2tlbnMpXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Yga2V5d29yZFBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRva2VuVHlwZS5MSU5FX0JSRUFLUyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuVHlwZTtcbiAgICB9XG4gICAgYnVpbGRLZXl3b3JkUGF0dGVybihrZXl3b3JkLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/XG4gICAgICAgICAgICBuZXcgUmVnRXhwKGdldENhc2VJbnNlbnNpdGl2ZVBhdHRlcm4oa2V5d29yZC52YWx1ZSkpIDpcbiAgICAgICAgICAgIGtleXdvcmQudmFsdWU7XG4gICAgfVxuICAgIGZpbmRMb25nZXJBbHQoa2V5d29yZCwgdGVybWluYWxUb2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRlcm1pbmFsVG9rZW5zLnJlZHVjZSgobG9uZ2VyQWx0cywgdG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0b2tlbiA9PT0gbnVsbCB8fCB0b2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9rZW4uUEFUVEVSTjtcbiAgICAgICAgICAgIGlmICgocGF0dGVybiA9PT0gbnVsbCB8fCBwYXR0ZXJuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXR0ZXJuLnNvdXJjZSkgJiYgcGFydGlhbE1hdGNoZXMoJ14nICsgcGF0dGVybi5zb3VyY2UgKyAnJCcsIGtleXdvcmQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbG9uZ2VyQWx0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb25nZXJBbHRzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW4tYnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/token-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/parser/value-converter.js":
/*!************************************************************!*\
  !*** ./node_modules/langium/lib/parser/value-converter.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultValueConverter: () => (/* binding */ DefaultValueConverter),\n/* harmony export */   ValueConverter: () => (/* binding */ ValueConverter)\n/* harmony export */ });\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultValueConverter {\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isCrossReference)(feature)) {\n            feature = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getCrossReferenceTerminal)(feature);\n        }\n        if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall)(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error('This cst node was not parsed by a rule.');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch (rule.name.toUpperCase()) {\n            case 'INT': return ValueConverter.convertInt(input);\n            case 'STRING': return ValueConverter.convertString(input);\n            case 'ID': return ValueConverter.convertID(input);\n        }\n        switch ((_a = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getRuleType)(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case 'number': return ValueConverter.convertNumber(input);\n            case 'boolean': return ValueConverter.convertBoolean(input);\n            case 'bigint': return ValueConverter.convertBigint(input);\n            case 'date': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\nvar ValueConverter;\n(function (ValueConverter) {\n    function convertString(input) {\n        let result = '';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === '\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            }\n            else {\n                result += c;\n            }\n        }\n        return result;\n    }\n    ValueConverter.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch (char) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            case '0': return '\\0';\n            default: return char;\n        }\n    }\n    function convertID(input) {\n        if (input.charAt(0) === '^') {\n            return input.substring(1);\n        }\n        else {\n            return input;\n        }\n    }\n    ValueConverter.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    ValueConverter.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    ValueConverter.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    ValueConverter.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    ValueConverter.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === 'true';\n    }\n    ValueConverter.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n//# sourceMappingURL=value-converter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL3ZhbHVlLWNvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RTtBQUNNO0FBQzVFO0FBQ1A7QUFDQTtBQUNBLFlBQVksNkVBQWdCO0FBQzVCLHNCQUFzQixrRkFBeUI7QUFDL0M7QUFDQSxZQUFZLHVFQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9FQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHBhcnNlclxcdmFsdWUtY29udmVydGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGlzQ3Jvc3NSZWZlcmVuY2UsIGlzUnVsZUNhbGwgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBnZXRDcm9zc1JlZmVyZW5jZVRlcm1pbmFsLCBnZXRSdWxlVHlwZSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRWYWx1ZUNvbnZlcnRlciB7XG4gICAgY29udmVydChpbnB1dCwgY3N0Tm9kZSkge1xuICAgICAgICBsZXQgZmVhdHVyZSA9IGNzdE5vZGUuZ3JhbW1hclNvdXJjZTtcbiAgICAgICAgaWYgKGlzQ3Jvc3NSZWZlcmVuY2UoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSBnZXRDcm9zc1JlZmVyZW5jZVRlcm1pbmFsKGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1J1bGVDYWxsKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gZmVhdHVyZS5ydWxlLnJlZjtcbiAgICAgICAgICAgIGlmICghcnVsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjc3Qgbm9kZSB3YXMgbm90IHBhcnNlZCBieSBhIHJ1bGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIGNzdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJ1bkNvbnZlcnRlcihydWxlLCBpbnB1dCwgY3N0Tm9kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN3aXRjaCAocnVsZS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0lOVCc6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0SW50KGlucHV0KTtcbiAgICAgICAgICAgIGNhc2UgJ1NUUklORyc6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0U3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIGNhc2UgJ0lEJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRJRChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICgoX2EgPSBnZXRSdWxlVHlwZShydWxlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0TnVtYmVyKGlucHV0KTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuY29udmVydEJvb2xlYW4oaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnYmlnaW50JzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRCaWdpbnQoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0RGF0ZShpbnB1dCk7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgdmFyIFZhbHVlQ29udmVydGVyO1xuKGZ1bmN0aW9uIChWYWx1ZUNvbnZlcnRlcikge1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IGlucHV0LmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjb252ZXJ0RXNjYXBlQ2hhcmFjdGVyKGMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFZhbHVlQ29udmVydGVyLmNvbnZlcnRTdHJpbmcgPSBjb252ZXJ0U3RyaW5nO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRFc2NhcGVDaGFyYWN0ZXIoY2hhcikge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ2InOiByZXR1cm4gJ1xcYic7XG4gICAgICAgICAgICBjYXNlICdmJzogcmV0dXJuICdcXGYnO1xuICAgICAgICAgICAgY2FzZSAnbic6IHJldHVybiAnXFxuJztcbiAgICAgICAgICAgIGNhc2UgJ3InOiByZXR1cm4gJ1xccic7XG4gICAgICAgICAgICBjYXNlICd0JzogcmV0dXJuICdcXHQnO1xuICAgICAgICAgICAgY2FzZSAndic6IHJldHVybiAnXFx2JztcbiAgICAgICAgICAgIGNhc2UgJzAnOiByZXR1cm4gJ1xcMCc7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0SUQoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJBdCgwKSA9PT0gJ14nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFZhbHVlQ29udmVydGVyLmNvbnZlcnRJRCA9IGNvbnZlcnRJRDtcbiAgICBmdW5jdGlvbiBjb252ZXJ0SW50KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCk7XG4gICAgfVxuICAgIFZhbHVlQ29udmVydGVyLmNvbnZlcnRJbnQgPSBjb252ZXJ0SW50O1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRCaWdpbnQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChpbnB1dCk7XG4gICAgfVxuICAgIFZhbHVlQ29udmVydGVyLmNvbnZlcnRCaWdpbnQgPSBjb252ZXJ0QmlnaW50O1xuICAgIGZ1bmN0aW9uIGNvbnZlcnREYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfVxuICAgIFZhbHVlQ29udmVydGVyLmNvbnZlcnREYXRlID0gY29udmVydERhdGU7XG4gICAgZnVuY3Rpb24gY29udmVydE51bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydE51bWJlciA9IGNvbnZlcnROdW1iZXI7XG4gICAgZnVuY3Rpb24gY29udmVydEJvb2xlYW4oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydEJvb2xlYW4gPSBjb252ZXJ0Qm9vbGVhbjtcbn0pKFZhbHVlQ29udmVydGVyIHx8IChWYWx1ZUNvbnZlcnRlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZS1jb252ZXJ0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/parser/value-converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/linker.js":
/*!*******************************************************!*\
  !*** ./node_modules/langium/lib/references/linker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultLinker: () => (/* binding */ DefaultLinker)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../workspace/documents.js */ \"(ssr)/./node_modules/langium/lib/workspace/documents.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nconst ref_resolving = Symbol('ref_resolving');\nclass DefaultLinker {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        for (const node of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(document.parseResult.value)) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);\n            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamReferences)(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        var _a;\n        const ref = refInfo.reference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            ref._ref = ref_resolving;\n            try {\n                const description = this.getCandidate(refInfo);\n                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(description)) {\n                    ref._ref = description;\n                }\n                else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                    }\n                    else {\n                        // Try to load the target AST node later using the already provided description\n                        ref._ref = undefined;\n                    }\n                }\n            }\n            catch (err) {\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\n                const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });\n            }\n            // Add the reference to the document's array of references\n            // Only add if the reference has been not been resolved earlier\n            // Otherwise we end up with duplicates\n            // See also implementation of `buildReference`\n            document.references.push(ref);\n        }\n    }\n    unlink(document) {\n        for (const ref of document.references) {\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref() {\n                var _a;\n                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                }\n                else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNodeDescription)(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                }\n                else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    this._ref = ref_resolving;\n                    const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.findRootNode)(node).$document;\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && document && document.state < _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__.DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\n                        return this._ref = undefined;\n                    }\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                    document === null || document === void 0 ? void 0 : document.references.push(this);\n                }\n                else if (this._ref === ref_resolving) {\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\n                }\n                return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        var _a;\n        try {\n            const description = this.getCandidate(refInfo);\n            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error: this.createLinkingError(refInfo, description)\n                };\n            }\n        }\n        catch (err) {\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\n            const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);\n            return {\n                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.findRootNode)(refInfo.container).$document;\n        if (document && document.state < _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__.DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n    }\n}\n//# sourceMappingURL=linker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9saW5rZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUN1QjtBQUNGO0FBQ3BCO0FBQ0o7QUFDMUQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxRUFBaUI7QUFDeEQsMkJBQTJCLDhEQUFTO0FBQ3BDLGtCQUFrQiwwRUFBaUI7QUFDbkMsWUFBWSxxRUFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBLHlEQUF5RCxjQUFjLDREQUE0RCxhQUFhLEtBQUssYUFBYSxHQUFHO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFFQUFvQjtBQUM3QztBQUNBO0FBQ0Esd0hBQXdILHNDQUFzQztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRUFBWTtBQUNqRCwyREFBMkQsc0NBQXNDO0FBQ2pHLHNFQUFzRSxrRUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDJDQUEyQyxHQUFHLFVBQVUsV0FBVyxRQUFRO0FBQ3hKO0FBQ0EsdUJBQXVCLDBEQUFTO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLCtEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQWM7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMkJBQTJCO0FBQ3hHO0FBQ0E7QUFDQSxxREFBcUQsY0FBYyw0REFBNEQsMkJBQTJCLEtBQUssYUFBYSxHQUFHO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlFQUFZO0FBQ3JDLHlDQUF5QyxrRUFBYTtBQUN0RCx5R0FBeUcsYUFBYTtBQUN0SDtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsMkNBQTJDLGVBQWUsU0FBUywyQkFBMkIsd0JBQXdCO0FBQ2pMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxyZWZlcmVuY2VzXFxsaW5rZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgaXNBc3ROb2RlLCBpc0FzdE5vZGVEZXNjcmlwdGlvbiwgaXNMaW5raW5nRXJyb3IgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBmaW5kUm9vdE5vZGUsIHN0cmVhbUFzdCwgc3RyZWFtUmVmZXJlbmNlcyB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpbnRlcnJ1cHRBbmRDaGVjayB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRTdGF0ZSB9IGZyb20gJy4uL3dvcmtzcGFjZS9kb2N1bWVudHMuanMnO1xuY29uc3QgcmVmX3Jlc29sdmluZyA9IFN5bWJvbCgncmVmX3Jlc29sdmluZycpO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMaW5rZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMucmVmbGVjdGlvbiA9IHNlcnZpY2VzLnNoYXJlZC5Bc3RSZWZsZWN0aW9uO1xuICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudHMgPSAoKSA9PiBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMuc2NvcGVQcm92aWRlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuU2NvcGVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hc3ROb2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICB9XG4gICAgYXN5bmMgbGluayhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdHJlYW1Bc3QoZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICBzdHJlYW1SZWZlcmVuY2VzKG5vZGUpLmZvckVhY2gocmVmID0+IHRoaXMuZG9MaW5rKHJlZiwgZG9jdW1lbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb0xpbmsocmVmSW5mbywgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZWYgPSByZWZJbmZvLnJlZmVyZW5jZTtcbiAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtYXkgYWxyZWFkeSBoYXZlIGJlZW4gcmVzb2x2ZWQgbGF6aWx5IGJ5IGFjY2Vzc2luZyBpdHMgYHJlZmAgcHJvcGVydHkuXG4gICAgICAgIGlmIChyZWYuX3JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWYuX3JlZiA9IHJlZl9yZXNvbHZpbmc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5nZXRDYW5kaWRhdGUocmVmSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlua2luZ0Vycm9yKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYuX3JlZiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLl9ub2RlRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGFuZ2l1bURvY3VtZW50cygpLmhhc0RvY3VtZW50KGRlc2NyaXB0aW9uLmRvY3VtZW50VXJpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBkb2N1bWVudCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua2VkTm9kZSA9IHRoaXMubG9hZEFzdE5vZGUoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLl9yZWYgPSBsaW5rZWROb2RlICE9PSBudWxsICYmIGxpbmtlZE5vZGUgIT09IHZvaWQgMCA/IGxpbmtlZE5vZGUgOiB0aGlzLmNyZWF0ZUxpbmtpbmdFcnJvcihyZWZJbmZvLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbG9hZCB0aGUgdGFyZ2V0IEFTVCBub2RlIGxhdGVyIHVzaW5nIHRoZSBhbHJlYWR5IHByb3ZpZGVkIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuX3JlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXNvbHZpbmcgcmVmZXJlbmNlIHRvICcke3JlZi4kcmVmVGV4dH0nOmAsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKF9hID0gZXJyLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFN0cmluZyhlcnIpO1xuICAgICAgICAgICAgICAgIHJlZi5fcmVmID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZJbmZvKSwgeyBtZXNzYWdlOiBgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVzb2x2aW5nIHJlZmVyZW5jZSB0byAnJHtyZWYuJHJlZlRleHR9JzogJHtlcnJvck1lc3NhZ2V9YCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCdzIGFycmF5IG9mIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIGlmIHRoZSByZWZlcmVuY2UgaGFzIGJlZW4gbm90IGJlZW4gcmVzb2x2ZWQgZWFybGllclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGVuZCB1cCB3aXRoIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIC8vIFNlZSBhbHNvIGltcGxlbWVudGF0aW9uIG9mIGBidWlsZFJlZmVyZW5jZWBcbiAgICAgICAgICAgIGRvY3VtZW50LnJlZmVyZW5jZXMucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubGluayhkb2N1bWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBkb2N1bWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVmLl9yZWY7XG4gICAgICAgICAgICBkZWxldGUgcmVmLl9ub2RlRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVmZXJlbmNlcyA9IFtdO1xuICAgIH1cbiAgICBnZXRDYW5kaWRhdGUocmVmSW5mbykge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVQcm92aWRlci5nZXRTY29wZShyZWZJbmZvKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY29wZS5nZXRFbGVtZW50KHJlZkluZm8ucmVmZXJlbmNlLiRyZWZUZXh0KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uICE9PSB2b2lkIDAgPyBkZXNjcmlwdGlvbiA6IHRoaXMuY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8pO1xuICAgIH1cbiAgICBidWlsZFJlZmVyZW5jZShub2RlLCBwcm9wZXJ0eSwgcmVmTm9kZSwgcmVmVGV4dCkge1xuICAgICAgICAvLyBTZWUgYmVoYXZpb3IgZGVzY3JpcHRpb24gaW4gZG9jIG9mIExpbmtlciwgdXBkYXRlIHRoYXQgb24gY2hhbmdlcyBpbiBoZXJlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgY29uc3QgbGlua2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0ge1xuICAgICAgICAgICAgJHJlZk5vZGU6IHJlZk5vZGUsXG4gICAgICAgICAgICAkcmVmVGV4dDogcmVmVGV4dCxcbiAgICAgICAgICAgIGdldCByZWYoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodGhpcy5fcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3N0IGZyZXF1ZW50IGNhc2U6IHRoZSB0YXJnZXQgaXMgYWxyZWFkeSByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3ROb2RlRGVzY3JpcHRpb24odGhpcy5fbm9kZURlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGNhbmRpZGF0ZSBoYXMgYmVlbiBmb3VuZCBiZWZvcmUsIGJ1dCBpdCBpcyBub3QgbG9hZGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua2VkTm9kZSA9IGxpbmtlci5sb2FkQXN0Tm9kZSh0aGlzLl9ub2RlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWYgPSBsaW5rZWROb2RlICE9PSBudWxsICYmIGxpbmtlZE5vZGUgIT09IHZvaWQgMCA/IGxpbmtlZE5vZGUgOiBsaW5rZXIuY3JlYXRlTGlua2luZ0Vycm9yKHsgcmVmZXJlbmNlLCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5IH0sIHRoaXMuX25vZGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgaGFzIG5vdCBiZWVuIGxpbmtlZCB5ZXQsIHNvIGRvIHRoYXQgbm93LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWYgPSByZWZfcmVzb2x2aW5nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGZpbmRSb290Tm9kZShub2RlKS4kZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSBsaW5rZXIuZ2V0TGlua2VkTm9kZSh7IHJlZmVyZW5jZSwgY29udGFpbmVyOiBub2RlLCBwcm9wZXJ0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkRhdGEuZXJyb3IgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuc3RhdGUgPCBEb2N1bWVudFN0YXRlLkNvbXB1dGVkU2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBzY29wZSBpcyBub3QgcmVhZHksIGRvbid0IHNldCBgdGhpcy5fcmVmYCBzbyBsaW5rZXIgY2FuIHJldHJ5IGxhdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWYgPSAoX2EgPSByZWZEYXRhLm5vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlZkRhdGEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGVEZXNjcmlwdGlvbiA9IHJlZkRhdGEuZGVzY3I7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50ID09PSBudWxsIHx8IGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudC5yZWZlcmVuY2VzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlZiA9PT0gcmVmX3Jlc29sdmluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN5Y2xpYyByZWZlcmVuY2UgcmVzb2x1dGlvbiBkZXRlY3RlZDogJHtsaW5rZXIuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgobm9kZSl9LyR7cHJvcGVydHl9IChzeW1ib2wgJyR7cmVmVGV4dH0nKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNBc3ROb2RlKHRoaXMuX3JlZikgPyB0aGlzLl9yZWYgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0ICRub2RlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVEZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTGlua2luZ0Vycm9yKHRoaXMuX3JlZikgPyB0aGlzLl9yZWYgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfVxuICAgIGdldExpbmtlZE5vZGUocmVmSW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMuZ2V0Q2FuZGlkYXRlKHJlZkluZm8pO1xuICAgICAgICAgICAgaWYgKGlzTGlua2luZ0Vycm9yKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBkZXNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlua2VkTm9kZSA9IHRoaXMubG9hZEFzdE5vZGUoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbmtlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBsaW5rZWROb2RlLCBkZXNjcjogZGVzY3JpcHRpb24gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8sIGRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVzb2x2aW5nIHJlZmVyZW5jZSB0byAnJHtyZWZJbmZvLnJlZmVyZW5jZS4kcmVmVGV4dH0nOmAsIGVycik7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoX2EgPSBlcnIubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyaW5nKGVycik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZkluZm8pLCB7IG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXNvbHZpbmcgcmVmZXJlbmNlIHRvICcke3JlZkluZm8ucmVmZXJlbmNlLiRyZWZUZXh0fSc6ICR7ZXJyb3JNZXNzYWdlfWAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZEFzdE5vZGUobm9kZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChub2RlRGVzY3JpcHRpb24ubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVEZXNjcmlwdGlvbi5ub2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMubGFuZ2l1bURvY3VtZW50cygpLmdldERvY3VtZW50KG5vZGVEZXNjcmlwdGlvbi5kb2N1bWVudFVyaSk7XG4gICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzdE5vZGVMb2NhdG9yLmdldEFzdE5vZGUoZG9jLnBhcnNlUmVzdWx0LnZhbHVlLCBub2RlRGVzY3JpcHRpb24ucGF0aCk7XG4gICAgfVxuICAgIGNyZWF0ZUxpbmtpbmdFcnJvcihyZWZJbmZvLCB0YXJnZXREZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBpcyBzdWZmaWNpZW50bHkgcHJvY2Vzc2VkIGJ5IHRoZSBEb2N1bWVudEJ1aWxkZXIuIElmIG5vdCwgdGhpcyBpcyBhIGhpbnQgZm9yIGEgYnVnXG4gICAgICAgIC8vIGluIHRoZSBsYW5ndWFnZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBmaW5kUm9vdE5vZGUocmVmSW5mby5jb250YWluZXIpLiRkb2N1bWVudDtcbiAgICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LnN0YXRlIDwgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3Blcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ZWQgcmVmZXJlbmNlIHJlc29sdXRpb24gYmVmb3JlIGRvY3VtZW50IHJlYWNoZWQgQ29tcHV0ZWRTY29wZXMgc3RhdGUgKCR7ZG9jdW1lbnQudXJpfSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHRoaXMucmVmbGVjdGlvbi5nZXRSZWZlcmVuY2VUeXBlKHJlZkluZm8pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZJbmZvKSwgeyBtZXNzYWdlOiBgQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlIHRvICR7cmVmZXJlbmNlVHlwZX0gbmFtZWQgJyR7cmVmSW5mby5yZWZlcmVuY2UuJHJlZlRleHR9Jy5gLCB0YXJnZXREZXNjcmlwdGlvbiB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/linker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/name-provider.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/references/name-provider.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultNameProvider: () => (/* binding */ DefaultNameProvider),\n/* harmony export */   isNamed: () => (/* binding */ isNamed)\n/* harmony export */ });\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nfunction isNamed(node) {\n    return typeof node.name === 'string';\n}\nclass DefaultNameProvider {\n    getName(node) {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n    getNameNode(node) {\n        return (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__.findNodeForProperty)(node.$cstNode, 'name');\n    }\n}\n//# sourceMappingURL=name-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9uYW1lLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0U7QUFDekQ7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEVBQW1CO0FBQ2xDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxyZWZlcmVuY2VzXFxuYW1lLXByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGZpbmROb2RlRm9yUHJvcGVydHkgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVkKG5vZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5vZGUubmFtZSA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdE5hbWVQcm92aWRlciB7XG4gICAgZ2V0TmFtZShub2RlKSB7XG4gICAgICAgIGlmIChpc05hbWVkKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldE5hbWVOb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlRm9yUHJvcGVydHkobm9kZS4kY3N0Tm9kZSwgJ25hbWUnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/name-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/references.js":
/*!***********************************************************!*\
  !*** ./node_modules/langium/lib/references/references.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultReferences: () => (/* binding */ DefaultReferences)\n/* harmony export */ });\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/uri-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultReferences {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__.findAssignment)(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(reference)) {\n                    return reference.ref;\n                }\n                else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.isChildNode)(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return undefined;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.stream)(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.getDocument)(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.toDocumentSegment)(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=references.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9yZWZlcmVuY2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBQ1g7QUFDSTtBQUNtQjtBQUMzQjtBQUNLO0FBQzFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdFQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx5REFBUTtBQUNwRTtBQUNBO0FBQ0EsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0VBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHJlZmVyZW5jZXNcXHJlZmVyZW5jZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZmluZEFzc2lnbm1lbnQgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNDaGlsZE5vZGUsIHRvRG9jdW1lbnRTZWdtZW50IH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBVcmlVdGlscyB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFJlZmVyZW5jZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICB9XG4gICAgZmluZERlY2xhcmF0aW9uKHNvdXJjZUNzdE5vZGUpIHtcbiAgICAgICAgaWYgKHNvdXJjZUNzdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBmaW5kQXNzaWdubWVudChzb3VyY2VDc3ROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtID0gc291cmNlQ3N0Tm9kZS5hc3ROb2RlO1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQgJiYgbm9kZUVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBub2RlRWxlbVthc3NpZ25tZW50LmZlYXR1cmVdO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2UucmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UocmVmKSAmJiByZWYuJHJlZk5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByZWYuJHJlZk5vZGUub2Zmc2V0IDw9IHNvdXJjZUNzdE5vZGUub2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcmVmLiRyZWZOb2RlLmVuZCA+PSBzb3VyY2VDc3ROb2RlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVFbGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZU5vZGUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lTm9kZShub2RlRWxlbSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXR1cm4gdGhlIHRhcmdldGVkIG5vZGUgaW4gY2FzZSB0aGUgdGFyZ2V0ZWQgY3N0IG5vZGUgaXMgdGhlIG5hbWUgbm9kZSBvciBwYXJ0IG9mIGl0XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVOb2RlICYmIChuYW1lTm9kZSA9PT0gc291cmNlQ3N0Tm9kZSB8fCBpc0NoaWxkTm9kZShzb3VyY2VDc3ROb2RlLCBuYW1lTm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlRWxlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZERlY2xhcmF0aW9uTm9kZShzb3VyY2VDc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGUgPSB0aGlzLmZpbmREZWNsYXJhdGlvbihzb3VyY2VDc3ROb2RlKTtcbiAgICAgICAgaWYgKGFzdE5vZGUgPT09IG51bGwgfHwgYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0Tm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKGFzdE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldE5vZGUgIT09IG51bGwgJiYgdGFyZ2V0Tm9kZSAhPT0gdm9pZCAwID8gdGFyZ2V0Tm9kZSA6IGFzdE5vZGUuJGNzdE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZFJlZmVyZW5jZXModGFyZ2V0Tm9kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZWZzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRSZWZlcmVuY2VUb1NlbGYodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4UmVmZXJlbmNlcyA9IHRoaXMuaW5kZXguZmluZEFsbFJlZmVyZW5jZXModGFyZ2V0Tm9kZSwgdGhpcy5ub2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aCh0YXJnZXROb2RlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLmRvY3VtZW50VXJpKSB7XG4gICAgICAgICAgICBpbmRleFJlZmVyZW5jZXMgPSBpbmRleFJlZmVyZW5jZXMuZmlsdGVyKHJlZiA9PiBVcmlVdGlscy5lcXVhbHMocmVmLnNvdXJjZVVyaSwgb3B0aW9ucy5kb2N1bWVudFVyaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZnMucHVzaCguLi5pbmRleFJlZmVyZW5jZXMpO1xuICAgICAgICByZXR1cm4gc3RyZWFtKHJlZnMpO1xuICAgIH1cbiAgICBnZXRSZWZlcmVuY2VUb1NlbGYodGFyZ2V0Tm9kZSkge1xuICAgICAgICBjb25zdCBuYW1lTm9kZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKHRhcmdldE5vZGUpO1xuICAgICAgICBpZiAobmFtZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMubm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVVyaTogZG9jLnVyaSxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHRhcmdldFVyaTogZG9jLnVyaSxcbiAgICAgICAgICAgICAgICB0YXJnZXRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHRvRG9jdW1lbnRTZWdtZW50KG5hbWVOb2RlKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmVyZW5jZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/references.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/scope-computation.js":
/*!******************************************************************!*\
  !*** ./node_modules/langium/lib/references/scope-computation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultScopeComputation: () => (/* binding */ DefaultScopeComputation)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/collections.js */ \"(ssr)/./node_modules/langium/lib/utils/collections.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nclass DefaultScopeComputation {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCancelled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode, document, children = _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamContents, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n    async computeLocalScopes(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_3__.MultiMap();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rootNode)) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n}\n//# sourceMappingURL=scope-computation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9zY29wZS1jb21wdXRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDYTtBQUN2QjtBQUNXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFFQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDLGVBQWUsMEJBQTBCO0FBQ3ZHLHNGQUFzRixlQUFlO0FBQ3JHLCtDQUErQyxrQkFBa0I7QUFDakU7QUFDQSxxRUFBcUUsMEJBQTBCO0FBQy9GO0FBQ0EsK0NBQStDLGtCQUFrQixxQ0FBcUMsZ0JBQWdCLDJGQUEyRixpQkFBaUI7QUFDbE87QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQSxpRUFBaUUsK0RBQWMsZ0JBQWdCLHFFQUFpQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEVBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUVBQWlCO0FBQ3RFO0FBQ0EsMkJBQTJCLDJEQUFRO0FBQ25DO0FBQ0EsMkJBQTJCLHNFQUFpQjtBQUM1QyxrQkFBa0IsMEVBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxccmVmZXJlbmNlc1xcc2NvcGUtY29tcHV0YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBzdHJlYW1BbGxDb250ZW50cywgc3RyZWFtQ29udGVudHMgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICcuLi91dGlscy9jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBpbnRlcnJ1cHRBbmRDaGVjayB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBzY29wZSBjb21wdXRhdGlvbiBjcmVhdGVzIGFuZCBjb2xsZWN0ZXMgZGVzY3JpcHRpb25zIG9mIHRoZSBBU1Qgbm9kZXMgdG8gYmUgZXhwb3J0ZWQgaW50byB0aGVcbiAqIF9nbG9iYWxfIHNjb3BlIGZyb20gdGhlIGdpdmVuIGRvY3VtZW50LiBCeSBkZWZhdWx0IHRob3NlIGFyZSB0aGUgZG9jdW1lbnQncyByb290IEFTVCBub2RlIGFuZCBpdHMgZGlyZWN0bHlcbiAqIGNvbnRhaW5lZCBjaGlsZCBub2Rlcy5cbiAqXG4gKiBCZXNpZGVzLCBpdCBnYXRoZXJzIGFsbCBBU1Qgbm9kZXMgdGhhdCBoYXZlIGEgbmFtZSAoYWNjb3JkaW5nIHRvIHRoZSBgTmFtZVByb3ZpZGVyYCBzZXJ2aWNlKSBhbmQgaW5jbHVkZXMgdGhlbVxuICogaW4gdGhlIGxvY2FsIHNjb3BlIG9mIHRoZWlyIHBhcnRpY3VsYXIgY29udGFpbmVyIG5vZGVzLiBBcyBhIHJlc3VsdCwgZm9yIGV2ZXJ5IGNyb3NzLXJlZmVyZW5jZSBpbiB0aGUgQVNULFxuICogdGFyZ2V0IGVsZW1lbnRzIGZyb20gdGhlIHNhbWUgbGV2ZWwgKHNpYmxpbmdzKSBhbmQgZnVydGhlciB1cCB0b3dhcmRzIHRoZSByb290IChwYXJlbnRzIGFuZCBzaWJsaW5ncyBvZiBwYXJlbnRzKVxuICogYXJlIHZpc2libGUuIEVsZW1lbnRzIGJlaW5nIG5lc3RlZCBpbnNpZGUgbG93ZXIgbGV2ZWxzIChjaGlsZHJlbiwgY2hpbGRyZW4gb2Ygc2libGluZ3MgYW5kIHBhcmVudHMnIHNpYmxpbmdzKVxuICogYXJlIF9pbnZpc2libGVfIGJ5IGRlZmF1bHQsIGJ1dCB0aGF0IGNhbiBiZSBjaGFuZ2VkIGJ5IGN1c3RvbWl6aW5nIHRoaXMgc2VydmljZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRTY29wZUNvbXB1dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLm5hbWVQcm92aWRlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTmFtZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9ucyA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlcjtcbiAgICB9XG4gICAgYXN5bmMgY29tcHV0ZUV4cG9ydHMoZG9jdW1lbnQsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRXhwb3J0c0Zvck5vZGUoZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUsIGRvY3VtZW50LCB1bmRlZmluZWQsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgQXN0Tm9kZURlc2NyaXB0aW9uIEFzdE5vZGVEZXNjcmlwdGlvbnN9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIEFzdE5vZGUgcGFyZW50Tm9kZX0gYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBUaGUgbGlzdCBvZiBjaGlsZHJlbiB0byBiZSBjb25zaWRlcmVkIGlzIGRldGVybWluZWQgYnkgdGhlIGZ1bmN0aW9uIHBhcmFtZXRlciB7QGxpbmsgY2hpbGRyZW59LlxuICAgICAqIEJ5IGRlZmF1bHQgb25seSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHtAbGluayBwYXJlbnROb2RlfSBhcmUgdmlzaXRlZCwgbmVzdGVkIG5vZGVzIGFyZSBub3QgZXhwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50Tm9kZSBBU1Qgbm9kZSB0byBiZSBleHBvcnRlZCwgaS5lLiwgb2Ygd2hpY2ggYW4ge0BsaW5rIEFzdE5vZGVEZXNjcmlwdGlvbn0gc2hhbGwgYmUgYWRkZWQgdG8gdGhlIHJldHVybmVkIGxpc3QuXG4gICAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBBU1Qgbm9kZSB0byBiZSBleHBvcnRlZC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB7QGxpbmsgcGFyZW50Tm9kZX0gYXMgc2luZ2xlIGFyZ3VtZW50IGFuZCByZXR1cm5pbmcgYW4ge0BsaW5rIEl0ZXJhYmxlfSBzdXBwbHlpbmcgdGhlIGNoaWxkcmVuIHRvIGJlIHZpc2l0ZWQsIHdoaWNoIG11c3QgYmUgZGlyZWN0bHkgb3IgdHJhbnNpdGl2ZWx5IGNvbnRhaW5lZCBpbiB7QGxpbmsgcGFyZW50Tm9kZX0uXG4gICAgICogQHBhcmFtIGNhbmNlbFRva2VuIEluZGljYXRlcyB3aGVuIHRvIGNhbmNlbCB0aGUgY3VycmVudCBvcGVyYXRpb24uXG4gICAgICogQHRocm93cyBgT3BlcmF0aW9uQ2FuY2VsbGVkYCBpZiBhIHVzZXIgYWN0aW9uIG9jY3VycyBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiB7QGxpbmsgQXN0Tm9kZURlc2NyaXB0aW9uIEFzdE5vZGVEZXNjcmlwdGlvbnN9IHRvIGJlIHB1Ymxpc2hlZCB0byBpbmRleC5cbiAgICAgKi9cbiAgICBhc3luYyBjb21wdXRlRXhwb3J0c0Zvck5vZGUocGFyZW50Tm9kZSwgZG9jdW1lbnQsIGNoaWxkcmVuID0gc3RyZWFtQ29udGVudHMsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBleHBvcnRzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0Tm9kZShwYXJlbnROb2RlLCBleHBvcnRzLCBkb2N1bWVudCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGlsZHJlbihwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5leHBvcnROb2RlKG5vZGUsIGV4cG9ydHMsIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2luZ2xlIG5vZGUgdG8gdGhlIGxpc3Qgb2YgZXhwb3J0cyBpZiBpdCBoYXMgYSBuYW1lLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgaG93XG4gICAgICogc3ltYm9scyBhcmUgZXhwb3J0ZWQsIGUuZy4gYnkgbW9kaWZ5aW5nIHRoZWlyIGV4cG9ydGVkIG5hbWUuXG4gICAgICovXG4gICAgZXhwb3J0Tm9kZShub2RlLCBleHBvcnRzLCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZShub2RlKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMucHVzaCh0aGlzLmRlc2NyaXB0aW9ucy5jcmVhdGVEZXNjcmlwdGlvbihub2RlLCBuYW1lLCBkb2N1bWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNvbXB1dGVMb2NhbFNjb3Blcyhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBNdWx0aU1hcCgpO1xuICAgICAgICAvLyBIZXJlIHdlIG5hdmlnYXRlIHRoZSBmdWxsIEFTVCAtIGxvY2FsIHNjb3BlcyBzaGFsbCBiZSBhdmFpbGFibGUgaW4gdGhlIHdob2xlIGRvY3VtZW50XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdHJlYW1BbGxDb250ZW50cyhyb290Tm9kZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vZGUobm9kZSwgZG9jdW1lbnQsIHNjb3Blcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHNpbmdsZSBub2RlIGR1cmluZyBzY29wZXMgY29tcHV0YXRpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG1ha2VzIHRoZSBub2RlIHZpc2libGVcbiAgICAgKiBpbiB0aGUgc3VidHJlZSBvZiBpdHMgY29udGFpbmVyIChpZiB0aGUgbm9kZSBoYXMgYSBuYW1lKS4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoaXMsXG4gICAgICogZS5nLiBieSBpbmNyZWFzaW5nIHRoZSB2aXNpYmlsaXR5IHRvIGEgaGlnaGVyIGxldmVsIGluIHRoZSBBU1QuXG4gICAgICovXG4gICAgcHJvY2Vzc05vZGUobm9kZSwgZG9jdW1lbnQsIHNjb3Blcykge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub2RlLiRjb250YWluZXI7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzY29wZXMuYWRkKGNvbnRhaW5lciwgdGhpcy5kZXNjcmlwdGlvbnMuY3JlYXRlRGVzY3JpcHRpb24obm9kZSwgbmFtZSwgZG9jdW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLWNvbXB1dGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/scope-computation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/scope-provider.js":
/*!***************************************************************!*\
  !*** ./node_modules/langium/lib/references/scope-provider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultScopeProvider: () => (/* binding */ DefaultScopeProvider)\n/* harmony export */ });\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scope.js */ \"(ssr)/./node_modules/langium/lib/references/scope.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/caching.js */ \"(ssr)/./node_modules/langium/lib/utils/caching.js\");\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\nclass DefaultScopeProvider {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__.WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push((0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    createScope(elements, outerScope, options) {\n        return new _scope_js__WEBPACK_IMPORTED_MODULE_3__.StreamScope((0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(elements), outerScope, options);\n    }\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    createScopeForNodes(elements, outerScope, options) {\n        const s = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new _scope_js__WEBPACK_IMPORTED_MODULE_3__.StreamScope(s, outerScope, options);\n    }\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, () => new _scope_js__WEBPACK_IMPORTED_MODULE_3__.MapScope(this.indexManager.allElements(referenceType)));\n    }\n}\n//# sourceMappingURL=scope-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9zY29wZS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDQztBQUNSO0FBQ1M7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZEQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQU07QUFDdEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVyxDQUFDLHdEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixrREFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLCtDQUFRO0FBQzFFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxyZWZlcmVuY2VzXFxzY29wZS1wcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IE1hcFNjb3BlLCBTdHJlYW1TY29wZSB9IGZyb20gJy4vc2NvcGUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFdvcmtzcGFjZUNhY2hlIH0gZnJvbSAnLi4vdXRpbHMvY2FjaGluZy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFNjb3BlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMucmVmbGVjdGlvbiA9IHNlcnZpY2VzLnNoYXJlZC5Bc3RSZWZsZWN0aW9uO1xuICAgICAgICB0aGlzLm5hbWVQcm92aWRlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTmFtZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9ucyA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5nbG9iYWxTY29wZUNhY2hlID0gbmV3IFdvcmtzcGFjZUNhY2hlKHNlcnZpY2VzLnNoYXJlZCk7XG4gICAgfVxuICAgIGdldFNjb3BlKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gW107XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0aGlzLnJlZmxlY3Rpb24uZ2V0UmVmZXJlbmNlVHlwZShjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcHJlY29tcHV0ZWQgPSBnZXREb2N1bWVudChjb250ZXh0LmNvbnRhaW5lcikucHJlY29tcHV0ZWRTY29wZXM7XG4gICAgICAgIGlmIChwcmVjb21wdXRlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gY29udGV4dC5jb250YWluZXI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRGVzY3JpcHRpb25zID0gcHJlY29tcHV0ZWQuZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGVzY3JpcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzLnB1c2goc3RyZWFtKGFsbERlc2NyaXB0aW9ucykuZmlsdGVyKGRlc2MgPT4gdGhpcy5yZWZsZWN0aW9uLmlzU3VidHlwZShkZXNjLnR5cGUsIHJlZmVyZW5jZVR5cGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxTY29wZShyZWZlcmVuY2VUeXBlLCBjb250ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNjb3Blcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jcmVhdGVTY29wZShzY29wZXNbaV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2NvcGUgZm9yIHRoZSBnaXZlbiBjb2xsZWN0aW9uIG9mIEFTVCBub2RlIGRlc2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBjcmVhdGVTY29wZShlbGVtZW50cywgb3V0ZXJTY29wZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVNjb3BlKHN0cmVhbShlbGVtZW50cyksIG91dGVyU2NvcGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzY29wZSBmb3IgdGhlIGdpdmVuIGNvbGxlY3Rpb24gb2YgQVNUIG5vZGVzLCB3aGljaCBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gcmVzcGVjdGl2ZVxuICAgICAqIGRlc2NyaXB0aW9ucyBmaXJzdC4gVGhpcyBpcyBkb25lIHVzaW5nIHRoZSBgTmFtZVByb3ZpZGVyYCBhbmQgYEFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyYCBzZXJ2aWNlcy5cbiAgICAgKi9cbiAgICBjcmVhdGVTY29wZUZvck5vZGVzKGVsZW1lbnRzLCBvdXRlclNjb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHMgPSBzdHJlYW0oZWxlbWVudHMpLm1hcChlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbnMuY3JlYXRlRGVzY3JpcHRpb24oZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KS5ub25OdWxsYWJsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVNjb3BlKHMsIG91dGVyU2NvcGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnbG9iYWwgc2NvcGUgZmlsdGVyZWQgZm9yIHRoZSBnaXZlbiByZWZlcmVuY2UgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRHbG9iYWxTY29wZShyZWZlcmVuY2VUeXBlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxTY29wZUNhY2hlLmdldChyZWZlcmVuY2VUeXBlLCAoKSA9PiBuZXcgTWFwU2NvcGUodGhpcy5pbmRleE1hbmFnZXIuYWxsRWxlbWVudHMocmVmZXJlbmNlVHlwZSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/scope-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/references/scope.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/references/scope.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY_SCOPE: () => (/* binding */ EMPTY_SCOPE),\n/* harmony export */   MapScope: () => (/* binding */ MapScope),\n/* harmony export */   StreamScope: () => (/* binding */ StreamScope)\n/* harmony export */ });\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nclass StreamScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        }\n        else {\n            return this.elements;\n        }\n    }\n    getElement(name) {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\nclass MapScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n    getAllElements() {\n        let elementStream = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n}\nconst EMPTY_SCOPE = {\n    getElement() {\n        return undefined;\n    },\n    getAllElements() {\n        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STREAM;\n    }\n};\n//# sourceMappingURL=scope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9zY29wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3REFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLDBEQUFZO0FBQzNCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxyZWZlcmVuY2VzXFxzY29wZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBFTVBUWV9TVFJFQU0sIHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNjb3BlIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIGEgYFN0cmVhbWAuIEl0IGhhcyBhbiBvcHRpb25hbCBfb3V0ZXIgc2NvcGVfIGRlc2NyaWJpbmdcbiAqIHRoZSBuZXh0IGxldmVsIG9mIGVsZW1lbnRzLCB3aGljaCBhcmUgcXVlcmllZCB3aGVuIGEgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGZvdW5kIGluIHRoZSBzdHJlYW0gcHJvdmlkZWRcbiAqIHRvIHRoaXMgc2NvcGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TY29wZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMsIG91dGVyU2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIHRoaXMub3V0ZXJTY29wZSA9IG91dGVyU2NvcGU7XG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgfVxuICAgIGdldEFsbEVsZW1lbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRlclNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5jb25jYXQodGhpcy5vdXRlclNjb3BlLmdldEFsbEVsZW1lbnRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RWxlbWVudChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5jYXNlSW5zZW5zaXRpdmVcbiAgICAgICAgICAgID8gdGhpcy5lbGVtZW50cy5maW5kKGUgPT4gZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgIDogdGhpcy5lbGVtZW50cy5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0ZXJTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJTY29wZS5nZXRFbGVtZW50KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hcFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cywgb3V0ZXJTY29wZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50Lm5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIDogZWxlbWVudC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5zZXQobmFtZSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlclNjb3BlID0gb3V0ZXJTY29wZTtcbiAgICB9XG4gICAgZ2V0RWxlbWVudChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogbmFtZTtcbiAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzLmVsZW1lbnRzLmdldChsb2NhbE5hbWUpO1xuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRlclNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRlclNjb3BlLmdldEVsZW1lbnQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0QWxsRWxlbWVudHMoKSB7XG4gICAgICAgIGxldCBlbGVtZW50U3RyZWFtID0gc3RyZWFtKHRoaXMuZWxlbWVudHMudmFsdWVzKCkpO1xuICAgICAgICBpZiAodGhpcy5vdXRlclNjb3BlKSB7XG4gICAgICAgICAgICBlbGVtZW50U3RyZWFtID0gZWxlbWVudFN0cmVhbS5jb25jYXQodGhpcy5vdXRlclNjb3BlLmdldEFsbEVsZW1lbnRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50U3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBFTVBUWV9TQ09QRSA9IHtcbiAgICBnZXRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0QWxsRWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9TVFJFQU07XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/references/scope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/serializer/hydrator.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/serializer/hydrator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultHydrator: () => (/* binding */ DefaultHydrator)\n/* harmony export */ });\n/* harmony import */ var _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser/cst-node-builder.js */ \"(ssr)/./node_modules/langium/lib/parser/cst-node-builder.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ \"(ssr)/./node_modules/langium/lib/utils/collections.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultHydrator {\n    constructor(services) {\n        this.grammarElementIdMap = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.BiMap();\n        this.tokenTypeIdMap = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            parserErrors: result.parserErrors.map(e => (Object.assign(Object.assign({}, e), { message: e.message }))),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    dehydrateLexerReport(lexerReport) {\n        // By default, lexer reports are serializable\n        return lexerReport;\n    }\n    createDehyrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.streamCst)(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    }\n                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            }\n            else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isRootCstNode)(node)) {\n            cstNode.fullText = node.fullText;\n        }\n        else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        }\n        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLeafCstNode)(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if ('$cstNode' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            lexerReport: result.lexerReport,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(node)) {\n            astNodes.set(astNode, {});\n        }\n        let root;\n        if (node.$cstNode) {\n            for (const cstNode of (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.streamCst)(node.$cstNode)) {\n                let cst;\n                if ('fullText' in cstNode) {\n                    cst = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.RootCstNodeImpl(cstNode.fullText);\n                    root = cst;\n                }\n                else if ('content' in cstNode) {\n                    cst = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.CompositeCstNodeImpl();\n                }\n                else if ('tokenType' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    }\n                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            }\n            else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === 'number') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (!node) {\n            return undefined;\n        }\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        return element;\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(this.grammar)) {\n            if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_5__.isAbstractElement)(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n}\n//# sourceMappingURL=hydrator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc2VyaWFsaXplci9oeWRyYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RztBQUNyQztBQUMyQztBQUMzRDtBQUNGO0FBQ0U7QUFDM0M7QUFDUDtBQUNBLHVDQUF1Qyx3REFBSztBQUM1QyxrQ0FBa0Msd0RBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsUUFBUSxvQkFBb0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQVM7QUFDdkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxrQ0FBa0MsOERBQVM7QUFDM0Msd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakM7QUFDQTtBQUNBLDZCQUE2Qiw0REFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBUztBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLDREQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQWtCO0FBQzlCO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBUztBQUN2QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhEQUFTO0FBQzNDO0FBQ0E7QUFDQSw4QkFBOEIsd0VBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZFQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBUztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCLDREQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFTO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsNERBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0VBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQVM7QUFDdkMsZ0JBQWdCLDhFQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcc2VyaWFsaXplclxcaHlkcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjQgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ29tcG9zaXRlQ3N0Tm9kZUltcGwsIExlYWZDc3ROb2RlSW1wbCwgUm9vdENzdE5vZGVJbXBsIH0gZnJvbSAnLi4vcGFyc2VyL2NzdC1ub2RlLWJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgaXNBYnN0cmFjdEVsZW1lbnQgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBpc1Jvb3RDc3ROb2RlLCBpc0NvbXBvc2l0ZUNzdE5vZGUsIGlzTGVhZkNzdE5vZGUsIGlzQXN0Tm9kZSwgaXNSZWZlcmVuY2UgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBzdHJlYW1Bc3QgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgQmlNYXAgfSBmcm9tICcuLi91dGlscy9jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBzdHJlYW1Dc3QgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRIeWRyYXRvciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5ncmFtbWFyRWxlbWVudElkTWFwID0gbmV3IEJpTWFwKCk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlSWRNYXAgPSBuZXcgQmlNYXAoKTtcbiAgICAgICAgdGhpcy5ncmFtbWFyID0gc2VydmljZXMuR3JhbW1hcjtcbiAgICAgICAgdGhpcy5sZXhlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlcjtcbiAgICAgICAgdGhpcy5saW5rZXIgPSBzZXJ2aWNlcy5yZWZlcmVuY2VzLkxpbmtlcjtcbiAgICB9XG4gICAgZGVoeWRyYXRlKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGV4ZXJFcnJvcnM6IHJlc3VsdC5sZXhlckVycm9ycyxcbiAgICAgICAgICAgIGxleGVyUmVwb3J0OiByZXN1bHQubGV4ZXJSZXBvcnQgPyB0aGlzLmRlaHlkcmF0ZUxleGVyUmVwb3J0KHJlc3VsdC5sZXhlclJlcG9ydCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBzaGFsbG93IGNvcGllcyBvZiB0aGUgZXJyb3JzXG4gICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgZXJyb3JzIGluaGVyaXQgZnJvbSB0aGUgYEVycm9yYCBjbGFzcywgd2hpY2ggaXMgbm90IHRyYW5zZmVyYWJsZSBhY3Jvc3Mgd29ya2VyIHRocmVhZHNcbiAgICAgICAgICAgIHBhcnNlckVycm9yczogcmVzdWx0LnBhcnNlckVycm9ycy5tYXAoZSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlKSwgeyBtZXNzYWdlOiBlLm1lc3NhZ2UgfSkpKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRlaHlkcmF0ZUFzdE5vZGUocmVzdWx0LnZhbHVlLCB0aGlzLmNyZWF0ZURlaHlyYXRpb25Db250ZXh0KHJlc3VsdC52YWx1ZSkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRlaHlkcmF0ZUxleGVyUmVwb3J0KGxleGVyUmVwb3J0KSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGxleGVyIHJlcG9ydHMgYXJlIHNlcmlhbGl6YWJsZVxuICAgICAgICByZXR1cm4gbGV4ZXJSZXBvcnQ7XG4gICAgfVxuICAgIGNyZWF0ZURlaHlyYXRpb25Db250ZXh0KG5vZGUpIHtcbiAgICAgICAgY29uc3QgYXN0Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNzdE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGFzdE5vZGUgb2Ygc3RyZWFtQXN0KG5vZGUpKSB7XG4gICAgICAgICAgICBhc3ROb2Rlcy5zZXQoYXN0Tm9kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLiRjc3ROb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNzdE5vZGUgb2Ygc3RyZWFtQ3N0KG5vZGUuJGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY3N0Tm9kZXMuc2V0KGNzdE5vZGUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN0Tm9kZXMsXG4gICAgICAgICAgICBjc3ROb2Rlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWh5ZHJhdGVBc3ROb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIG9iai4kdHlwZSA9IG5vZGUuJHR5cGU7XG4gICAgICAgIG9iai4kY29udGFpbmVySW5kZXggPSBub2RlLiRjb250YWluZXJJbmRleDtcbiAgICAgICAgb2JqLiRjb250YWluZXJQcm9wZXJ0eSA9IG5vZGUuJGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouJGNzdE5vZGUgPSB0aGlzLmRlaHlkcmF0ZUNzdE5vZGUobm9kZS4kY3N0Tm9kZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IGFycjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5kZWh5ZHJhdGVBc3ROb2RlKGl0ZW0sIGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZmVyZW5jZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5kZWh5ZHJhdGVSZWZlcmVuY2UoaXRlbSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqW25hbWVdID0gdGhpcy5kZWh5ZHJhdGVBc3ROb2RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IHRoaXMuZGVoeWRyYXRlUmVmZXJlbmNlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBkZWh5ZHJhdGVSZWZlcmVuY2UocmVmZXJlbmNlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBvYmouJHJlZlRleHQgPSByZWZlcmVuY2UuJHJlZlRleHQ7XG4gICAgICAgIGlmIChyZWZlcmVuY2UuJHJlZk5vZGUpIHtcbiAgICAgICAgICAgIG9iai4kcmVmTm9kZSA9IGNvbnRleHQuY3N0Tm9kZXMuZ2V0KHJlZmVyZW5jZS4kcmVmTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZGVoeWRyYXRlQ3N0Tm9kZShub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNzdE5vZGUgPSBjb250ZXh0LmNzdE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgaWYgKGlzUm9vdENzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGNzdE5vZGUuZnVsbFRleHQgPSBub2RlLmZ1bGxUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90ZTogVGhpcyByZXR1cm5zIHVuZGVmaW5lZCBmb3IgaGlkZGVuIG5vZGVzIChpLmUuIGNvbW1lbnRzKVxuICAgICAgICAgICAgY3N0Tm9kZS5ncmFtbWFyU291cmNlID0gdGhpcy5nZXRHcmFtbWFyRWxlbWVudElkKG5vZGUuZ3JhbW1hclNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3N0Tm9kZS5oaWRkZW4gPSBub2RlLmhpZGRlbjtcbiAgICAgICAgY3N0Tm9kZS5hc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZS5hc3ROb2RlKTtcbiAgICAgICAgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgY3N0Tm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50Lm1hcChjaGlsZCA9PiB0aGlzLmRlaHlkcmF0ZUNzdE5vZGUoY2hpbGQsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xlYWZDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjc3ROb2RlLnRva2VuVHlwZSA9IG5vZGUudG9rZW5UeXBlLm5hbWU7XG4gICAgICAgICAgICBjc3ROb2RlLm9mZnNldCA9IG5vZGUub2Zmc2V0O1xuICAgICAgICAgICAgY3N0Tm9kZS5sZW5ndGggPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIGNzdE5vZGUuc3RhcnRMaW5lID0gbm9kZS5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgY3N0Tm9kZS5zdGFydENvbHVtbiA9IG5vZGUucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgY3N0Tm9kZS5lbmRMaW5lID0gbm9kZS5yYW5nZS5lbmQubGluZTtcbiAgICAgICAgICAgIGNzdE5vZGUuZW5kQ29sdW1uID0gbm9kZS5yYW5nZS5lbmQuY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3ROb2RlO1xuICAgIH1cbiAgICBoeWRyYXRlKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBub2RlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jcmVhdGVIeWRyYXRpb25Db250ZXh0KG5vZGUpO1xuICAgICAgICBpZiAoJyRjc3ROb2RlJyBpbiBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGVDc3ROb2RlKG5vZGUuJGNzdE5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZXhlckVycm9yczogcmVzdWx0LmxleGVyRXJyb3JzLFxuICAgICAgICAgICAgbGV4ZXJSZXBvcnQ6IHJlc3VsdC5sZXhlclJlcG9ydCxcbiAgICAgICAgICAgIHBhcnNlckVycm9yczogcmVzdWx0LnBhcnNlckVycm9ycyxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmh5ZHJhdGVBc3ROb2RlKG5vZGUsIGNvbnRleHQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZUh5ZHJhdGlvbkNvbnRleHQobm9kZSkge1xuICAgICAgICBjb25zdCBhc3ROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY3N0Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgYXN0Tm9kZSBvZiBzdHJlYW1Bc3Qobm9kZSkpIHtcbiAgICAgICAgICAgIGFzdE5vZGVzLnNldChhc3ROb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvb3Q7XG4gICAgICAgIGlmIChub2RlLiRjc3ROb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNzdE5vZGUgb2Ygc3RyZWFtQ3N0KG5vZGUuJGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNzdDtcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bGxUZXh0JyBpbiBjc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdCA9IG5ldyBSb290Q3N0Tm9kZUltcGwoY3N0Tm9kZS5mdWxsVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBjc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdjb250ZW50JyBpbiBjc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdCA9IG5ldyBDb21wb3NpdGVDc3ROb2RlSW1wbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgndG9rZW5UeXBlJyBpbiBjc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdCA9IHRoaXMuaHlkcmF0ZUNzdExlYWZOb2RlKGNzdE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNzdE5vZGVzLnNldChjc3ROb2RlLCBjc3QpO1xuICAgICAgICAgICAgICAgICAgICBjc3Qucm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3ROb2RlcyxcbiAgICAgICAgICAgIGNzdE5vZGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGh5ZHJhdGVBc3ROb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYXN0Tm9kZSA9IGNvbnRleHQuYXN0Tm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBhc3ROb2RlLiR0eXBlID0gbm9kZS4kdHlwZTtcbiAgICAgICAgYXN0Tm9kZS4kY29udGFpbmVySW5kZXggPSBub2RlLiRjb250YWluZXJJbmRleDtcbiAgICAgICAgYXN0Tm9kZS4kY29udGFpbmVyUHJvcGVydHkgPSBub2RlLiRjb250YWluZXJQcm9wZXJ0eTtcbiAgICAgICAgaWYgKG5vZGUuJGNzdE5vZGUpIHtcbiAgICAgICAgICAgIGFzdE5vZGUuJGNzdE5vZGUgPSBjb250ZXh0LmNzdE5vZGVzLmdldChub2RlLiRjc3ROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IGFycjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5zZXRQYXJlbnQodGhpcy5oeWRyYXRlQXN0Tm9kZShpdGVtLCBjb250ZXh0KSwgYXN0Tm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmh5ZHJhdGVSZWZlcmVuY2UoaXRlbSwgYXN0Tm9kZSwgbmFtZSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IHRoaXMuc2V0UGFyZW50KHRoaXMuaHlkcmF0ZUFzdE5vZGUodmFsdWUsIGNvbnRleHQpLCBhc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGFzdE5vZGVbbmFtZV0gPSB0aGlzLmh5ZHJhdGVSZWZlcmVuY2UodmFsdWUsIGFzdE5vZGUsIG5hbWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFzdE5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0Tm9kZTtcbiAgICB9XG4gICAgc2V0UGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgICBub2RlLiRjb250YWluZXIgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBoeWRyYXRlUmVmZXJlbmNlKHJlZmVyZW5jZSwgbm9kZSwgbmFtZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rZXIuYnVpbGRSZWZlcmVuY2Uobm9kZSwgbmFtZSwgY29udGV4dC5jc3ROb2Rlcy5nZXQocmVmZXJlbmNlLiRyZWZOb2RlKSwgcmVmZXJlbmNlLiRyZWZUZXh0KTtcbiAgICB9XG4gICAgaHlkcmF0ZUNzdE5vZGUoY3N0Tm9kZSwgY29udGV4dCwgbnVtID0gMCkge1xuICAgICAgICBjb25zdCBjc3ROb2RlT2JqID0gY29udGV4dC5jc3ROb2Rlcy5nZXQoY3N0Tm9kZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY3N0Tm9kZS5ncmFtbWFyU291cmNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY3N0Tm9kZU9iai5ncmFtbWFyU291cmNlID0gdGhpcy5nZXRHcmFtbWFyRWxlbWVudChjc3ROb2RlLmdyYW1tYXJTb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNzdE5vZGVPYmouYXN0Tm9kZSA9IGNvbnRleHQuYXN0Tm9kZXMuZ2V0KGNzdE5vZGUuYXN0Tm9kZSk7XG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUoY3N0Tm9kZU9iaikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY3N0Tm9kZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWQgPSB0aGlzLmh5ZHJhdGVDc3ROb2RlKGNoaWxkLCBjb250ZXh0LCBudW0rKyk7XG4gICAgICAgICAgICAgICAgY3N0Tm9kZU9iai5jb250ZW50LnB1c2goaHlkcmF0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3ROb2RlT2JqO1xuICAgIH1cbiAgICBoeWRyYXRlQ3N0TGVhZk5vZGUoY3N0Tm9kZSkge1xuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB0aGlzLmdldFRva2VuVHlwZShjc3ROb2RlLnRva2VuVHlwZSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGNzdE5vZGUub2Zmc2V0O1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjc3ROb2RlLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gY3N0Tm9kZS5zdGFydExpbmU7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gY3N0Tm9kZS5zdGFydENvbHVtbjtcbiAgICAgICAgY29uc3QgZW5kTGluZSA9IGNzdE5vZGUuZW5kTGluZTtcbiAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gY3N0Tm9kZS5lbmRDb2x1bW47XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9IGNzdE5vZGUuaGlkZGVuO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IExlYWZDc3ROb2RlSW1wbChvZmZzZXQsIGxlbmd0aCwge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydExpbmUsXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyOiBzdGFydENvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmUsXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyOiBlbmRDb2x1bW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdG9rZW5UeXBlLCBoaWRkZW4pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0VG9rZW5UeXBlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV4ZXIuZGVmaW5pdGlvbltuYW1lXTtcbiAgICB9XG4gICAgZ2V0R3JhbW1hckVsZW1lbnRJZChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncmFtbWFyRWxlbWVudElkTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR3JhbW1hckVsZW1lbnRJZE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuZ2V0KG5vZGUpO1xuICAgIH1cbiAgICBnZXRHcmFtbWFyRWxlbWVudChpZCkge1xuICAgICAgICBpZiAodGhpcy5ncmFtbWFyRWxlbWVudElkTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR3JhbW1hckVsZW1lbnRJZE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuZ2V0S2V5KGlkKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGNyZWF0ZUdyYW1tYXJFbGVtZW50SWRNYXAoKSB7XG4gICAgICAgIGxldCBpZCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBzdHJlYW1Bc3QodGhpcy5ncmFtbWFyKSkge1xuICAgICAgICAgICAgaWYgKGlzQWJzdHJhY3RFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFtbWFyRWxlbWVudElkTWFwLnNldChlbGVtZW50LCBpZCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh5ZHJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/serializer/hydrator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/serializer/json-serializer.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/serializer/json-serializer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultJsonSerializer: () => (/* binding */ DefaultJsonSerializer),\n/* harmony export */   isAstNodeWithComment: () => (/* binding */ isAstNodeWithComment)\n/* harmony export */ });\n/* harmony import */ var vscode_uri__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode-uri */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\nfunction isAstNodeWithComment(node) {\n    return typeof node.$comment === 'string';\n}\nfunction isIntermediateReference(obj) {\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\n}\nclass DefaultJsonSerializer {\n    constructor(services) {\n        /** The set of AstNode properties to be ignored by the serializer. */\n        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options) {\n        const serializeOptions = options !== null && options !== void 0 ? options : {};\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);\n        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        }\n        finally {\n            this.currentDocument = undefined;\n        }\n    }\n    deserialize(content, options) {\n        const deserializeOptions = options !== null && options !== void 0 ? options : {};\n        const root = JSON.parse(content);\n        this.linkNode(root, root, deserializeOptions);\n        return root;\n    }\n    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        }\n        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(refValue);\n                let targetUri = '';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    }\n                    else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                };\n            }\n            else {\n                return {\n                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference',\n                    $refText\n                };\n            }\n        }\n        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(value)) {\n            let astNode = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    astNode.$comment = comment.replace(/\\r/g, '');\n                }\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        }\n        else {\n            return value;\n        }\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = cstNode => ({\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        });\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\n                const propertyAssignments = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.findNodesForProperty)(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n            return node;\n        }\n        return undefined;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    }\n                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(element)) {\n                        this.linkNode(element, root, options, node, propertyName, index);\n                    }\n                }\n            }\n            else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(item)) {\n                this.linkNode(item, root, options, node, propertyName);\n            }\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : '',\n                    ref\n                };\n            }\n            else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : ''\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        }\n        else {\n            return undefined;\n        }\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf('#');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return 'Could not resolve path: ' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : vscode_uri__WEBPACK_IMPORTED_MODULE_3__.URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return 'Could not find document for URI: ' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : vscode_uri__WEBPACK_IMPORTED_MODULE_3__.URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return 'Could not find document for URI: ' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return 'Could not resolve URI: ' + uri;\n            }\n            return node;\n        }\n        catch (err) {\n            return String(err);\n        }\n    }\n}\n//# sourceMappingURL=json-serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc2VyaWFsaXplci9qc29uLXNlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQztBQUMwQjtBQUNQO0FBQ2E7QUFDMUQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBMEQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdFQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSxHQUFHLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQVM7QUFDMUI7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkVBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDJDQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiwyQ0FBRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxzZXJpYWxpemVyXFxqc29uLXNlcmlhbGl6ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAndnNjb2RlLXVyaSc7XG5pbXBvcnQgeyBpc0FzdE5vZGUsIGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgZmluZE5vZGVzRm9yUHJvcGVydHkgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FzdE5vZGVXaXRoQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlLiRjb21tZW50ID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzSW50ZXJtZWRpYXRlUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhIW9iaiAmJiAoJyRyZWYnIGluIG9iaiB8fCAnJGVycm9yJyBpbiBvYmopO1xufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRKc29uU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgLyoqIFRoZSBzZXQgb2YgQXN0Tm9kZSBwcm9wZXJ0aWVzIHRvIGJlIGlnbm9yZWQgYnkgdGhlIHNlcmlhbGl6ZXIuICovXG4gICAgICAgIHRoaXMuaWdub3JlUHJvcGVydGllcyA9IG5ldyBTZXQoWyckY29udGFpbmVyJywgJyRjb250YWluZXJQcm9wZXJ0eScsICckY29udGFpbmVySW5kZXgnLCAnJGRvY3VtZW50JywgJyRjc3ROb2RlJ10pO1xuICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudHMgPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMuYXN0Tm9kZUxvY2F0b3IgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZUxvY2F0b3I7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29tbWVudFByb3ZpZGVyID0gc2VydmljZXMuZG9jdW1lbnRhdGlvbi5Db21tZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZU9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWNSZXBsYWNlciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBsYWNlcjtcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHRoaXMucmVwbGFjZXIoa2V5LCB2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VyID0gc3BlY2lmaWNSZXBsYWNlciA/IChrZXksIHZhbHVlKSA9PiBzcGVjaWZpY1JlcGxhY2VyKGtleSwgdmFsdWUsIGRlZmF1bHRSZXBsYWNlcikgOiBkZWZhdWx0UmVwbGFjZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREb2N1bWVudCA9IGdldERvY3VtZW50KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUsIHJlcGxhY2VyLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9jdW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzZXJpYWxpemUoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZU9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgIHRoaXMubGlua05vZGUocm9vdCwgcm9vdCwgZGVzZXJpYWxpemVPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJlcGxhY2VyKGtleSwgdmFsdWUsIHsgcmVmVGV4dCwgc291cmNlVGV4dCwgdGV4dFJlZ2lvbnMsIGNvbW1lbnRzLCB1cmlDb252ZXJ0ZXIgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZVByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZWZWYWx1ZSA9IHZhbHVlLnJlZjtcbiAgICAgICAgICAgIGNvbnN0ICRyZWZUZXh0ID0gcmVmVGV4dCA/IHZhbHVlLiRyZWZUZXh0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHJlZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudChyZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFVyaSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREb2N1bWVudCAmJiB0aGlzLmN1cnJlbnREb2N1bWVudCAhPT0gdGFyZ2V0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVyaUNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJpID0gdXJpQ29udmVydGVyKHRhcmdldERvY3VtZW50LnVyaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJpID0gdGFyZ2V0RG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRyZWY6IGAke3RhcmdldFVyaX0jJHt0YXJnZXRQYXRofWAsXG4gICAgICAgICAgICAgICAgICAgICRyZWZUZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRlcnJvcjogKF9iID0gKF9hID0gdmFsdWUuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgJHJlZlRleHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBhc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRleHRSZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZSA9IHRoaXMuYWRkQXN0Tm9kZVJlZ2lvbldpdGhBc3NpZ25tZW50c1RvKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCgha2V5IHx8IHZhbHVlLiRkb2N1bWVudCkgJiYgKGFzdE5vZGUgPT09IG51bGwgfHwgYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0Tm9kZS4kdGV4dFJlZ2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IFVSSSBpcyBhZGRlZCB0byB0aGUgcm9vdCBub2RlIG9mIHRoZSByZXN1bHRpbmcgSlNPTiB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGFzdE5vZGUuJHRleHRSZWdpb24uZG9jdW1lbnRVUkkgPSAoX2MgPSB0aGlzLmN1cnJlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VUZXh0ICYmICFrZXkpIHtcbiAgICAgICAgICAgICAgICBhc3ROb2RlICE9PSBudWxsICYmIGFzdE5vZGUgIT09IHZvaWQgMCA/IGFzdE5vZGUgOiAoYXN0Tm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZS4kc291cmNlVGV4dCA9IChfZCA9IHZhbHVlLiRjc3ROb2RlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tZW50cykge1xuICAgICAgICAgICAgICAgIGFzdE5vZGUgIT09IG51bGwgJiYgYXN0Tm9kZSAhPT0gdm9pZCAwID8gYXN0Tm9kZSA6IChhc3ROb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5jb21tZW50UHJvdmlkZXIuZ2V0Q29tbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0Tm9kZS4kY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFxyL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN0Tm9kZSAhPT0gbnVsbCAmJiBhc3ROb2RlICE9PSB2b2lkIDAgPyBhc3ROb2RlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQXN0Tm9kZVJlZ2lvbldpdGhBc3NpZ25tZW50c1RvKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlRG9jdW1lbnRTZWdtZW50ID0gY3N0Tm9kZSA9PiAoe1xuICAgICAgICAgICAgb2Zmc2V0OiBjc3ROb2RlLm9mZnNldCxcbiAgICAgICAgICAgIGVuZDogY3N0Tm9kZS5lbmQsXG4gICAgICAgICAgICBsZW5ndGg6IGNzdE5vZGUubGVuZ3RoLFxuICAgICAgICAgICAgcmFuZ2U6IGNzdE5vZGUucmFuZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dFJlZ2lvbiA9IG5vZGUuJHRleHRSZWdpb24gPSBjcmVhdGVEb2N1bWVudFNlZ21lbnQobm9kZS4kY3N0Tm9kZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50cyA9IHRleHRSZWdpb24uYXNzaWdubWVudHMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmZpbHRlcihrZXkgPT4gIWtleS5zdGFydHNXaXRoKCckJykpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUFzc2lnbm1lbnRzID0gZmluZE5vZGVzRm9yUHJvcGVydHkobm9kZS4kY3N0Tm9kZSwga2V5KS5tYXAoY3JlYXRlRG9jdW1lbnRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlBc3NpZ25tZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHNba2V5XSA9IHByb3BlcnR5QXNzaWdubWVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsaW5rTm9kZShub2RlLCByb290LCBvcHRpb25zLCBjb250YWluZXIsIGNvbnRhaW5lclByb3BlcnR5LCBjb250YWluZXJJbmRleCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eU5hbWUsIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpdGVtLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaXRlbVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludGVybWVkaWF0ZVJlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtpbmRleF0gPSB0aGlzLnJldml2ZVJlZmVyZW5jZShub2RlLCBwcm9wZXJ0eU5hbWUsIHJvb3QsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rTm9kZShlbGVtZW50LCByb290LCBvcHRpb25zLCBub2RlLCBwcm9wZXJ0eU5hbWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJtZWRpYXRlUmVmZXJlbmNlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdGhpcy5yZXZpdmVSZWZlcmVuY2Uobm9kZSwgcHJvcGVydHlOYW1lLCByb290LCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlua05vZGUoaXRlbSwgcm9vdCwgb3B0aW9ucywgbm9kZSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdXRhYmxlID0gbm9kZTtcbiAgICAgICAgbXV0YWJsZS4kY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBtdXRhYmxlLiRjb250YWluZXJQcm9wZXJ0eSA9IGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBtdXRhYmxlLiRjb250YWluZXJJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgIH1cbiAgICByZXZpdmVSZWZlcmVuY2UoY29udGFpbmVyLCBwcm9wZXJ0eSwgcm9vdCwgcmVmZXJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCByZWZUZXh0ID0gcmVmZXJlbmNlLiRyZWZUZXh0O1xuICAgICAgICBsZXQgZXJyb3IgPSByZWZlcmVuY2UuJGVycm9yO1xuICAgICAgICBpZiAocmVmZXJlbmNlLiRyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0UmVmTm9kZShyb290LCByZWZlcmVuY2UuJHJlZiwgb3B0aW9ucy51cmlDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShyZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZlRleHQgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRyZWZUZXh0OiByZWZUZXh0ICE9PSBudWxsICYmIHJlZlRleHQgIT09IHZvaWQgMCA/IHJlZlRleHQgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcmVmID0ge1xuICAgICAgICAgICAgICAgICRyZWZUZXh0OiByZWZUZXh0ICE9PSBudWxsICYmIHJlZlRleHQgIT09IHZvaWQgMCA/IHJlZlRleHQgOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlZi5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiByZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWZOb2RlKHJvb3QsIHVyaSwgdXJpQ29udmVydGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudEluZGV4ID0gdXJpLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZShyb290LCB1cmkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDb3VsZCBub3QgcmVzb2x2ZSBwYXRoOiAnICsgdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50VXJpID0gdXJpQ29udmVydGVyID8gdXJpQ29udmVydGVyKHVyaSkgOiBVUkkucGFyc2UodXJpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHRoaXMubGFuZ2l1bURvY3VtZW50cy5nZXREb2N1bWVudChkb2N1bWVudFVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0NvdWxkIG5vdCBmaW5kIGRvY3VtZW50IGZvciBVUkk6ICcgKyB1cmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50VXJpID0gdXJpQ29udmVydGVyID8gdXJpQ29udmVydGVyKHVyaS5zdWJzdHJpbmcoMCwgZnJhZ21lbnRJbmRleCkpIDogVVJJLnBhcnNlKHVyaS5zdWJzdHJpbmcoMCwgZnJhZ21lbnRJbmRleCkpO1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0RG9jdW1lbnQoZG9jdW1lbnRVcmkpO1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ291bGQgbm90IGZpbmQgZG9jdW1lbnQgZm9yIFVSSTogJyArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4ID09PSB1cmkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmFzdE5vZGVMb2NhdG9yLmdldEFzdE5vZGUoZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUsIHVyaS5zdWJzdHJpbmcoZnJhZ21lbnRJbmRleCArIDEpKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ291bGQgbm90IHJlc29sdmUgVVJJOiAnICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhlcnIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/serializer/json-serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/service-registry.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/service-registry.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultServiceRegistry: () => (/* binding */ DefaultServiceRegistry)\n/* harmony export */ });\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/uri-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/uri-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nclass DefaultServiceRegistry {\n    /**\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n     */\n    get map() {\n        return this.fileExtensionMap;\n    }\n    constructor(services) {\n        this.languageIdMap = new Map();\n        this.fileExtensionMap = new Map();\n        this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n    }\n    register(language) {\n        const data = language.LanguageMetaData;\n        for (const ext of data.fileExtensions) {\n            if (this.fileExtensionMap.has(ext)) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\n            }\n            this.fileExtensionMap.set(ext, language);\n        }\n        this.languageIdMap.set(data.languageId, language);\n        if (this.languageIdMap.size === 1) {\n            this.singleton = language;\n        }\n        else {\n            this.singleton = undefined;\n        }\n    }\n    getServices(uri) {\n        var _a, _b;\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.languageIdMap.size === 0) {\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n        }\n        const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;\n        if (languageId !== undefined) {\n            const services = this.languageIdMap.get(languageId);\n            if (services) {\n                return services;\n            }\n        }\n        const ext = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_0__.UriUtils.extname(uri);\n        const services = this.fileExtensionMap.get(ext);\n        if (!services) {\n            if (languageId) {\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n            }\n            else {\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n            }\n        }\n        return services;\n    }\n    hasServices(uri) {\n        try {\n            this.getServices(uri);\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    get all() {\n        return Array.from(this.languageIdMap.values());\n    }\n}\n//# sourceMappingURL=service-registry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc2VydmljZS1yZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyx3REFBd0QsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLElBQUksa0JBQWtCLFdBQVc7QUFDakk7QUFDQTtBQUNBLGdHQUFnRyxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFxzZXJ2aWNlLXJlZ2lzdHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi91dGlscy91cmktdXRpbHMuanMnO1xuLyoqXG4gKiBHZW5lcmljIHJlZ2lzdHJ5IGZvciBMYW5naXVtIHNlcnZpY2VzLCBidXQgY2FwYWJsZSBvZiBiZWluZyB1c2VkIHdpdGggZXh0ZW5kaW5nIHNlcnZpY2Ugc2V0cyBhcyB3ZWxsIChzdWNoIGFzIHRoZSBsc3AtY29tcGxldGUgTGFuZ2l1bUNvcmVTZXJ2aWNlcyBzZXQpXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U2VydmljZVJlZ2lzdHJ5IHtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIG5ldyBgZmlsZUV4dGVuc2lvbk1hcGAgKG9yIGBsYW5ndWFnZUlkTWFwYCkgcHJvcGVydHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXQgbWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlRXh0ZW5zaW9uTWFwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmxhbmd1YWdlSWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmlsZUV4dGVuc2lvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50ZXh0RG9jdW1lbnRzID0gc2VydmljZXMgPT09IG51bGwgfHwgc2VydmljZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VzLndvcmtzcGFjZS5UZXh0RG9jdW1lbnRzO1xuICAgIH1cbiAgICByZWdpc3RlcihsYW5ndWFnZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gbGFuZ3VhZ2UuTGFuZ3VhZ2VNZXRhRGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgZGF0YS5maWxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZUV4dGVuc2lvbk1hcC5oYXMoZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIGZpbGUgZXh0ZW5zaW9uICR7ZXh0fSBpcyB1c2VkIGJ5IG11bHRpcGxlIGxhbmd1YWdlcy4gSXQgaXMgbm93IGFzc2lnbmVkIHRvICcke2RhdGEubGFuZ3VhZ2VJZH0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxlRXh0ZW5zaW9uTWFwLnNldChleHQsIGxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhbmd1YWdlSWRNYXAuc2V0KGRhdGEubGFuZ3VhZ2VJZCwgbGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZUlkTWFwLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gbGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNpbmdsZXRvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTZXJ2aWNlcyh1cmkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xldG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZUlkTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZpY2UgcmVnaXN0cnkgaXMgZW1wdHkuIFVzZSBgcmVnaXN0ZXJgIHRvIHJlZ2lzdGVyIHRoZSBzZXJ2aWNlcyBvZiBhIGxhbmd1YWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSAoX2IgPSAoX2EgPSB0aGlzLnRleHREb2N1bWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQodXJpKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhbmd1YWdlSWQ7XG4gICAgICAgIGlmIChsYW5ndWFnZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5sYW5ndWFnZUlkTWFwLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSBVcmlVdGlscy5leHRuYW1lKHVyaSk7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5maWxlRXh0ZW5zaW9uTWFwLmdldChleHQpO1xuICAgICAgICBpZiAoIXNlcnZpY2VzKSB7XG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgcmVnaXN0cnkgY29udGFpbnMgbm8gc2VydmljZXMgZm9yIHRoZSBleHRlbnNpb24gJyR7ZXh0fScgZm9yIGxhbmd1YWdlICcke2xhbmd1YWdlSWR9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgcmVnaXN0cnkgY29udGFpbnMgbm8gc2VydmljZXMgZm9yIHRoZSBleHRlbnNpb24gJyR7ZXh0fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgIH1cbiAgICBoYXNTZXJ2aWNlcyh1cmkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VydmljZXModXJpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhbGwoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGFuZ3VhZ2VJZE1hcC52YWx1ZXMoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1yZWdpc3RyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/service-registry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/syntax-tree.js":
/*!*************************************************!*\
  !*** ./node_modules/langium/lib/syntax-tree.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractAstReflection: () => (/* binding */ AbstractAstReflection),\n/* harmony export */   isAstNode: () => (/* binding */ isAstNode),\n/* harmony export */   isAstNodeDescription: () => (/* binding */ isAstNodeDescription),\n/* harmony export */   isCompositeCstNode: () => (/* binding */ isCompositeCstNode),\n/* harmony export */   isLeafCstNode: () => (/* binding */ isLeafCstNode),\n/* harmony export */   isLinkingError: () => (/* binding */ isLinkingError),\n/* harmony export */   isReference: () => (/* binding */ isReference),\n/* harmony export */   isRootCstNode: () => (/* binding */ isRootCstNode)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nfunction isAstNode(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';\n}\nfunction isReference(obj) {\n    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';\n}\nfunction isAstNodeDescription(obj) {\n    return typeof obj === 'object' && obj !== null\n        && typeof obj.name === 'string'\n        && typeof obj.type === 'string'\n        && typeof obj.path === 'string';\n}\nfunction isLinkingError(obj) {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode(obj.container)\n        && isReference(obj.reference)\n        && typeof obj.message === 'string';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nclass AbstractAstReflection {\n    constructor() {\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        }\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\nfunction isCompositeCstNode(node) {\n    return typeof node === 'object' && node !== null && Array.isArray(node.content);\n}\nfunction isLeafCstNode(node) {\n    return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';\n}\nfunction isRootCstNode(node) {\n    return isCompositeCstNode(node) && typeof node.fullText === 'string';\n}\n//# sourceMappingURL=syntax-tree.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc3ludGF4LXRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcc3ludGF4LXRyZWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN0Tm9kZShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmouJHR5cGUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iai4kcmVmVGV4dCA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc3ROb2RlRGVzY3JpcHRpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbFxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgdHlwZW9mIG9iai5wYXRoID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0xpbmtpbmdFcnJvcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsXG4gICAgICAgICYmIGlzQXN0Tm9kZShvYmouY29udGFpbmVyKVxuICAgICAgICAmJiBpc1JlZmVyZW5jZShvYmoucmVmZXJlbmNlKVxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEFzdFJlZmxlY3Rpb259IGludGVyZmFjZS5cbiAqIFNlcnZlcyB0byBjYWNoZSBzdWJ0eXBlIGNvbXB1dGF0aW9uIHJlc3VsdHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSB0aHJvdWdob3V0IGRpZmZlcmVudCBwYXJ0cyBvZiBMYW5naXVtLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJ0eXBlcyA9IHt9O1xuICAgICAgICB0aGlzLmFsbFN1YnR5cGVzID0ge307XG4gICAgfVxuICAgIGlzSW5zdGFuY2Uobm9kZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gaXNBc3ROb2RlKG5vZGUpICYmIHRoaXMuaXNTdWJ0eXBlKG5vZGUuJHR5cGUsIHR5cGUpO1xuICAgIH1cbiAgICBpc1N1YnR5cGUoc3VidHlwZSwgc3VwZXJ0eXBlKSB7XG4gICAgICAgIGlmIChzdWJ0eXBlID09PSBzdXBlcnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXN0ZWQgPSB0aGlzLnN1YnR5cGVzW3N1YnR5cGVdO1xuICAgICAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgICAgICAgbmVzdGVkID0gdGhpcy5zdWJ0eXBlc1tzdWJ0eXBlXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbmVzdGVkW3N1cGVydHlwZV07XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbXB1dGVJc1N1YnR5cGUoc3VidHlwZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIG5lc3RlZFtzdXBlcnR5cGVdID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBbGxTdWJUeXBlcyh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5hbGxTdWJ0eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbGxUeXBlcyA9IHRoaXMuZ2V0QWxsVHlwZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvc3NpYmxlU3ViVHlwZSBvZiBhbGxUeXBlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3VidHlwZShwb3NzaWJsZVN1YlR5cGUsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2gocG9zc2libGVTdWJUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsbFN1YnR5cGVzW3R5cGVdID0gdHlwZXM7XG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShub2RlLmNvbnRlbnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhZkNzdE5vZGUobm9kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCAmJiB0eXBlb2Ygbm9kZS50b2tlblR5cGUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUm9vdENzdE5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc0NvbXBvc2l0ZUNzdE5vZGUobm9kZSkgJiYgdHlwZW9mIG5vZGUuZnVsbFRleHQgPT09ICdzdHJpbmcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ludGF4LXRyZWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/syntax-tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/ast-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/ast-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignMandatoryProperties: () => (/* binding */ assignMandatoryProperties),\n/* harmony export */   copyAstNode: () => (/* binding */ copyAstNode),\n/* harmony export */   findLocalReferences: () => (/* binding */ findLocalReferences),\n/* harmony export */   findRootNode: () => (/* binding */ findRootNode),\n/* harmony export */   getContainerOfType: () => (/* binding */ getContainerOfType),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   hasContainerOfType: () => (/* binding */ hasContainerOfType),\n/* harmony export */   linkContentToContainer: () => (/* binding */ linkContentToContainer),\n/* harmony export */   streamAllContents: () => (/* binding */ streamAllContents),\n/* harmony export */   streamAst: () => (/* binding */ streamAst),\n/* harmony export */   streamContents: () => (/* binding */ streamContents),\n/* harmony export */   streamReferences: () => (/* binding */ streamReferences)\n/* harmony export */ });\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nfunction linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(item)) {\n                        item.$container = node;\n                        item.$containerProperty = name;\n                        item.$containerIndex = index;\n                    }\n                });\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {\n                value.$container = node;\n                value.$containerProperty = name;\n            }\n        }\n    }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nfunction getContainerOfType(node, typePredicate) {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nfunction hasContainerOfType(node, predicate) {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nfunction getDocument(node) {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nfunction findRootNode(node) {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nfunction streamContents(node, options) {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return _stream_js__WEBPACK_IMPORTED_MODULE_1__.DONE_RESULT;\n    });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nfunction streamAllContents(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nfunction streamAst(root, options) {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, () => []);\n    }\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) {\n        return true;\n    }\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return (0,_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.inRange)(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nfunction streamReferences(node) {\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = node[property];\n                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return _stream_js__WEBPACK_IMPORTED_MODULE_1__.DONE_RESULT;\n    });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nfunction findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.stream)(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nfunction assignMandatoryProperties(reflection, node) {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\nfunction copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    }\n    else {\n        return propertyType;\n    }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nfunction copyAstNode(node, buildReference) {\n    const copy = { $type: node.$type };\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            }\n            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(value)) {\n                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n            }\n            else if (Array.isArray(value)) {\n                const copiedArray = [];\n                for (const element of value) {\n                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    }\n                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(element)) {\n                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                    }\n                    else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            }\n            else {\n                copy[name] = value;\n            }\n        }\n    }\n    linkContentToContainer(copy);\n    return copy;\n}\n//# sourceMappingURL=ast-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvYXN0LXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDbUI7QUFDckM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUJBQXFCLDBEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQVM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVztBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFjO0FBQ2pDO0FBQ0EsZUFBZSxzREFBYyxnREFBZ0QsbUJBQW1CO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0REFBVztBQUMvQjtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBVztBQUN2QyxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBVztBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsV0FBVyxrREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVM7QUFDekI7QUFDQTtBQUNBLHFCQUFxQiw0REFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkIsNERBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx1dGlsc1xcYXN0LXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGlzQXN0Tm9kZSwgaXNSZWZlcmVuY2UgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBET05FX1JFU1VMVCwgc3RyZWFtLCBTdHJlYW1JbXBsLCBUcmVlU3RyZWFtSW1wbCB9IGZyb20gJy4vc3RyZWFtLmpzJztcbmltcG9ydCB7IGluUmFuZ2UgfSBmcm9tICcuL2NzdC11dGlscy5qcyc7XG4vKipcbiAqIExpbmsgdGhlIGAkY29udGFpbmVyYCBhbmQgb3RoZXIgcmVsYXRlZCBwcm9wZXJ0aWVzIG9mIGV2ZXJ5IEFTVCBub2RlIHRoYXQgaXMgZGlyZWN0bHkgY29udGFpbmVkXG4gKiBpbiB0aGUgZ2l2ZW4gYG5vZGVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlua0NvbnRlbnRUb0NvbnRhaW5lcihub2RlKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uJGNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLiRjb250YWluZXJQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLiRjb250YWluZXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuJGNvbnRhaW5lciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgdmFsdWUuJGNvbnRhaW5lclByb3BlcnR5ID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogV2FsayBhbG9uZyB0aGUgaGllcmFyY2h5IG9mIGNvbnRhaW5lcnMgZnJvbSB0aGUgZ2l2ZW4gQVNUIG5vZGUgdG8gdGhlIHJvb3QgYW5kIHJldHVybiB0aGUgZmlyc3RcbiAqIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSB0eXBlIHByZWRpY2F0ZS4gSWYgdGhlIHN0YXJ0IG5vZGUgaXRzZWxmIG1hdGNoZXMsIGl0IGlzIHJldHVybmVkLlxuICogSWYgbm8gY29udGFpbmVyIG1hdGNoZXMsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGFpbmVyT2ZUeXBlKG5vZGUsIHR5cGVQcmVkaWNhdGUpIHtcbiAgICBsZXQgaXRlbSA9IG5vZGU7XG4gICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVQcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBpdGVtLiRjb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFdhbGsgYWxvbmcgdGhlIGhpZXJhcmNoeSBvZiBjb250YWluZXJzIGZyb20gdGhlIGdpdmVuIEFTVCBub2RlIHRvIHRoZSByb290IGFuZCBjaGVjayBmb3IgZXhpc3RlbmNlXG4gKiBvZiBhIGNvbnRhaW5lciB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIHByZWRpY2F0ZS4gVGhlIHN0YXJ0IG5vZGUgaXMgaW5jbHVkZWQgaW4gdGhlIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRhaW5lck9mVHlwZShub2RlLCBwcmVkaWNhdGUpIHtcbiAgICBsZXQgaXRlbSA9IG5vZGU7XG4gICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbSA9IGl0ZW0uJGNvbnRhaW5lcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgZG9jdW1lbnQgaW4gd2hpY2ggdGhlIGdpdmVuIEFTVCBub2RlIGlzIGNvbnRhaW5lZC4gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IGlzXG4gKiB1c3VhbGx5IGhlbGQgYnkgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgQVNULlxuICpcbiAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIG5vZGUgaXMgbm90IGNvbnRhaW5lZCBpbiBhIGRvY3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgIGNvbnN0IHJvb3ROb2RlID0gZmluZFJvb3ROb2RlKG5vZGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJvb3ROb2RlLiRkb2N1bWVudDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTVCBub2RlIGhhcyBubyBkb2N1bWVudC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoZSBnaXZlbiBBU1Qgbm9kZSBieSBmb2xsb3dpbmcgdGhlIGAkY29udGFpbmVyYCByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFJvb3ROb2RlKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS4kY29udGFpbmVyKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLiRjb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJlYW0gb2YgYWxsIEFTVCBub2RlcyB0aGF0IGFyZSBkaXJlY3RseSBjb250YWluZWQgaW4gdGhlIGdpdmVuIG5vZGUuIFRoaXMgaW5jbHVkZXNcbiAqIHNpbmdsZS12YWx1ZWQgYXMgd2VsbCBhcyBtdWx0aS12YWx1ZWQgKGFycmF5KSBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQ29udGVudHMobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbXVzdCBiZSBhbiBBc3ROb2RlLicpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYW5nZTtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHtcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMobm9kZSksXG4gICAgICAgIGtleUluZGV4OiAwLFxuICAgICAgICBhcnJheUluZGV4OiAwXG4gICAgfSksIHN0YXRlID0+IHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmtleUluZGV4IDwgc3RhdGUua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gc3RhdGUua2V5c1tzdGF0ZS5rZXlJbmRleF07XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5LnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUua2V5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZUluUmFuZ2UodmFsdWUsIHJhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmFycmF5SW5kZXggPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdGUuYXJyYXlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUoZWxlbWVudCkgJiYgaXNBc3ROb2RlSW5SYW5nZShlbGVtZW50LCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGVsZW1lbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJheUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5rZXlJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBBU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUuXG4gKiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1BbGxDb250ZW50cyhyb290LCBvcHRpb25zKSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBub2RlIG11c3QgYmUgYW4gQXN0Tm9kZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlU3RyZWFtSW1wbChyb290LCBub2RlID0+IHN0cmVhbUNvbnRlbnRzKG5vZGUsIG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBBU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUsXG4gKiBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1Bc3Qocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3Qgbm9kZSBtdXN0IGJlIGFuIEFzdE5vZGUuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFuZ2UpICYmICFpc0FzdE5vZGVJblJhbmdlKHJvb3QsIG9wdGlvbnMucmFuZ2UpKSB7XG4gICAgICAgIC8vIFJldHVybiBhbiBlbXB0eSBzdHJlYW0gaWYgdGhlIHJvb3Qgbm9kZSBpc24ndCBpbiByYW5nZVxuICAgICAgICByZXR1cm4gbmV3IFRyZWVTdHJlYW1JbXBsKHJvb3QsICgpID0+IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmVlU3RyZWFtSW1wbChyb290LCBub2RlID0+IHN0cmVhbUNvbnRlbnRzKG5vZGUsIG9wdGlvbnMpLCB7IGluY2x1ZGVSb290OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gaXNBc3ROb2RlSW5SYW5nZShhc3ROb2RlLCByYW5nZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlUmFuZ2UgPSAoX2EgPSBhc3ROb2RlLiRjc3ROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFuZ2U7XG4gICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5SYW5nZShub2RlUmFuZ2UsIHJhbmdlKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBjcm9zcy1yZWZlcmVuY2VzIHRoYXQgYXJlIGhlbGQgYnkgdGhlIGdpdmVuIEFTVCBub2RlLiBUaGlzIGluY2x1ZGVzXG4gKiBzaW5nbGUtdmFsdWVkIGFzIHdlbGwgYXMgbXVsdGktdmFsdWVkIChhcnJheSkgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbVJlZmVyZW5jZXMobm9kZSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgoKSA9PiAoe1xuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyhub2RlKSxcbiAgICAgICAga2V5SW5kZXg6IDAsXG4gICAgICAgIGFycmF5SW5kZXg6IDBcbiAgICB9KSwgc3RhdGUgPT4ge1xuICAgICAgICB3aGlsZSAoc3RhdGUua2V5SW5kZXggPCBzdGF0ZS5rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzdGF0ZS5rZXlzW3N0YXRlLmtleUluZGV4XTtcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogeyByZWZlcmVuY2U6IHZhbHVlLCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5IH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLmFycmF5SW5kZXggPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdGUuYXJyYXlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogeyByZWZlcmVuY2U6IGVsZW1lbnQsIGNvbnRhaW5lcjogbm9kZSwgcHJvcGVydHksIGluZGV4IH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJheUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5rZXlJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIFN0cmVhbSBvZiByZWZlcmVuY2VzIHRvIHRoZSB0YXJnZXQgbm9kZSBmcm9tIHRoZSBBc3ROb2RlIHRyZWVcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSBBc3ROb2RlIHdlIGFyZSBsb29raW5nIGZvclxuICogQHBhcmFtIGxvb2t1cCBBc3ROb2RlIHdoZXJlIHdlIHNlYXJjaCBmb3IgcmVmZXJlbmNlcy4gSWYgbm90IHByb3ZpZGVkLCB0aGUgcm9vdCBub2RlIG9mIHRoZSBkb2N1bWVudCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTG9jYWxSZWZlcmVuY2VzKHRhcmdldE5vZGUsIGxvb2t1cCA9IGdldERvY3VtZW50KHRhcmdldE5vZGUpLnBhcnNlUmVzdWx0LnZhbHVlKSB7XG4gICAgY29uc3QgcmVmcyA9IFtdO1xuICAgIHN0cmVhbUFzdChsb29rdXApLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIHN0cmVhbVJlZmVyZW5jZXMobm9kZSkuZm9yRWFjaChyZWZJbmZvID0+IHtcbiAgICAgICAgICAgIGlmIChyZWZJbmZvLnJlZmVyZW5jZS5yZWYgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2gocmVmSW5mby5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyZWFtKHJlZnMpO1xufVxuLyoqXG4gKiBBc3NpZ25zIGFsbCBtYW5kYXRvcnkgQVNUIHByb3BlcnRpZXMgdG8gdGhlIHNwZWNpZmllZCBub2RlLlxuICpcbiAqIEBwYXJhbSByZWZsZWN0aW9uIFJlZmxlY3Rpb24gb2JqZWN0IHVzZWQgdG8gZ2F0aGVyIG1hbmRhdG9yeSBwcm9wZXJ0aWVzIGZvciB0aGUgbm9kZS5cbiAqIEBwYXJhbSBub2RlIFNwZWNpZmllZCBub2RlIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCBwcm9wZXJ0aWVzIGFyZSBkaXJlY3RseSBhc3NpZ25lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk1hbmRhdG9yeVByb3BlcnRpZXMocmVmbGVjdGlvbiwgbm9kZSkge1xuICAgIGNvbnN0IHR5cGVNZXRhRGF0YSA9IHJlZmxlY3Rpb24uZ2V0VHlwZU1ldGFEYXRhKG5vZGUuJHR5cGUpO1xuICAgIGNvbnN0IGdlbmVyaWNOb2RlID0gbm9kZTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHR5cGVNZXRhRGF0YS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIE9ubHkgc2V0IHRoZSB2YWx1ZSBpZiB0aGUgcHJvcGVydHkgaXMgbm90IGFscmVhZHkgc2V0IGFuZCBpZiBpdCBoYXMgYSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChwcm9wZXJ0eS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBnZW5lcmljTm9kZVtwcm9wZXJ0eS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnZW5lcmljTm9kZVtwcm9wZXJ0eS5uYW1lXSA9IGNvcHlEZWZhdWx0VmFsdWUocHJvcGVydHkuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvcHlEZWZhdWx0VmFsdWUocHJvcGVydHlUeXBlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlUeXBlKSkge1xuICAgICAgICByZXR1cm4gWy4uLnByb3BlcnR5VHlwZS5tYXAoY29weURlZmF1bHRWYWx1ZSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5VHlwZTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHNwZWNpZmllZCBBU1Qgbm9kZS5cbiAqIFRoZSByZXN1bHRpbmcgY29weSB3aWxsIG9ubHkgY29udGFpbiBzZW1hbnRpY2FsbHkgcmVsZXZhbnQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGAkdHlwZWAgcHJvcGVydHkgYW5kIEFTVCBwcm9wZXJ0aWVzLlxuICpcbiAqIFJlZmVyZW5jZXMgYXJlIGNvcGllZCB3aXRob3V0IHJlc29sdmVkIGNyb3NzIHJlZmVyZW5jZS4gVGhlIHNwZWNpZmllZCBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlYnVpbGQgdGhlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlBc3ROb2RlKG5vZGUsIGJ1aWxkUmVmZXJlbmNlKSB7XG4gICAgY29uc3QgY29weSA9IHsgJHR5cGU6IG5vZGUuJHR5cGUgfTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgaWYgKCFuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb3B5W25hbWVdID0gY29weUFzdE5vZGUodmFsdWUsIGJ1aWxkUmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvcHlbbmFtZV0gPSBidWlsZFJlZmVyZW5jZShjb3B5LCBuYW1lLCB2YWx1ZS4kcmVmTm9kZSwgdmFsdWUuJHJlZlRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWRBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWRBcnJheS5wdXNoKGNvcHlBc3ROb2RlKGVsZW1lbnQsIGJ1aWxkUmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZEFycmF5LnB1c2goYnVpbGRSZWZlcmVuY2UoY29weSwgbmFtZSwgZWxlbWVudC4kcmVmTm9kZSwgZWxlbWVudC4kcmVmVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkQXJyYXkucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5W25hbWVdID0gY29waWVkQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlua0NvbnRlbnRUb0NvbnRhaW5lcihjb3B5KTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/ast-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/caching.js":
/*!***************************************************!*\
  !*** ./node_modules/langium/lib/utils/caching.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextCache: () => (/* binding */ ContextCache),\n/* harmony export */   DisposableCache: () => (/* binding */ DisposableCache),\n/* harmony export */   DocumentCache: () => (/* binding */ DocumentCache),\n/* harmony export */   SimpleCache: () => (/* binding */ SimpleCache),\n/* harmony export */   WorkspaceCache: () => (/* binding */ WorkspaceCache)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass DisposableCache {\n    constructor() {\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error('This cache has already been disposed');\n        }\n    }\n}\nclass SimpleCache extends DisposableCache {\n    constructor() {\n        super(...arguments);\n        this.cache = new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\nclass ContextCache extends DisposableCache {\n    constructor(converter) {\n        super();\n        this.cache = new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        }\n        else {\n            this.cache.clear();\n        }\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nclass DocumentCache extends ContextCache {\n    /**\n     * Creates a new document cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     *\n     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,\n     * which triggers on all documents that have been affected by this change, assuming that the\n     * state is `DocumentState.Linked` or a later state.\n     */\n    constructor(sharedServices, state) {\n        super(uri => uri.toString());\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {\n                this.clear(document.uri.toString());\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                for (const uri of deleted) { // react only on deleted documents\n                    this.clear(uri);\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n                const allUris = changed.concat(deleted); // react on both changed and deleted documents\n                for (const uri of allUris) {\n                    this.clear(uri);\n                }\n            }));\n        }\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace is added, changed or deleted, the whole cache is evicted.\n */\nclass WorkspaceCache extends SimpleCache {\n    /**\n     * Creates a new workspace cache.\n     *\n     * @param sharedServices Service container instance to hook into document lifecycle events.\n     * @param state Optional document state on which the cache should evict.\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n     * *Deleted* documents are considered in both cases.\n     */\n    constructor(sharedServices, state) {\n        super();\n        if (state) {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\n                this.clear();\n            }));\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n                if (deleted.length > 0) { // react only on deleted documents\n                    this.clear();\n                }\n            }));\n        }\n        else {\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n                this.clear();\n            }));\n        }\n    }\n}\n//# sourceMappingURL=caching.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY2FjaGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx1dGlsc1xcY2FjaGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b0Rpc3Bvc2UgPSBbXTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIG9uRGlzcG9zZShkaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b0Rpc3Bvc2UuZm9yRWFjaChkaXNwb3NhYmxlID0+IGRpc3Bvc2FibGUuZGlzcG9zZSgpKTtcbiAgICB9XG4gICAgdGhyb3dJZkRpc3Bvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY2FjaGUgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNpbXBsZUNhY2hlIGV4dGVuZHMgRGlzcG9zYWJsZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldChrZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcigpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRleHRDYWNoZSBleHRlbmRzIERpc3Bvc2FibGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoY29udmVydGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29udmVydGVyID0gY29udmVydGVyICE9PSBudWxsICYmIGNvbnZlcnRlciAhPT0gdm9pZCAwID8gY29udmVydGVyIDogKHZhbHVlID0+IHZhbHVlKTtcbiAgICB9XG4gICAgaGFzKGNvbnRleHRLZXksIGtleSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUZvckNvbnRleHQoY29udGV4dEtleSkuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChjb250ZXh0S2V5LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0KGNvbnRleHRLZXksIGtleSwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgY29uc3QgY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUZvckNvbnRleHQoY29udGV4dEtleSk7XG4gICAgICAgIGlmIChjb250ZXh0Q2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0Q2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGNvbnRleHRDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShjb250ZXh0S2V5LCBrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjbGVhcihjb250ZXh0S2V5KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChjb250ZXh0S2V5KSB7XG4gICAgICAgICAgICBjb25zdCBtYXBLZXkgPSB0aGlzLmNvbnZlcnRlcihjb250ZXh0S2V5KTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKG1hcEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpIHtcbiAgICAgICAgY29uc3QgbWFwS2V5ID0gdGhpcy5jb252ZXJ0ZXIoY29udGV4dEtleSk7XG4gICAgICAgIGxldCBkb2N1bWVudENhY2hlID0gdGhpcy5jYWNoZS5nZXQobWFwS2V5KTtcbiAgICAgICAgaWYgKCFkb2N1bWVudENhY2hlKSB7XG4gICAgICAgICAgICBkb2N1bWVudENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQobWFwS2V5LCBkb2N1bWVudENhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnRDYWNoZTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZXJ5IGtleS92YWx1ZSBwYWlyIGluIHRoaXMgY2FjaGUgaXMgc2NvcGVkIHRvIGEgZG9jdW1lbnQuXG4gKiBJZiB0aGlzIGRvY3VtZW50IGlzIGNoYW5nZWQgb3IgZGVsZXRlZCwgYWxsIGFzc29jaWF0ZWQga2V5L3ZhbHVlIHBhaXJzIGFyZSBkZWxldGVkLlxuICovXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRDYWNoZSBleHRlbmRzIENvbnRleHRDYWNoZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaGFyZWRTZXJ2aWNlcyBTZXJ2aWNlIGNvbnRhaW5lciBpbnN0YW5jZSB0byBob29rIGludG8gZG9jdW1lbnQgbGlmZWN5Y2xlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gc3RhdGUgT3B0aW9uYWwgZG9jdW1lbnQgc3RhdGUgb24gd2hpY2ggdGhlIGNhY2hlIHNob3VsZCBldmljdC5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjYWNoZSB3aWxsIGV2aWN0IG9uIGBEb2N1bWVudEJ1aWxkZXIjb25VcGRhdGVgLlxuICAgICAqICpEZWxldGVkKiBkb2N1bWVudHMgYXJlIGNvbnNpZGVyZWQgaW4gYm90aCBjYXNlcy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGluZyBhIHN0YXRlIGhlcmUgd2lsbCB1c2UgYERvY3VtZW50QnVpbGRlciNvbkRvY3VtZW50UGhhc2VgIGluc3RlYWQsXG4gICAgICogd2hpY2ggdHJpZ2dlcnMgb24gYWxsIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiBhZmZlY3RlZCBieSB0aGlzIGNoYW5nZSwgYXNzdW1pbmcgdGhhdCB0aGVcbiAgICAgKiBzdGF0ZSBpcyBgRG9jdW1lbnRTdGF0ZS5MaW5rZWRgIG9yIGEgbGF0ZXIgc3RhdGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2hhcmVkU2VydmljZXMsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKHVyaSA9PiB1cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uRG9jdW1lbnRQaGFzZShzdGF0ZSwgZG9jdW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uVXBkYXRlKChfY2hhbmdlZCwgZGVsZXRlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdXJpIG9mIGRlbGV0ZWQpIHsgLy8gcmVhY3Qgb25seSBvbiBkZWxldGVkIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHVyaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uVXBkYXRlKChjaGFuZ2VkLCBkZWxldGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsVXJpcyA9IGNoYW5nZWQuY29uY2F0KGRlbGV0ZWQpOyAvLyByZWFjdCBvbiBib3RoIGNoYW5nZWQgYW5kIGRlbGV0ZWQgZG9jdW1lbnRzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB1cmkgb2YgYWxsVXJpcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHVyaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBFdmVyeSBrZXkvdmFsdWUgcGFpciBpbiB0aGlzIGNhY2hlIGlzIHNjb3BlZCB0byB0aGUgd2hvbGUgd29ya3NwYWNlLlxuICogSWYgYW55IGRvY3VtZW50IGluIHRoZSB3b3Jrc3BhY2UgaXMgYWRkZWQsIGNoYW5nZWQgb3IgZGVsZXRlZCwgdGhlIHdob2xlIGNhY2hlIGlzIGV2aWN0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc3BhY2VDYWNoZSBleHRlbmRzIFNpbXBsZUNhY2hlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdvcmtzcGFjZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaGFyZWRTZXJ2aWNlcyBTZXJ2aWNlIGNvbnRhaW5lciBpbnN0YW5jZSB0byBob29rIGludG8gZG9jdW1lbnQgbGlmZWN5Y2xlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gc3RhdGUgT3B0aW9uYWwgZG9jdW1lbnQgc3RhdGUgb24gd2hpY2ggdGhlIGNhY2hlIHNob3VsZCBldmljdC5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBjYWNoZSB3aWxsIGV2aWN0IG9uIGBEb2N1bWVudEJ1aWxkZXIjb25VcGRhdGVgLlxuICAgICAqICpEZWxldGVkKiBkb2N1bWVudHMgYXJlIGNvbnNpZGVyZWQgaW4gYm90aCBjYXNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzaGFyZWRTZXJ2aWNlcywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRvRGlzcG9zZS5wdXNoKHNoYXJlZFNlcnZpY2VzLndvcmtzcGFjZS5Eb2N1bWVudEJ1aWxkZXIub25CdWlsZFBoYXNlKHN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uVXBkYXRlKChfY2hhbmdlZCwgZGVsZXRlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVkLmxlbmd0aCA+IDApIHsgLy8gcmVhY3Qgb25seSBvbiBkZWxldGVkIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/caching.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/collections.js":
/*!*******************************************************!*\
  !*** ./node_modules/langium/lib/utils/collections.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BiMap: () => (/* binding */ BiMap),\n/* harmony export */   MultiMap: () => (/* binding */ MultiMap)\n/* harmony export */ });\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nclass MultiMap {\n    constructor(elements) {\n        this.map = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n    /**\n     * The total number of values in the multimap.\n     */\n    get size() {\n        return _stream_js__WEBPACK_IMPORTED_MODULE_0__.Reduction.sum((0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.values()).map(a => a.length));\n    }\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear() {\n        this.map.clear();\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key, value) {\n        if (value === undefined) {\n            return this.map.delete(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    }\n                    else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key, value) {\n        if (value === undefined) {\n            return this.map.has(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key, value) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(value);\n        }\n        else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key, values) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(...values);\n        }\n        else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn) {\n        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));\n    }\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries() {\n        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value]));\n    }\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys() {\n        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.keys());\n    }\n    /**\n     * Returns a stream of values in the map.\n     */\n    values() {\n        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.values()).flat();\n    }\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey() {\n        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.entries());\n    }\n}\nclass BiMap {\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements) {\n        this.map = new Map();\n        this.inverse = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=collections.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY29sbGVjdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVMsS0FBSyxrREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFNO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXGNvbGxlY3Rpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFJlZHVjdGlvbiwgc3RyZWFtIH0gZnJvbSAnLi9zdHJlYW0uanMnO1xuLyoqXG4gKiBBIG11bHRpbWFwIGlzIGEgdmFyaWF0aW9uIG9mIGEgTWFwIHRoYXQgaGFzIHBvdGVudGlhbGx5IG11bHRpcGxlIHZhbHVlcyBmb3IgZXZlcnkga2V5LlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlNYXAge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gUmVkdWN0aW9uLnN1bShzdHJlYW0odGhpcy5tYXAudmFsdWVzKCkpLm1hcChhID0+IGEubGVuZ3RoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBlbnRyaWVzIGluIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBgdmFsdWVgIGlzIGdpdmVuOlxuICAgICAqICAqIFdpdGggYSB2YWx1ZSwgdGhpcyBtZXRob2QgZGVsZXRlcyB0aGUgc3BlY2lmaWMga2V5IC8gdmFsdWUgcGFpciBmcm9tIHRoZSBtdWx0aW1hcC5cbiAgICAgKiAgKiBXaXRob3V0IGEgdmFsdWUsIGFsbCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkgYXJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYSB2YWx1ZSBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLCBvciBgZmFsc2VgIGlmIHRoZSBzcGVjaWZpZWRcbiAgICAgKiAgICAga2V5IC8gdmFsdWUgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuIElmIG5vIHZhbHVlIGV4aXN0cyxcbiAgICAgKiBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIF9Ob3RlOl8gVGhlIHJldHVybmVkIGFycmF5IGlzIGFzc3VtZWQgbm90IHRvIGJlIG1vZGlmaWVkLiBVc2UgdGhlIGBzZXRgIG1ldGhvZCB0byBhZGQgYVxuICAgICAqIHZhbHVlIGFuZCBgZGVsZXRlYCB0byByZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubWFwLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBgdmFsdWVgIGlzIGdpdmVuOlxuICAgICAqICAqIFdpdGggYSB2YWx1ZSwgdGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmljIGtleSAvIHZhbHVlIHBhaXIgaXMgcHJlc2VudCBpbiB0aGUgbXVsdGltYXAuXG4gICAgICogICogV2l0aG91dCBhIHZhbHVlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGhhcyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLmluZGV4T2YodmFsdWUpID49IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBnaXZlbiBrZXkgLyB2YWx1ZSBwYWlyIHRvIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5tYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZ2l2ZW4gc2V0IG9mIGtleSAvIHZhbHVlIHBhaXJzIHRvIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBhZGRBbGwoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5nZXQoa2V5KS5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBBcnJheS5mcm9tKHZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXZlcnkga2V5IC8gdmFsdWUgcGFpciBpbiB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgZm9yRWFjaChjYWxsYmFja2ZuKSB7XG4gICAgICAgIHRoaXMubWFwLmZvckVhY2goKGFycmF5LCBrZXkpID0+IGFycmF5LmZvckVhY2godmFsdWUgPT4gY2FsbGJhY2tmbih2YWx1ZSwga2V5LCB0aGlzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKS5pdGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLm1hcC5lbnRyaWVzKCkpXG4gICAgICAgICAgICAuZmxhdE1hcCgoW2tleSwgYXJyYXldKSA9PiBhcnJheS5tYXAodmFsdWUgPT4gW2tleSwgdmFsdWVdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2Yga2V5cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0odGhpcy5tYXAua2V5cygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiB2YWx1ZXMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0odGhpcy5tYXAudmFsdWVzKCkpLmZsYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBrZXksIHZhbHVlIHNldCBwYWlycyBmb3IgZXZlcnkga2V5IGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgZW50cmllc0dyb3VwZWRCeUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLm1hcC5lbnRyaWVzKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCaU1hcCB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zaXplO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaW52ZXJzZS5jbGVhcigpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW52ZXJzZS5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICB9XG4gICAgZ2V0S2V5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2UuZ2V0KHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLmludmVyc2UuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/cst-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/cst-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultNameRegexp: () => (/* binding */ DefaultNameRegexp),\n/* harmony export */   RangeComparison: () => (/* binding */ RangeComparison),\n/* harmony export */   compareRange: () => (/* binding */ compareRange),\n/* harmony export */   findCommentNode: () => (/* binding */ findCommentNode),\n/* harmony export */   findDeclarationNodeAtOffset: () => (/* binding */ findDeclarationNodeAtOffset),\n/* harmony export */   findLeafNodeAtOffset: () => (/* binding */ findLeafNodeAtOffset),\n/* harmony export */   findLeafNodeBeforeOffset: () => (/* binding */ findLeafNodeBeforeOffset),\n/* harmony export */   flattenCst: () => (/* binding */ flattenCst),\n/* harmony export */   getInteriorNodes: () => (/* binding */ getInteriorNodes),\n/* harmony export */   getNextNode: () => (/* binding */ getNextNode),\n/* harmony export */   getPreviousNode: () => (/* binding */ getPreviousNode),\n/* harmony export */   getStartlineNode: () => (/* binding */ getStartlineNode),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isChildNode: () => (/* binding */ isChildNode),\n/* harmony export */   isCommentNode: () => (/* binding */ isCommentNode),\n/* harmony export */   streamCst: () => (/* binding */ streamCst),\n/* harmony export */   toDocumentSegment: () => (/* binding */ toDocumentSegment),\n/* harmony export */   tokenToRange: () => (/* binding */ tokenToRange)\n/* harmony export */ });\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nfunction streamCst(node) {\n    return new _stream_js__WEBPACK_IMPORTED_MODULE_0__.TreeStreamImpl(node, element => {\n        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(element)) {\n            return element.content;\n        }\n        else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nfunction flattenCst(node) {\n    return streamCst(node).filter(_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nfunction isChildNode(child, parent) {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction tokenToRange(token) {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn, // endColumn uses the correct index\n            line: token.endLine - 1\n        }\n    };\n}\nfunction toDocumentSegment(node) {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\nvar RangeComparison;\n(function (RangeComparison) {\n    RangeComparison[RangeComparison[\"Before\"] = 0] = \"Before\";\n    RangeComparison[RangeComparison[\"After\"] = 1] = \"After\";\n    RangeComparison[RangeComparison[\"OverlapFront\"] = 2] = \"OverlapFront\";\n    RangeComparison[RangeComparison[\"OverlapBack\"] = 3] = \"OverlapBack\";\n    RangeComparison[RangeComparison[\"Inside\"] = 4] = \"Inside\";\n    RangeComparison[RangeComparison[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nfunction compareRange(range, to) {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\n        return RangeComparison.Before;\n    }\n    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    }\n    else if (startInside) {\n        return RangeComparison.OverlapBack;\n    }\n    else if (endInside) {\n        return RangeComparison.OverlapFront;\n    }\n    else {\n        return RangeComparison.Outside;\n    }\n}\nfunction inRange(range, to) {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nconst DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nfunction findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\nfunction findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isRootCstNode)(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction isCommentNode(cstNode, commentNames) {\n    return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nfunction findLeafNodeAtOffset(node, offset) {\n    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(node)) {\n        return node;\n    }\n    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nfunction findLeafNodeBeforeOffset(node, offset) {\n    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(node)) {\n        return node;\n    }\n    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = undefined;\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        }\n        else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n    return closestNode;\n}\nfunction getPreviousNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nfunction getNextNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nfunction getStartlineNode(node) {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        }\n        else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\nfunction getInteriorNodes(start, end) {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        }\n        else {\n            break;\n        }\n    }\n    return current;\n}\nfunction getParentChain(node) {\n    const chain = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n//# sourceMappingURL=cst-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY3N0LXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRjtBQUN4QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSxzREFBYztBQUM3QixZQUFZLG1FQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0NBQWtDLDBEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUNwQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDTyxrQ0FBa0MsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDhEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsOERBQWE7QUFDckI7QUFDQTtBQUNBLGFBQWEsbUVBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsOERBQWE7QUFDckI7QUFDQTtBQUNBLGFBQWEsbUVBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXGNzdC11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBpc0NvbXBvc2l0ZUNzdE5vZGUsIGlzTGVhZkNzdE5vZGUsIGlzUm9vdENzdE5vZGUgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBUcmVlU3RyZWFtSW1wbCB9IGZyb20gJy4vc3RyZWFtLmpzJztcbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBDU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUsXG4gKiBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1Dc3Qobm9kZSkge1xuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwobm9kZSwgZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9LCB7IGluY2x1ZGVSb290OiB0cnVlIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJlYW0gb2YgYWxsIGxlYWYgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuQ3N0KG5vZGUpIHtcbiAgICByZXR1cm4gc3RyZWFtQ3N0KG5vZGUpLmZpbHRlcihpc0xlYWZDc3ROb2RlKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgY3N0IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgc3BlY2lmaWVkIHBhcmVudCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaGlsZE5vZGUoY2hpbGQsIHBhcmVudCkge1xuICAgIHdoaWxlIChjaGlsZC5jb250YWluZXIpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5jb250YWluZXI7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5Ub1JhbmdlKHRva2VuKSB7XG4gICAgLy8gQ2hldnJvdGFpbiB1c2VzIDEtYmFzZWQgaW5kaWNlcyBldmVyeXdoZXJlXG4gICAgLy8gU28gd2Ugc3VidHJhY3QgMSBmcm9tIGV2ZXJ5IHZhbHVlIHRvIGFsaWduIHdpdGggdGhlIExTUFxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHRva2VuLnN0YXJ0Q29sdW1uIC0gMSxcbiAgICAgICAgICAgIGxpbmU6IHRva2VuLnN0YXJ0TGluZSAtIDFcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHRva2VuLmVuZENvbHVtbiwgLy8gZW5kQ29sdW1uIHVzZXMgdGhlIGNvcnJlY3QgaW5kZXhcbiAgICAgICAgICAgIGxpbmU6IHRva2VuLmVuZExpbmUgLSAxXG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRG9jdW1lbnRTZWdtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyBvZmZzZXQsIGVuZCwgcmFuZ2UgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZW5kLFxuICAgICAgICBsZW5ndGg6IGVuZCAtIG9mZnNldFxuICAgIH07XG59XG5leHBvcnQgdmFyIFJhbmdlQ29tcGFyaXNvbjtcbihmdW5jdGlvbiAoUmFuZ2VDb21wYXJpc29uKSB7XG4gICAgUmFuZ2VDb21wYXJpc29uW1JhbmdlQ29tcGFyaXNvbltcIkJlZm9yZVwiXSA9IDBdID0gXCJCZWZvcmVcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiQWZ0ZXJcIl0gPSAxXSA9IFwiQWZ0ZXJcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiT3ZlcmxhcEZyb250XCJdID0gMl0gPSBcIk92ZXJsYXBGcm9udFwiO1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJPdmVybGFwQmFja1wiXSA9IDNdID0gXCJPdmVybGFwQmFja1wiO1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJJbnNpZGVcIl0gPSA0XSA9IFwiSW5zaWRlXCI7XG4gICAgUmFuZ2VDb21wYXJpc29uW1JhbmdlQ29tcGFyaXNvbltcIk91dHNpZGVcIl0gPSA1XSA9IFwiT3V0c2lkZVwiO1xufSkoUmFuZ2VDb21wYXJpc29uIHx8IChSYW5nZUNvbXBhcmlzb24gPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVSYW5nZShyYW5nZSwgdG8pIHtcbiAgICBpZiAocmFuZ2UuZW5kLmxpbmUgPCB0by5zdGFydC5saW5lIHx8IChyYW5nZS5lbmQubGluZSA9PT0gdG8uc3RhcnQubGluZSAmJiByYW5nZS5lbmQuY2hhcmFjdGVyIDw9IHRvLnN0YXJ0LmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlQ29tcGFyaXNvbi5CZWZvcmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmdlLnN0YXJ0LmxpbmUgPiB0by5lbmQubGluZSB8fCAocmFuZ2Uuc3RhcnQubGluZSA9PT0gdG8uZW5kLmxpbmUgJiYgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyID49IHRvLmVuZC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uQWZ0ZXI7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5zaWRlID0gcmFuZ2Uuc3RhcnQubGluZSA+IHRvLnN0YXJ0LmxpbmUgfHwgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IHRvLnN0YXJ0LmxpbmUgJiYgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyID49IHRvLnN0YXJ0LmNoYXJhY3Rlcik7XG4gICAgY29uc3QgZW5kSW5zaWRlID0gcmFuZ2UuZW5kLmxpbmUgPCB0by5lbmQubGluZSB8fCAocmFuZ2UuZW5kLmxpbmUgPT09IHRvLmVuZC5saW5lICYmIHJhbmdlLmVuZC5jaGFyYWN0ZXIgPD0gdG8uZW5kLmNoYXJhY3Rlcik7XG4gICAgaWYgKHN0YXJ0SW5zaWRlICYmIGVuZEluc2lkZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VDb21wYXJpc29uLkluc2lkZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlQ29tcGFyaXNvbi5PdmVybGFwQmFjaztcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kSW5zaWRlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uT3ZlcmxhcEZyb250O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlQ29tcGFyaXNvbi5PdXRzaWRlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKHJhbmdlLCB0bykge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBjb21wYXJlUmFuZ2UocmFuZ2UsIHRvKTtcbiAgICByZXR1cm4gY29tcGFyaXNvbiA+IFJhbmdlQ29tcGFyaXNvbi5BZnRlcjtcbn1cbi8vIFRoZSBcXHB7TH0gcmVnZXggbWF0Y2hlcyBhbnkgdW5pY29kZSBsZXR0ZXIgY2hhcmFjdGVyLCBpLmUuIGNoYXJhY3RlcnMgZnJvbSBub24tZW5nbGlzaCBhbHBoYWJldHNcbi8vIFRvZ2V0aGVyIHdpdGggXFx3IGl0IG1hdGNoZXMgYW55IGtpbmQgb2YgY2hhcmFjdGVyIHdoaWNoIGNhbiBjb21tb25seSBhcHBlYXIgaW4gSURzXG5leHBvcnQgY29uc3QgRGVmYXVsdE5hbWVSZWdleHAgPSAvXltcXHdcXHB7TH1dJC91O1xuLyoqXG4gKiBQZXJmb3JtcyBgZmluZExlYWZOb2RlQXRPZmZzZXRgIHdpdGggYSBtaW5vciBkaWZmZXJlbmNlOiBXaGVuIGVuY291bnRlcmluZyBhIGNoYXJhY3RlciB0aGF0IG1hdGNoZXMgdGhlIGBuYW1lUmVnZXhwYCBhcmd1bWVudCxcbiAqIGl0IHdpbGwgaW5zdGVhZCByZXR1cm4gdGhlIGxlYWYgbm9kZSBhdCB0aGUgYG9mZnNldCAtIDFgIHBvc2l0aW9uLlxuICpcbiAqIEZvciBMU1Agc2VydmljZXMsIHVzZXJzIGV4cGVjdCB0aGF0IHRoZSBkZWNsYXJhdGlvbiBvZiBhbiBlbGVtZW50IGlzIGF2YWlsYWJsZSBpZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGFmdGVyIHRoZSBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZERlY2xhcmF0aW9uTm9kZUF0T2Zmc2V0KGNzdE5vZGUsIG9mZnNldCwgbmFtZVJlZ2V4cCA9IERlZmF1bHROYW1lUmVnZXhwKSB7XG4gICAgaWYgKGNzdE5vZGUpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0IC0gY3N0Tm9kZS5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QXRPZmZzZXQgPSBjc3ROb2RlLnRleHQuY2hhckF0KGxvY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghbmFtZVJlZ2V4cC50ZXN0KHRleHRBdE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZExlYWZOb2RlQXRPZmZzZXQoY3N0Tm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUoY3N0Tm9kZSwgY29tbWVudE5hbWVzKSB7XG4gICAgaWYgKGNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSBnZXRQcmV2aW91c05vZGUoY3N0Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChwcmV2aW91cyAmJiBpc0NvbW1lbnROb2RlKHByZXZpb3VzLCBjb21tZW50TmFtZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUm9vdENzdE5vZGUoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIEdvIGZyb20gdGhlIGZpcnN0IG5vbi1oaWRkZW4gbm9kZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByZXZlcnNlIG9yZGVyXG4gICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIGZpbmQgdGhlIGNvbW1lbnQgbm9kZSB3aGljaCBkaXJlY3RseSBwcmVjZWRlcyB0aGUgcm9vdCBub2RlXG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNzdE5vZGUuY29udGVudC5maW5kSW5kZXgoZSA9PiAhZS5oaWRkZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVuZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNzdE5vZGUuY29udGVudFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21tZW50Tm9kZShjaGlsZCwgY29tbWVudE5hbWVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tZW50Tm9kZShjc3ROb2RlLCBjb21tZW50TmFtZXMpIHtcbiAgICByZXR1cm4gaXNMZWFmQ3N0Tm9kZShjc3ROb2RlKSAmJiBjb21tZW50TmFtZXMuaW5jbHVkZXMoY3N0Tm9kZS50b2tlblR5cGUubmFtZSk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBsZWFmIENTVCBub2RlIGF0IHRoZSBzcGVjaWZpZWQgMC1iYXNlZCBzdHJpbmcgb2Zmc2V0LlxuICogTm90ZSB0aGF0IHRoZSBnaXZlbiBvZmZzZXQgd2lsbCBiZSB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSByZXR1cm5lZCBsZWFmIG5vZGUuXG4gKlxuICogSWYgdGhlIG9mZnNldCBkb2VzIG5vdCBwb2ludCB0byBhIENTVCBub2RlIChidXQganVzdCB3aGl0ZSBzcGFjZSksIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBDU1Qgbm9kZSB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSBvZmZzZXQgVGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJucyBUaGUgQ1NUIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGVhZk5vZGVBdE9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAoaXNMZWFmQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdCA9IGJpbmFyeVNlYXJjaChub2RlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRMZWFmTm9kZUF0T2Zmc2V0KHNlYXJjaFJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbGVhZiBDU1Qgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIDAtYmFzZWQgc3RyaW5nIG9mZnNldC5cbiAqIElmIG5vIENTVCBub2RlIGV4aXN0cyBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLCBpdCB3aWxsIHJldHVybiB0aGUgbGVhZiBub2RlIGJlZm9yZSBpdC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBsZWFmIG5vZGUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgQ1NUIG5vZGUgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybnMgVGhlIENTVCBub2RlIGNsb3Nlc3QgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGVhZk5vZGVCZWZvcmVPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKGlzTGVhZkNzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHQgPSBiaW5hcnlTZWFyY2gobm9kZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRMZWFmTm9kZUJlZm9yZU9mZnNldChzZWFyY2hSZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChub2RlLCBvZmZzZXQsIGNsb3Nlc3QpIHtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IHJpZ2h0ID0gbm9kZS5jb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGNsb3Nlc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICAgICAgY29uc3QgbWlkZGxlTm9kZSA9IG5vZGUuY29udGVudFttaWRkbGVdO1xuICAgICAgICBpZiAobWlkZGxlTm9kZS5vZmZzZXQgPD0gb2Zmc2V0ICYmIG1pZGRsZU5vZGUuZW5kID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhbiBleGFjdCBtYXRjaFxuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pZGRsZU5vZGUuZW5kIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjbG9zZXN0IG5vZGUgKGxlc3MgdGhhbiBvZmZzZXQpIGFuZCBtb3ZlIHRvIHRoZSByaWdodCBoYWxmXG4gICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IGNsb3Nlc3QgPyBtaWRkbGVOb2RlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGVmdCA9IG1pZGRsZSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBsZWZ0IGhhbGZcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkZGxlIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdE5vZGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNOb2RlKG5vZGUsIGhpZGRlbiA9IHRydWUpIHtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGxldCBpbmRleCA9IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHBhcmVudC5jb250ZW50W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoaWRkZW4gfHwgIXByZXZpb3VzLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHROb2RlKG5vZGUsIGhpZGRlbiA9IHRydWUpIHtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGxldCBpbmRleCA9IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBwYXJlbnQuY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBhcmVudC5jb250ZW50W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoaWRkZW4gfHwgIW5leHQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydGxpbmVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGxpbmUgPSBub2RlLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgbGV0IGxhc3QgPSBub2RlO1xuICAgIGxldCBpbmRleDtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNlbGZJbmRleCA9IGluZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChzZWxmSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gc2VsZkluZGV4IC0gMTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY29udGVudFtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucmFuZ2Uuc3RhcnQubGluZSAhPT0gbGluZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBsYXN0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yTm9kZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGNvbW1vblBhcmVudCA9IGdldENvbW1vblBhcmVudChzdGFydCwgZW5kKTtcbiAgICBpZiAoIWNvbW1vblBhcmVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjb21tb25QYXJlbnQucGFyZW50LmNvbnRlbnQuc2xpY2UoY29tbW9uUGFyZW50LmEgKyAxLCBjb21tb25QYXJlbnQuYik7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QYXJlbnQoYSwgYikge1xuICAgIGNvbnN0IGFQYXJlbnRzID0gZ2V0UGFyZW50Q2hhaW4oYSk7XG4gICAgY29uc3QgYlBhcmVudHMgPSBnZXRQYXJlbnRDaGFpbihiKTtcbiAgICBsZXQgY3VycmVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFQYXJlbnRzLmxlbmd0aCAmJiBpIDwgYlBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYVBhcmVudCA9IGFQYXJlbnRzW2ldO1xuICAgICAgICBjb25zdCBiUGFyZW50ID0gYlBhcmVudHNbaV07XG4gICAgICAgIGlmIChhUGFyZW50LnBhcmVudCA9PT0gYlBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiBhUGFyZW50LnBhcmVudCxcbiAgICAgICAgICAgICAgICBhOiBhUGFyZW50LmluZGV4LFxuICAgICAgICAgICAgICAgIGI6IGJQYXJlbnQuaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudENoYWluKG5vZGUpIHtcbiAgICBjb25zdCBjaGFpbiA9IFtdO1xuICAgIHdoaWxlIChub2RlLmNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBjaGFpbi5wdXNoKHtcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2hhaW4ucmV2ZXJzZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/cst-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/disposable.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/utils/disposable.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Disposable: () => (/* binding */ Disposable)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nvar Disposable;\n(function (Disposable) {\n    function create(callback) {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (Disposable = {}));\n//# sourceMappingURL=disposable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZGlzcG9zYWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQyIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx1dGlsc1xcZGlzcG9zYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgdmFyIERpc3Bvc2FibGU7XG4oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGFzeW5jICgpID0+IGF3YWl0IGNhbGxiYWNrKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChEaXNwb3NhYmxlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3Bvc2FibGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/disposable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/utils/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorWithLocation: () => (/* binding */ ErrorWithLocation),\n/* harmony export */   assertUnreachable: () => (/* binding */ assertUnreachable)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass ErrorWithLocation extends Error {\n    constructor(node, message) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\nfunction assertUnreachable(_) {\n    throw new Error('Error! The input value was not handled.');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx3QkFBd0IsU0FBUyxLQUFLLHNCQUFzQixHQUFHLDJCQUEyQjtBQUMxRjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgY2xhc3MgRXJyb3JXaXRoTG9jYXRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihub2RlID8gYCR7bWVzc2FnZX0gYXQgJHtub2RlLnJhbmdlLnN0YXJ0LmxpbmV9OiR7bm9kZS5yYW5nZS5zdGFydC5jaGFyYWN0ZXJ9YCA6IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVbnJlYWNoYWJsZShfKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciEgVGhlIGlucHV0IHZhbHVlIHdhcyBub3QgaGFuZGxlZC4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/grammar-loader.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/utils/grammar-loader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadGrammarFromJson: () => (/* binding */ loadGrammarFromJson)\n/* harmony export */ });\n/* harmony import */ var _default_module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../default-module.js */ \"(ssr)/./node_modules/langium/lib/default-module.js\");\n/* harmony import */ var _dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-injection.js */ \"(ssr)/./node_modules/langium/lib/dependency-injection.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _workspace_file_system_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../workspace/file-system-provider.js */ \"(ssr)/./node_modules/langium/lib/workspace/file-system-provider.js\");\n/* harmony import */ var _uri_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uri-utils.js */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nconst minimalGrammarModule = {\n    Grammar: () => undefined,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: ['.langium'],\n        languageId: 'langium'\n    })\n};\nconst minimalSharedGrammarModule = {\n    AstReflection: () => new _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n    const shared = (0,_dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__.inject)((0,_default_module_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultSharedCoreModule)(_workspace_file_system_provider_js__WEBPACK_IMPORTED_MODULE_3__.EmptyFileSystem), minimalSharedGrammarModule);\n    const grammar = (0,_dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__.inject)((0,_default_module_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultCoreModule)({ shared }), minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nfunction loadGrammarFromJson(json) {\n    var _a;\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, _uri_utils_js__WEBPACK_IMPORTED_MODULE_4__.URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));\n    return astNode;\n}\n//# sourceMappingURL=grammar-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZ3JhbW1hci1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RjtBQUMxQztBQUNDO0FBQ2tCO0FBQ2xDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLG9GQUErQjtBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFNLENBQUMsaUZBQTZCLENBQUMsK0VBQWU7QUFDdkUsb0JBQW9CLGdFQUFNLENBQUMsMkVBQXVCLEdBQUcsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDhDQUFHLG1CQUFtQiwrREFBK0Q7QUFDN0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHV0aWxzXFxncmFtbWFyLWxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSwgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUgfSBmcm9tICcuLi9kZWZhdWx0LW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBpbmplY3QgfSBmcm9tICcuLi9kZXBlbmRlbmN5LWluamVjdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBhc3QgZnJvbSAnLi4vbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMnO1xuaW1wb3J0IHsgRW1wdHlGaWxlU3lzdGVtIH0gZnJvbSAnLi4vd29ya3NwYWNlL2ZpbGUtc3lzdGVtLXByb3ZpZGVyLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4vdXJpLXV0aWxzLmpzJztcbmNvbnN0IG1pbmltYWxHcmFtbWFyTW9kdWxlID0ge1xuICAgIEdyYW1tYXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBMYW5ndWFnZU1ldGFEYXRhOiAoKSA9PiAoe1xuICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICBmaWxlRXh0ZW5zaW9uczogWycubGFuZ2l1bSddLFxuICAgICAgICBsYW5ndWFnZUlkOiAnbGFuZ2l1bSdcbiAgICB9KVxufTtcbmNvbnN0IG1pbmltYWxTaGFyZWRHcmFtbWFyTW9kdWxlID0ge1xuICAgIEFzdFJlZmxlY3Rpb246ICgpID0+IG5ldyBhc3QuTGFuZ2l1bUdyYW1tYXJBc3RSZWZsZWN0aW9uKClcbn07XG5mdW5jdGlvbiBjcmVhdGVNaW5pbWFsR3JhbW1hclNlcnZpY2VzKCkge1xuICAgIGNvbnN0IHNoYXJlZCA9IGluamVjdChjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShFbXB0eUZpbGVTeXN0ZW0pLCBtaW5pbWFsU2hhcmVkR3JhbW1hck1vZHVsZSk7XG4gICAgY29uc3QgZ3JhbW1hciA9IGluamVjdChjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSh7IHNoYXJlZCB9KSwgbWluaW1hbEdyYW1tYXJNb2R1bGUpO1xuICAgIHNoYXJlZC5TZXJ2aWNlUmVnaXN0cnkucmVnaXN0ZXIoZ3JhbW1hcik7XG4gICAgcmV0dXJuIGdyYW1tYXI7XG59XG4vKipcbiAqIExvYWQgYSBMYW5naXVtIGdyYW1tYXIgZm9yIHlvdXIgbGFuZ3VhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLiBUaGlzIGlzIHVzZWQgYnkgc2V2ZXJhbCBzZXJ2aWNlcyxcbiAqIG1vc3Qgbm90YWJseSB0aGUgcGFyc2VyIGJ1aWxkZXIgd2hpY2ggaW50ZXJwcmV0cyB0aGUgZ3JhbW1hciB0byBjcmVhdGUgYSBwYXJzZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkR3JhbW1hckZyb21Kc29uKGpzb24pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2VydmljZXMgPSBjcmVhdGVNaW5pbWFsR3JhbW1hclNlcnZpY2VzKCk7XG4gICAgY29uc3QgYXN0Tm9kZSA9IHNlcnZpY2VzLnNlcmlhbGl6ZXIuSnNvblNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoanNvbik7XG4gICAgc2VydmljZXMuc2hhcmVkLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRGYWN0b3J5LmZyb21Nb2RlbChhc3ROb2RlLCBVUkkucGFyc2UoYG1lbW9yeTovLyR7KF9hID0gYXN0Tm9kZS5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZ3JhbW1hcid9LmxhbmdpdW1gKSk7XG4gICAgcmV0dXJuIGFzdE5vZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFtbWFyLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/grammar-loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/grammar-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/utils/grammar-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAssignment: () => (/* binding */ findAssignment),\n/* harmony export */   findNameAssignment: () => (/* binding */ findNameAssignment),\n/* harmony export */   findNodeForKeyword: () => (/* binding */ findNodeForKeyword),\n/* harmony export */   findNodeForProperty: () => (/* binding */ findNodeForProperty),\n/* harmony export */   findNodesForKeyword: () => (/* binding */ findNodesForKeyword),\n/* harmony export */   findNodesForKeywordInternal: () => (/* binding */ findNodesForKeywordInternal),\n/* harmony export */   findNodesForProperty: () => (/* binding */ findNodesForProperty),\n/* harmony export */   getActionAtElement: () => (/* binding */ getActionAtElement),\n/* harmony export */   getActionType: () => (/* binding */ getActionType),\n/* harmony export */   getAllReachableRules: () => (/* binding */ getAllReachableRules),\n/* harmony export */   getCrossReferenceTerminal: () => (/* binding */ getCrossReferenceTerminal),\n/* harmony export */   getEntryRule: () => (/* binding */ getEntryRule),\n/* harmony export */   getExplicitRuleType: () => (/* binding */ getExplicitRuleType),\n/* harmony export */   getHiddenRules: () => (/* binding */ getHiddenRules),\n/* harmony export */   getRuleType: () => (/* binding */ getRuleType),\n/* harmony export */   getRuleTypeName: () => (/* binding */ getRuleTypeName),\n/* harmony export */   getTypeName: () => (/* binding */ getTypeName),\n/* harmony export */   isArrayCardinality: () => (/* binding */ isArrayCardinality),\n/* harmony export */   isArrayOperator: () => (/* binding */ isArrayOperator),\n/* harmony export */   isCommentTerminal: () => (/* binding */ isCommentTerminal),\n/* harmony export */   isDataType: () => (/* binding */ isDataType),\n/* harmony export */   isDataTypeRule: () => (/* binding */ isDataTypeRule),\n/* harmony export */   isOptionalCardinality: () => (/* binding */ isOptionalCardinality),\n/* harmony export */   terminalRegex: () => (/* binding */ terminalRegex)\n/* harmony export */ });\n/* harmony import */ var _utils_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/errors.js */ \"(ssr)/./node_modules/langium/lib/utils/errors.js\");\n/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ \"(ssr)/./node_modules/langium/lib/languages/generated/ast.js\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _cst_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/* harmony import */ var _regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./regexp-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/regexp-utils.js\");\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nfunction getEntryRule(grammar) {\n    return grammar.rules.find(e => _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(e) && e.entry);\n}\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nfunction getHiddenRules(grammar) {\n    return grammar.rules.filter((e) => _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(e) && e.hidden);\n}\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nfunction getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = new Set();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n    const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n    const rules = new Set();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rule).forEach(node => {\n        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node) || (allTerminals && _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nfunction getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    }\n    else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return undefined;\n}\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nfunction isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !(0,_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.isWhitespace)(terminalRegex(terminalRule));\n}\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nfunction findNodesForProperty(node, property) {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nfunction findNodeForProperty(node, property, index) {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first) {\n    if (!first) {\n        const nodeFeature = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(node.grammarSource, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nfunction findNodesForKeyword(node, keyword) {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nfunction findNodeForKeyword(node, keyword, index) {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = (0,_cst_utils_js__WEBPACK_IMPORTED_MODULE_4__.streamCst)(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            }\n            else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nfunction findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n        const assignment = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(cstNode.grammarSource, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nfunction findNameAssignment(type) {\n    let startNode = type;\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container;\n        }\n        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        }\n        else {\n            (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_5__.assertUnreachable)(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    // the cache is only required to prevent infinite loops\n    function go(node, refType) {\n        let childAssignment = undefined;\n        const parentAssignment = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(node, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(startNode)) {\n        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        }\n        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node) && _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        }\n        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\nfunction getActionAtElement(element) {\n    const parent = element.$container;\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(item)) {\n                return item;\n            }\n            else {\n                const action = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(elements[i]).find(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isOptionalCardinality(cardinality, element) {\n    return cardinality === '?' || cardinality === '*' || (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isGroup(element) && Boolean(element.guardCondition));\n}\nfunction isArrayCardinality(cardinality) {\n    return cardinality === '*' || cardinality === '+';\n}\nfunction isArrayOperator(operator) {\n    return operator === '+=';\n}\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nfunction isDataTypeRule(rule) {\n    return isDataTypeRuleInternal(rule, new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) {\n        return true;\n    }\n    else {\n        visited.add(rule);\n    }\n    for (const node of (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rule)) {\n        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        }\n        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment(node)) {\n            return false;\n        }\n        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\nfunction isDataType(type) {\n    return isDataTypeInternal(type.type, new Set());\n}\nfunction isDataTypeInternal(type, visited) {\n    if (visited.has(type)) {\n        return true;\n    }\n    else {\n        visited.add(type);\n    }\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isArrayType(type)) {\n        return false;\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isReferenceType(type)) {\n        return false;\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        }\n        else if (type.stringType !== undefined) {\n            return true;\n        }\n        else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nfunction getExplicitRuleType(rule) {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    }\n    else if (rule.dataType) {\n        return rule.dataType;\n    }\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            // check if we need to check Action as return type\n            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(refType)) {\n                return refType.name;\n            }\n            else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInterface(refType) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\nfunction getTypeName(type) {\n    var _a;\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInterface(type) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(type) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isReturnType(type)) {\n        return type.name;\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\nfunction getActionType(action) {\n    var _a;\n    if (action.inferredType) {\n        return action.inferredType.name;\n    }\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n/**\n * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.\n * For data type rules, the name of the rule is returned,\n * e.g. \"INT_value returns number: MY_INT;\" returns \"INT_value\".\n * @param rule the given rule\n * @returns the name of the AST node type of the rule\n */\nfunction getRuleTypeName(rule) {\n    var _a, _b, _c;\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\n/**\n * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.\n * For data type rules, the name of the declared return type of the rule is returned (if any),\n * e.g. \"INT_value returns number: MY_INT;\" returns \"number\".\n * @param rule the given rule\n * @returns the name of the type of the produced values of the rule at runtime\n */\nfunction getRuleType(rule) {\n    var _a, _b, _c;\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';\n    }\n    else {\n        return (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\nfunction terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    }\n    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else {\n        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n    }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\nfunction terminalGroupToRegex(group) {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\nfunction untilTokenToRegex(until) {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\nfunction negateTokenToRegex(negate) {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\nfunction characterRangeToRegex(range) {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\nfunction keywordToRegex(keyword) {\n    return (0,_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegExp)(keyword.value);\n}\nfunction withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n//# sourceMappingURL=grammar-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZ3JhbW1hci11dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ0Y7QUFDRTtBQUNnQjtBQUM1QjtBQUNvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLHFFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUNBQXVDLHVFQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUVBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBaUI7QUFDckIsWUFBWSxtRUFBYywyQkFBMkIsMkVBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQ0FBbUMsOERBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUVBQWtCLHFCQUFxQixxRUFBZ0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFhO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBa0Isd0JBQXdCLHFFQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx1RUFBa0I7QUFDMUI7QUFDQSxZQUFZLGlFQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxRUFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUVBQWtCLE9BQU8scUVBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWlCO0FBQ3hDLFlBQVkscUVBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBYyxVQUFVLHFFQUFnQjtBQUN6RDtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEsZ0VBQVc7QUFDbkI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsZ0JBQWdCLGlFQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRUFBaUIsbUJBQW1CLGlFQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEVBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMERBQTBELGdFQUFXO0FBQ3JFO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRUFBaUI7QUFDeEMsWUFBWSxtRUFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFnQjtBQUNqQztBQUNBO0FBQ0EsaUJBQWlCLGlFQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQWU7QUFDdkI7QUFDQTtBQUNBLGFBQWEsd0VBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLG9FQUFlO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLHFFQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFnQjtBQUNoQztBQUNBO0FBQ0EscUJBQXFCLG9FQUFlLGFBQWEsK0RBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFFBQVEscUVBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLG9FQUFlLFVBQVUsK0RBQVUsVUFBVSxxRUFBZ0I7QUFDMUU7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUVBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx1RUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLHVFQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0VBQTBCO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhLHdFQUFtQjtBQUNoQztBQUNBO0FBQ0EsYUFBYSx5RUFBb0I7QUFDakM7QUFDQTtBQUNBLGFBQWEsMkVBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYSx1RUFBa0I7QUFDL0I7QUFDQTtBQUNBLGFBQWEscUVBQWdCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLHFFQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLG1FQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscURBQXFELGdFQUFnRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLFNBQVMsSUFBSSx1Q0FBdUM7QUFDbEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QyxHQUFHLFNBQVM7QUFDckY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkJBQTJCLEdBQUcsNEJBQTRCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLDhEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUE2RCxFQUFFLE1BQU07QUFDekY7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEVBQUUsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHV0aWxzXFxncmFtbWFyLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxLTIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgYXNzZXJ0VW5yZWFjaGFibGUgfSBmcm9tICcuLi91dGlscy9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgYXN0IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGlzQ29tcG9zaXRlQ3N0Tm9kZSB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IGdldENvbnRhaW5lck9mVHlwZSwgc3RyZWFtQWxsQ29udGVudHMgfSBmcm9tICcuL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBzdHJlYW1Dc3QgfSBmcm9tICcuL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVSZWdFeHAsIGlzV2hpdGVzcGFjZSB9IGZyb20gJy4vcmVnZXhwLXV0aWxzLmpzJztcbi8qKlxuICogUmV0dXJucyB0aGUgZW50cnkgcnVsZSBvZiB0aGUgZ2l2ZW4gZ3JhbW1hciwgaWYgYW55LiBJZiB0aGUgZ3JhbW1hciBmaWxlIGRvZXMgbm90IGNvbnRhaW4gYW4gZW50cnkgcnVsZSxcbiAqIHRoZSByZXN1bHQgaXMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnRyeVJ1bGUoZ3JhbW1hcikge1xuICAgIHJldHVybiBncmFtbWFyLnJ1bGVzLmZpbmQoZSA9PiBhc3QuaXNQYXJzZXJSdWxlKGUpICYmIGUuZW50cnkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFsbCBoaWRkZW4gdGVybWluYWwgcnVsZXMgb2YgdGhlIGdpdmVuIGdyYW1tYXIsIGlmIGFueS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhpZGRlblJ1bGVzKGdyYW1tYXIpIHtcbiAgICByZXR1cm4gZ3JhbW1hci5ydWxlcy5maWx0ZXIoKGUpID0+IGFzdC5pc1Rlcm1pbmFsUnVsZShlKSAmJiBlLmhpZGRlbik7XG59XG4vKipcbiAqIFJldHVybnMgYWxsIHJ1bGVzIHRoYXQgY2FuIGJlIHJlYWNoZWQgZnJvbSB0aGUgdG9wbW9zdCBydWxlcyBvZiB0aGUgc3BlY2lmaWVkIGdyYW1tYXIgKGVudHJ5IGFuZCBoaWRkZW4gdGVybWluYWwgcnVsZXMpLlxuICpcbiAqIEBwYXJhbSBncmFtbWFyIFRoZSBncmFtbWFyIHRoYXQgY29udGFpbnMgYWxsIHJ1bGVzXG4gKiBAcGFyYW0gYWxsVGVybWluYWxzIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGVybWluYWxzIHRoYXQgYXJlIHJlZmVyZW5jZWQgb25seSBieSBvdGhlciB0ZXJtaW5hbHNcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiByZWZlcmVuY2VkIHBhcnNlciBhbmQgdGVybWluYWwgcnVsZXMuIElmIHRoZSBncmFtbWFyIGNvbnRhaW5zIG5vIGVudHJ5IHJ1bGUsXG4gKiAgICAgIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgcnVsZXMgb2YgdGhlIHNwZWNpZmllZCBncmFtbWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsUmVhY2hhYmxlUnVsZXMoZ3JhbW1hciwgYWxsVGVybWluYWxzKSB7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGVudHJ5UnVsZSA9IGdldEVudHJ5UnVsZShncmFtbWFyKTtcbiAgICBpZiAoIWVudHJ5UnVsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNldChncmFtbWFyLnJ1bGVzKTtcbiAgICB9XG4gICAgY29uc3QgdG9wTW9zdFJ1bGVzID0gW2VudHJ5UnVsZV0uY29uY2F0KGdldEhpZGRlblJ1bGVzKGdyYW1tYXIpKTtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdG9wTW9zdFJ1bGVzKSB7XG4gICAgICAgIHJ1bGVEZnMocnVsZSwgcnVsZU5hbWVzLCBhbGxUZXJtaW5hbHMpO1xuICAgIH1cbiAgICBjb25zdCBydWxlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JhbW1hci5ydWxlcykge1xuICAgICAgICBpZiAocnVsZU5hbWVzLmhhcyhydWxlLm5hbWUpIHx8IChhc3QuaXNUZXJtaW5hbFJ1bGUocnVsZSkgJiYgcnVsZS5oaWRkZW4pKSB7XG4gICAgICAgICAgICBydWxlcy5hZGQocnVsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzO1xufVxuZnVuY3Rpb24gcnVsZURmcyhydWxlLCB2aXNpdGVkU2V0LCBhbGxUZXJtaW5hbHMpIHtcbiAgICB2aXNpdGVkU2V0LmFkZChydWxlLm5hbWUpO1xuICAgIHN0cmVhbUFsbENvbnRlbnRzKHJ1bGUpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmIChhc3QuaXNSdWxlQ2FsbChub2RlKSB8fCAoYWxsVGVybWluYWxzICYmIGFzdC5pc1Rlcm1pbmFsUnVsZUNhbGwobm9kZSkpKSB7XG4gICAgICAgICAgICBjb25zdCByZWZSdWxlID0gbm9kZS5ydWxlLnJlZjtcbiAgICAgICAgICAgIGlmIChyZWZSdWxlICYmICF2aXNpdGVkU2V0LmhhcyhyZWZSdWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcnVsZURmcyhyZWZSdWxlLCB2aXNpdGVkU2V0LCBhbGxUZXJtaW5hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIGdyYW1tYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHBhcnNlIGEgY3Jvc3MtcmVmZXJlbmNlICh1c3VhbGx5IGEgcmVmZXJlbmNlIHRvIGEgdGVybWluYWwgcnVsZSkuXG4gKiBBIGNyb3NzLXJlZmVyZW5jZSBjYW4gZGVjbGFyZSB0aGlzIGV4cHJlc3Npb24gZXhwbGljaXRseSBpbiB0aGUgZm9ybSBgW1R5cGUgOiBUZXJtaW5hbF1gLCBidXQgaWYgYFRlcm1pbmFsYFxuICogaXMgb21pdHRlZCwgdGhpcyBmdW5jdGlvbiBhdHRlbXB0cyB0byBpbmZlciBpdCBmcm9tIHRoZSBuYW1lIG9mIHRoZSByZWZlcmVuY2VkIGBUeXBlYCAodXNpbmcgYGZpbmROYW1lQXNzaWdubWVudGApLlxuICpcbiAqIFJldHVybnMgdGhlIGdyYW1tYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHBhcnNlIHRoZSBnaXZlbiBjcm9zcy1yZWZlcmVuY2UsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGlzIG5vdCBkZWNsYXJlZFxuICogYW5kIGNhbm5vdCBiZSBpbmZlcnJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyb3NzUmVmZXJlbmNlVGVybWluYWwoY3Jvc3NSZWYpIHtcbiAgICBpZiAoY3Jvc3NSZWYudGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIGNyb3NzUmVmLnRlcm1pbmFsO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcm9zc1JlZi50eXBlLnJlZikge1xuICAgICAgICBjb25zdCBuYW1lQXNzaWdtZW50ID0gZmluZE5hbWVBc3NpZ25tZW50KGNyb3NzUmVmLnR5cGUucmVmKTtcbiAgICAgICAgcmV0dXJuIG5hbWVBc3NpZ21lbnQgPT09IG51bGwgfHwgbmFtZUFzc2lnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmFtZUFzc2lnbWVudC50ZXJtaW5hbDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB0ZXJtaW5hbCBydWxlIHJlcHJlc2VudHMgYSBjb21tZW50LiBUaGlzIGlzIHRydWUgaWYgdGhlIHJ1bGUgaXMgbWFya2VkXG4gKiBhcyBgaGlkZGVuYCBhbmQgaXQgZG9lcyBub3QgbWF0Y2ggd2hpdGUgc3BhY2UuIFRoaXMgbWVhbnMgZXZlcnkgaGlkZGVuIHRva2VuIChpLmUuIGV4Y2x1ZGVkIGZyb20gdGhlIEFTVClcbiAqIHRoYXQgY29udGFpbnMgdmlzaWJsZSBjaGFyYWN0ZXJzIGlzIGNvbnNpZGVyZWQgYSBjb21tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb21tZW50VGVybWluYWwodGVybWluYWxSdWxlKSB7XG4gICAgcmV0dXJuIHRlcm1pbmFsUnVsZS5oaWRkZW4gJiYgIWlzV2hpdGVzcGFjZSh0ZXJtaW5hbFJlZ2V4KHRlcm1pbmFsUnVsZSkpO1xufVxuLyoqXG4gKiBGaW5kIGFsbCBDU1Qgbm9kZXMgd2l0aGluIHRoZSBnaXZlbiBub2RlIHRoYXQgY29udHJpYnV0ZSB0byB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBub2RlIEEgQ1NUIG5vZGUgaW4gd2hpY2ggdG8gbG9vayBmb3IgcHJvcGVydHkgYXNzaWdubWVudHMuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IGFycmF5LlxuICogQHBhcmFtIHByb3BlcnR5IEEgcHJvcGVydHkgbmFtZSBvZiB0aGUgY29uc3RydWN0ZWQgQVNUIG5vZGUuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVzRm9yUHJvcGVydHkobm9kZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoIW5vZGUgfHwgIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmROb2Rlc0ZvclByb3BlcnR5SW50ZXJuYWwobm9kZSwgcHJvcGVydHksIG5vZGUuYXN0Tm9kZSwgdHJ1ZSk7XG59XG4vKipcbiAqIEZpbmQgYSBzaW5nbGUgQ1NUIG5vZGUgd2l0aGluIHRoZSBnaXZlbiBub2RlIHRoYXQgY29udHJpYnV0ZXMgdG8gdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBIENTVCBub2RlIGluIHdoaWNoIHRvIGxvb2sgZm9yIHByb3BlcnR5IGFzc2lnbm1lbnRzLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBwcm9wZXJ0eSBBIHByb3BlcnR5IG5hbWUgb2YgdGhlIGNvbnN0cnVjdGVkIEFTVCBub2RlLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBpbmRleCBJZiBubyBpbmRleCBpcyBzcGVjaWZpZWQgb3IgdGhlIGluZGV4IGlzIGxlc3MgdGhhbiB6ZXJvLCB0aGUgZmlyc3QgZm91bmQgbm9kZSBpcyByZXR1cm5lZC4gSWYgdGhlXG4gKiAgICAgICAgc3BlY2lmaWVkIGluZGV4IGV4Y2VlZHMgdGhlIG51bWJlciBvZiBhc3NpZ25tZW50cyB0byB0aGUgcHJvcGVydHksIHRoZSBsYXN0IGZvdW5kIG5vZGUgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSxcbiAqICAgICAgICB0aGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZUZvclByb3BlcnR5KG5vZGUsIHByb3BlcnR5LCBpbmRleCkge1xuICAgIGlmICghbm9kZSB8fCAhcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBmaW5kTm9kZXNGb3JQcm9wZXJ0eUludGVybmFsKG5vZGUsIHByb3BlcnR5LCBub2RlLmFzdE5vZGUsIHRydWUpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbm9kZXMubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbaW5kZXhdO1xufVxuZnVuY3Rpb24gZmluZE5vZGVzRm9yUHJvcGVydHlJbnRlcm5hbChub2RlLCBwcm9wZXJ0eSwgZWxlbWVudCwgZmlyc3QpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVGZWF0dXJlID0gZ2V0Q29udGFpbmVyT2ZUeXBlKG5vZGUuZ3JhbW1hclNvdXJjZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIGlmIChub2RlRmVhdHVyZSAmJiBub2RlRmVhdHVyZS5mZWF0dXJlID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpICYmIG5vZGUuYXN0Tm9kZSA9PT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50LmZsYXRNYXAoZSA9PiBmaW5kTm9kZXNGb3JQcm9wZXJ0eUludGVybmFsKGUsIHByb3BlcnR5LCBlbGVtZW50LCBmYWxzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4vKipcbiAqIEZpbmQgYWxsIENTVCBub2RlcyB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBIENTVCBub2RlIGluIHdoaWNoIHRvIGxvb2sgZm9yIGtleXdvcmRzLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBhbiBlbXB0eSBhcnJheS5cbiAqIEBwYXJhbSBrZXl3b3JkIEEga2V5d29yZCBhcyBzcGVjaWZpZWQgaW4gdGhlIGdyYW1tYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZXNGb3JLZXl3b3JkKG5vZGUsIGtleXdvcmQpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZmluZE5vZGVzRm9yS2V5d29yZEludGVybmFsKG5vZGUsIGtleXdvcmQsIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5hc3ROb2RlKTtcbn1cbi8qKlxuICogRmluZCBhIHNpbmdsZSBDU1Qgbm9kZSB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIG5vZGUgQSBDU1Qgbm9kZSBpbiB3aGljaCB0byBsb29rIGZvciBrZXl3b3Jkcy4gSWYgdGhpcyBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgYHVuZGVmaW5lZGAuXG4gKiBAcGFyYW0ga2V5d29yZCBBIGtleXdvcmQgYXMgc3BlY2lmaWVkIGluIHRoZSBncmFtbWFyLlxuICogQHBhcmFtIGluZGV4IElmIG5vIGluZGV4IGlzIHNwZWNpZmllZCBvciB0aGUgaW5kZXggaXMgbGVzcyB0aGFuIHplcm8sIHRoZSBmaXJzdCBmb3VuZCBub2RlIGlzIHJldHVybmVkLiBJZiB0aGVcbiAqICAgICAgICBzcGVjaWZpZWQgaW5kZXggZXhjZWVkcyB0aGUgbnVtYmVyIG9mIGtleXdvcmQgb2NjdXJyZW5jZXMsIHRoZSBsYXN0IGZvdW5kIG5vZGUgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSxcbiAqICAgICAgICB0aGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZUZvcktleXdvcmQobm9kZSwga2V5d29yZCwgaW5kZXgpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBmaW5kTm9kZXNGb3JLZXl3b3JkSW50ZXJuYWwobm9kZSwga2V5d29yZCwgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmFzdE5vZGUpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbm9kZXMubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbaW5kZXhdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2Rlc0ZvcktleXdvcmRJbnRlcm5hbChub2RlLCBrZXl3b3JkLCBlbGVtZW50KSB7XG4gICAgaWYgKG5vZGUuYXN0Tm9kZSAhPT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhc3QuaXNLZXl3b3JkKG5vZGUuZ3JhbW1hclNvdXJjZSkgJiYgbm9kZS5ncmFtbWFyU291cmNlLnZhbHVlID09PSBrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGNvbnN0IHRyZWVJdGVyYXRvciA9IHN0cmVhbUNzdChub2RlKS5pdGVyYXRvcigpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3Qga2V5d29yZE5vZGVzID0gW107XG4gICAgZG8ge1xuICAgICAgICByZXN1bHQgPSB0cmVlSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmFzdE5vZGUgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0LmlzS2V5d29yZChjaGlsZE5vZGUuZ3JhbW1hclNvdXJjZSkgJiYgY2hpbGROb2RlLmdyYW1tYXJTb3VyY2UudmFsdWUgPT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlSXRlcmF0b3IucHJ1bmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKCFyZXN1bHQuZG9uZSk7XG4gICAgcmV0dXJuIGtleXdvcmROb2Rlcztcbn1cbi8qKlxuICogSWYgdGhlIGdpdmVuIENTVCBub2RlIHdhcyBwYXJzZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBwcm9wZXJ0eSBhc3NpZ25tZW50LCB0aGUgcmVzcGVjdGl2ZSBgQXNzaWdubWVudGAgZ3JhbW1hclxuICogbm9kZSBpcyByZXR1cm5lZC4gSWYgbm8gYXNzaWdubWVudCBpcyBmb3VuZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gY3N0Tm9kZSBBIENTVCBub2RlIGZvciB3aGljaCB0byBmaW5kIGEgcHJvcGVydHkgYXNzaWdubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBc3NpZ25tZW50KGNzdE5vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXN0Tm9kZSA9IGNzdE5vZGUuYXN0Tm9kZTtcbiAgICAvLyBPbmx5IHNlYXJjaCB1bnRpbCB0aGUgYXN0IG5vZGUgb2YgdGhlIHBhcmVudCBjc3Qgbm9kZSBpcyBubyBsb25nZXIgdGhlIG9yaWdpbmFsIGFzdCBub2RlXG4gICAgLy8gVGhpcyB3b3VsZCBtYWtlIHVzIGp1bXAgdG8gYSBwcmVjZWRpbmcgcnVsZSBjYWxsLCB3aGljaCBjb250YWlucyBvbmx5IHVucmVsYXRlZCBhc3NpZ25tZW50c1xuICAgIHdoaWxlIChhc3ROb2RlID09PSAoKF9hID0gY3N0Tm9kZS5jb250YWluZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hc3ROb2RlKSkge1xuICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0gZ2V0Q29udGFpbmVyT2ZUeXBlKGNzdE5vZGUuZ3JhbW1hclNvdXJjZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzaWdubWVudDtcbiAgICAgICAgfVxuICAgICAgICBjc3ROb2RlID0gY3N0Tm9kZS5jb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEZpbmQgYW4gYXNzaWdubWVudCB0byB0aGUgYG5hbWVgIHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gZ3JhbW1hciB0eXBlLiBUaGlzIHJlcXVpcmVzIHRoZSBgdHlwZWAgdG8gYmUgaW5mZXJyZWRcbiAqIGZyb20gYSBwYXJzZXIgcnVsZSwgYW5kIHRoYXQgcnVsZSBtdXN0IGNvbnRhaW4gYW4gYXNzaWdubWVudCB0byB0aGUgYG5hbWVgIHByb3BlcnR5LiBJbiBhbGwgb3RoZXIgY2FzZXMsXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTmFtZUFzc2lnbm1lbnQodHlwZSkge1xuICAgIGxldCBzdGFydE5vZGUgPSB0eXBlO1xuICAgIGlmIChhc3QuaXNJbmZlcnJlZFR5cGUoc3RhcnROb2RlKSkge1xuICAgICAgICAvLyBmb3IgaW5mZXJyZWQgdHlwZXMsIHRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZm9yIHRoZSBuYW1lLWFzc2lnbm1lbnQgaXMgZGlmZmVyZW50XG4gICAgICAgIGlmIChhc3QuaXNBY3Rpb24oc3RhcnROb2RlLiRjb250YWluZXIpKSB7XG4gICAgICAgICAgICAvLyBhIHR5cGUgd2hpY2ggaXMgZXhwbGljaXRseSBpbmZlcnJlZCBieSBhbiBhY3Rpb246IGludmVzdGlnYXRlIHRoZSBzaWJibGluZyBvZiB0aGUgQWN0aW9uIG5vZGUsIGkuZS4gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBBY3Rpb24ncyBwYXJlbnRcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS4kY29udGFpbmVyLiRjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzUGFyc2VyUnVsZShzdGFydE5vZGUuJGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIC8vIGludmVzdGlnYXRlIHRoZSBwYXJzZXIgcnVsZSB3aXRoIHRoZSBleHBsaWNpdGx5IGluZmVycmVkIHR5cGVcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS4kY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoc3RhcnROb2RlLiRjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbCh0eXBlLCBzdGFydE5vZGUsIG5ldyBNYXAoKSk7XG59XG5mdW5jdGlvbiBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbCh0eXBlLCBzdGFydE5vZGUsIGNhY2hlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHRoZSBjYWNoZSBpcyBvbmx5IHJlcXVpcmVkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICBmdW5jdGlvbiBnbyhub2RlLCByZWZUeXBlKSB7XG4gICAgICAgIGxldCBjaGlsZEFzc2lnbm1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcmVudEFzc2lnbm1lbnQgPSBnZXRDb250YWluZXJPZlR5cGUobm9kZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIC8vIE5vIHBhcmVudCBhc3NpZ25tZW50IGltcGxpZXMgdW5hc3NpZ25lZCBydWxlIGNhbGxcbiAgICAgICAgaWYgKCFwYXJlbnRBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBjaGlsZEFzc2lnbm1lbnQgPSBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbChyZWZUeXBlLCByZWZUeXBlLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KHR5cGUsIGNoaWxkQXNzaWdubWVudCk7XG4gICAgICAgIHJldHVybiBjaGlsZEFzc2lnbm1lbnQ7XG4gICAgfVxuICAgIGlmIChjYWNoZS5oYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldCh0eXBlKTtcbiAgICB9XG4gICAgY2FjaGUuc2V0KHR5cGUsIHVuZGVmaW5lZCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHN0cmVhbUFsbENvbnRlbnRzKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgaWYgKGFzdC5pc0Fzc2lnbm1lbnQobm9kZSkgJiYgbm9kZS5mZWF0dXJlLnRvTG93ZXJDYXNlKCkgPT09ICduYW1lJykge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHR5cGUsIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzUnVsZUNhbGwobm9kZSkgJiYgYXN0LmlzUGFyc2VyUnVsZShub2RlLnJ1bGUucmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdvKG5vZGUsIG5vZGUucnVsZS5yZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5pc1NpbXBsZVR5cGUobm9kZSkgJiYgKChfYSA9IG5vZGUudHlwZVJlZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBnbyhub2RlLCBub2RlLnR5cGVSZWYucmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvbkF0RWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC4kY29udGFpbmVyO1xuICAgIGlmIChhc3QuaXNHcm91cChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcGFyZW50LmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoYXN0LmlzQWN0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBzdHJlYW1BbGxDb250ZW50cyhlbGVtZW50c1tpXSkuZmluZChhc3QuaXNBY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzdC5pc0Fic3RyYWN0RWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3Rpb25BdEVsZW1lbnQocGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT3B0aW9uYWxDYXJkaW5hbGl0eShjYXJkaW5hbGl0eSwgZWxlbWVudCkge1xuICAgIHJldHVybiBjYXJkaW5hbGl0eSA9PT0gJz8nIHx8IGNhcmRpbmFsaXR5ID09PSAnKicgfHwgKGFzdC5pc0dyb3VwKGVsZW1lbnQpICYmIEJvb2xlYW4oZWxlbWVudC5ndWFyZENvbmRpdGlvbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlDYXJkaW5hbGl0eShjYXJkaW5hbGl0eSkge1xuICAgIHJldHVybiBjYXJkaW5hbGl0eSA9PT0gJyonIHx8IGNhcmRpbmFsaXR5ID09PSAnKyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSAnKz0nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHBhcnNlciBydWxlIGlzIGEgX2RhdGEgdHlwZSBydWxlXywgbWVhbmluZyB0aGF0IGl0IGhhcyBhXG4gKiBwcmltaXRpdmUgcmV0dXJuIHR5cGUgbGlrZSBgbnVtYmVyYCwgYGJvb2xlYW5gLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFUeXBlUnVsZShydWxlKSB7XG4gICAgcmV0dXJuIGlzRGF0YVR5cGVSdWxlSW50ZXJuYWwocnVsZSwgbmV3IFNldCgpKTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVR5cGVSdWxlSW50ZXJuYWwocnVsZSwgdmlzaXRlZCkge1xuICAgIGlmICh2aXNpdGVkLmhhcyhydWxlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKHJ1bGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3RyZWFtQWxsQ29udGVudHMocnVsZSkpIHtcbiAgICAgICAgaWYgKGFzdC5pc1J1bGVDYWxsKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUucnVsZS5yZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBSdWxlQ2FsbCB0byB1bnJlc29sdmVkIHJ1bGUuIERvbid0IGFzc3VtZSBgcnVsZWAgaXMgYSBEYXRhVHlwZSBydWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3QuaXNQYXJzZXJSdWxlKG5vZGUucnVsZS5yZWYpICYmICFpc0RhdGFUeXBlUnVsZUludGVybmFsKG5vZGUucnVsZS5yZWYsIHZpc2l0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5pc0Fzc2lnbm1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuaXNBY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihydWxlLmRlZmluaXRpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVR5cGUodHlwZSkge1xuICAgIHJldHVybiBpc0RhdGFUeXBlSW50ZXJuYWwodHlwZS50eXBlLCBuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gaXNEYXRhVHlwZUludGVybmFsKHR5cGUsIHZpc2l0ZWQpIHtcbiAgICBpZiAodmlzaXRlZC5oYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXNpdGVkLmFkZCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKGFzdC5pc0FycmF5VHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1JlZmVyZW5jZVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudHlwZXMuZXZlcnkoZSA9PiBpc0RhdGFUeXBlSW50ZXJuYWwoZSwgdmlzaXRlZCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgICAgIGlmICh0eXBlLnByaW1pdGl2ZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS5zdHJpbmdUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUudHlwZVJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0eXBlLnR5cGVSZWYucmVmO1xuICAgICAgICAgICAgaWYgKGFzdC5pc1R5cGUocmVmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RhdGFUeXBlSW50ZXJuYWwocmVmLnR5cGUsIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSkge1xuICAgIGlmIChydWxlLmluZmVycmVkVHlwZSkge1xuICAgICAgICByZXR1cm4gcnVsZS5pbmZlcnJlZFR5cGUubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocnVsZS5kYXRhVHlwZSkge1xuICAgICAgICByZXR1cm4gcnVsZS5kYXRhVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocnVsZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNvbnN0IHJlZlR5cGUgPSBydWxlLnJldHVyblR5cGUucmVmO1xuICAgICAgICBpZiAocmVmVHlwZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBjaGVjayBBY3Rpb24gYXMgcmV0dXJuIHR5cGVcbiAgICAgICAgICAgIGlmIChhc3QuaXNQYXJzZXJSdWxlKHJlZlR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZlR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFzdC5pc0ludGVyZmFjZShyZWZUeXBlKSB8fCBhc3QuaXNUeXBlKHJlZlR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZlR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVOYW1lKHR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGFzdC5pc1BhcnNlclJ1bGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0YVR5cGVSdWxlKHR5cGUpID8gdHlwZS5uYW1lIDogKF9hID0gZ2V0RXhwbGljaXRSdWxlVHlwZSh0eXBlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNJbnRlcmZhY2UodHlwZSkgfHwgYXN0LmlzVHlwZSh0eXBlKSB8fCBhc3QuaXNSZXR1cm5UeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0FjdGlvbih0eXBlKSkge1xuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZSh0eXBlKTtcbiAgICAgICAgaWYgKGFjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25UeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0luZmVycmVkVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgbmFtZSBvZiBVbmtub3duIFR5cGUnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3Rpb25UeXBlKGFjdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYWN0aW9uLmluZmVycmVkVHlwZSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmluZmVycmVkVHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2EgPSBhY3Rpb24udHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZikge1xuICAgICAgICByZXR1cm4gZ2V0VHlwZU5hbWUoYWN0aW9uLnR5cGUucmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gbm90IGluZmVycmluZyBhbmQgbm90IHJlZmVyZW5jaW5nIGEgdmFsaWQgdHlwZVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXQgZGV2ZWxvcG1lbnQgdGltZSAoZm9yIGNvZGUgZ2VuZXJhdGlvbiBhbmQgdGhlIGludGVybmFsIHR5cGUgc3lzdGVtKSB0byBnZXQgdGhlIHR5cGUgb2YgdGhlIEFTVCBub2RlIHByb2R1Y2VkIGJ5IHRoZSBnaXZlbiBydWxlLlxuICogRm9yIGRhdGEgdHlwZSBydWxlcywgdGhlIG5hbWUgb2YgdGhlIHJ1bGUgaXMgcmV0dXJuZWQsXG4gKiBlLmcuIFwiSU5UX3ZhbHVlIHJldHVybnMgbnVtYmVyOiBNWV9JTlQ7XCIgcmV0dXJucyBcIklOVF92YWx1ZVwiLlxuICogQHBhcmFtIHJ1bGUgdGhlIGdpdmVuIHJ1bGVcbiAqIEByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBBU1Qgbm9kZSB0eXBlIG9mIHRoZSBydWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlVHlwZU5hbWUocnVsZSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChhc3QuaXNUZXJtaW5hbFJ1bGUocnVsZSkpIHtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHJ1bGUudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdzdHJpbmcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0YVR5cGVSdWxlKHJ1bGUpID8gcnVsZS5uYW1lIDogKF9jID0gZ2V0RXhwbGljaXRSdWxlVHlwZShydWxlKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcnVsZS5uYW1lO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGF0IHJ1bnRpbWUgdG8gZ2V0IHRoZSBhY3R1YWwgdHlwZSBvZiB0aGUgdmFsdWVzIHByb2R1Y2VkIGJ5IHRoZSBnaXZlbiBydWxlIGF0IHJ1bnRpbWUuXG4gKiBGb3IgZGF0YSB0eXBlIHJ1bGVzLCB0aGUgbmFtZSBvZiB0aGUgZGVjbGFyZWQgcmV0dXJuIHR5cGUgb2YgdGhlIHJ1bGUgaXMgcmV0dXJuZWQgKGlmIGFueSksXG4gKiBlLmcuIFwiSU5UX3ZhbHVlIHJldHVybnMgbnVtYmVyOiBNWV9JTlQ7XCIgcmV0dXJucyBcIm51bWJlclwiLlxuICogQHBhcmFtIHJ1bGUgdGhlIGdpdmVuIHJ1bGVcbiAqIEByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlIG9mIHRoZSBwcm9kdWNlZCB2YWx1ZXMgb2YgdGhlIHJ1bGUgYXQgcnVudGltZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVsZVR5cGUocnVsZSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChhc3QuaXNUZXJtaW5hbFJ1bGUocnVsZSkpIHtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHJ1bGUudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdzdHJpbmcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChfYyA9IGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHJ1bGUubmFtZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdGVybWluYWxSZWdleCh0ZXJtaW5hbFJ1bGUpIHtcbiAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgczogZmFsc2UsXG4gICAgICAgIGk6IGZhbHNlLFxuICAgICAgICB1OiBmYWxzZVxuICAgIH07XG4gICAgY29uc3Qgc291cmNlID0gYWJzdHJhY3RFbGVtZW50VG9SZWdleCh0ZXJtaW5hbFJ1bGUuZGVmaW5pdGlvbiwgZmxhZ3MpO1xuICAgIGNvbnN0IGZsYWdUZXh0ID0gT2JqZWN0LmVudHJpZXMoZmxhZ3MpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSkubWFwKChbbmFtZV0pID0+IG5hbWUpLmpvaW4oJycpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgZmxhZ1RleHQpO1xufVxuLy8gVXNpbmcgW1xcc1xcU10qIGFsbG93cyB0byBtYXRjaCBldmVyeXRoaW5nLCBjb21wYXJlZCB0byAuIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggbGluZSB0ZXJtaW5hdG9yc1xuY29uc3QgV0lMRENBUkQgPSAvW1xcc1xcU10vLnNvdXJjZTtcbmZ1bmN0aW9uIGFic3RyYWN0RWxlbWVudFRvUmVnZXgoZWxlbWVudCwgZmxhZ3MpIHtcbiAgICBpZiAoYXN0LmlzVGVybWluYWxBbHRlcm5hdGl2ZXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRlcm1pbmFsQWx0ZXJuYXRpdmVzVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzVGVybWluYWxHcm91cChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdGVybWluYWxHcm91cFRvUmVnZXgoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0NoYXJhY3RlclJhbmdlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJSYW5nZVRvUmVnZXgoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1Rlcm1pbmFsUnVsZUNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IGVsZW1lbnQucnVsZS5yZWY7XG4gICAgICAgIGlmICghcnVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJ1bGUgcmVmZXJlbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYWJzdHJhY3RFbGVtZW50VG9SZWdleChydWxlLmRlZmluaXRpb24pLCB7XG4gICAgICAgICAgICBjYXJkaW5hbGl0eTogZWxlbWVudC5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogZWxlbWVudC5sb29rYWhlYWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc05lZ2F0ZWRUb2tlbihlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gbmVnYXRlVG9rZW5Ub1JlZ2V4KGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNVbnRpbFRva2VuKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB1bnRpbFRva2VuVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzUmVnZXhUb2tlbihlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBlbGVtZW50LnJlZ2V4Lmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGVsZW1lbnQucmVnZXguc3Vic3RyaW5nKDEsIGxhc3RTbGFzaCk7XG4gICAgICAgIGNvbnN0IHJlZ2V4RmxhZ3MgPSBlbGVtZW50LnJlZ2V4LnN1YnN0cmluZyhsYXN0U2xhc2ggKyAxKTtcbiAgICAgICAgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgICBmbGFncy5pID0gcmVnZXhGbGFncy5pbmNsdWRlcygnaScpO1xuICAgICAgICAgICAgZmxhZ3MucyA9IHJlZ2V4RmxhZ3MuaW5jbHVkZXMoJ3MnKTtcbiAgICAgICAgICAgIGZsYWdzLnUgPSByZWdleEZsYWdzLmluY2x1ZGVzKCd1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShzb3VyY2UsIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiBlbGVtZW50LmNhcmRpbmFsaXR5LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBlbGVtZW50Lmxvb2thaGVhZCxcbiAgICAgICAgICAgIHdyYXA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNXaWxkY2FyZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KFdJTERDQVJELCB7XG4gICAgICAgICAgICBjYXJkaW5hbGl0eTogZWxlbWVudC5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogZWxlbWVudC5sb29rYWhlYWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVybWluYWwgZWxlbWVudDogJHtlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuJHR5cGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGVybWluYWxBbHRlcm5hdGl2ZXNUb1JlZ2V4KGFsdGVybmF0aXZlcykge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYWx0ZXJuYXRpdmVzLmVsZW1lbnRzLm1hcChlID0+IGFic3RyYWN0RWxlbWVudFRvUmVnZXgoZSkpLmpvaW4oJ3wnKSwge1xuICAgICAgICBjYXJkaW5hbGl0eTogYWx0ZXJuYXRpdmVzLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IGFsdGVybmF0aXZlcy5sb29rYWhlYWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRlcm1pbmFsR3JvdXBUb1JlZ2V4KGdyb3VwKSB7XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShncm91cC5lbGVtZW50cy5tYXAoZSA9PiBhYnN0cmFjdEVsZW1lbnRUb1JlZ2V4KGUpKS5qb2luKCcnKSwge1xuICAgICAgICBjYXJkaW5hbGl0eTogZ3JvdXAuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogZ3JvdXAubG9va2FoZWFkXG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bnRpbFRva2VuVG9SZWdleCh1bnRpbCkge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYCR7V0lMRENBUkR9Kj8ke2Fic3RyYWN0RWxlbWVudFRvUmVnZXgodW50aWwudGVybWluYWwpfWAsIHtcbiAgICAgICAgY2FyZGluYWxpdHk6IHVudGlsLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IHVudGlsLmxvb2thaGVhZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbmVnYXRlVG9rZW5Ub1JlZ2V4KG5lZ2F0ZSkge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYCg/ISR7YWJzdHJhY3RFbGVtZW50VG9SZWdleChuZWdhdGUudGVybWluYWwpfSkke1dJTERDQVJEfSo/YCwge1xuICAgICAgICBjYXJkaW5hbGl0eTogbmVnYXRlLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IG5lZ2F0ZS5sb29rYWhlYWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlclJhbmdlVG9SZWdleChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5yaWdodCkge1xuICAgICAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KGBbJHtrZXl3b3JkVG9SZWdleChyYW5nZS5sZWZ0KX0tJHtrZXl3b3JkVG9SZWdleChyYW5nZS5yaWdodCl9XWAsIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiByYW5nZS5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogcmFuZ2UubG9va2FoZWFkLFxuICAgICAgICAgICAgd3JhcDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoa2V5d29yZFRvUmVnZXgocmFuZ2UubGVmdCksIHtcbiAgICAgICAgY2FyZGluYWxpdHk6IHJhbmdlLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IHJhbmdlLmxvb2thaGVhZCxcbiAgICAgICAgd3JhcDogZmFsc2VcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGtleXdvcmRUb1JlZ2V4KGtleXdvcmQpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVnRXhwKGtleXdvcmQudmFsdWUpO1xufVxuZnVuY3Rpb24gd2l0aENhcmRpbmFsaXR5KHJlZ2V4LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRpb25zLndyYXAgIT09IGZhbHNlIHx8IG9wdGlvbnMubG9va2FoZWFkKSB7XG4gICAgICAgIHJlZ2V4ID0gYCgkeyhfYSA9IG9wdGlvbnMubG9va2FoZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJ30ke3JlZ2V4fSlgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jYXJkaW5hbGl0eSkge1xuICAgICAgICByZXR1cm4gYCR7cmVnZXh9JHtvcHRpb25zLmNhcmRpbmFsaXR5fWA7XG4gICAgfVxuICAgIHJldHVybiByZWdleDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYW1tYXItdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/promise-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/utils/promise-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   OperationCancelled: () => (/* binding */ OperationCancelled),\n/* harmony export */   delayNextTick: () => (/* binding */ delayNextTick),\n/* harmony export */   interruptAndCheck: () => (/* binding */ interruptAndCheck),\n/* harmony export */   isOperationCancelled: () => (/* binding */ isOperationCancelled),\n/* harmony export */   setInterruptionPeriod: () => (/* binding */ setInterruptionPeriod),\n/* harmony export */   startCancelableOperation: () => (/* binding */ startCancelableOperation)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\n */\nfunction delayNextTick() {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === 'undefined') {\n            setTimeout(resolve, 0);\n        }\n        else {\n            setImmediate(resolve);\n        }\n    });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nfunction startCancelableOperation() {\n    lastTick = performance.now();\n    return new _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();\n}\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nfunction setInterruptionPeriod(period) {\n    globalInterruptionPeriod = period;\n}\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nconst OperationCancelled = Symbol('OperationCancelled');\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nfunction isOperationCancelled(err) {\n    return err === OperationCancelled;\n}\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nasync function interruptAndCheck(token) {\n    if (token === _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = performance.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n        // prevent calling delayNextTick every iteration of loop\n        // where delayNextTick takes up the majority or all of the\n        // globalInterruptionPeriod itself\n        lastTick = performance.now();\n    }\n    if (token.isCancellationRequested) {\n        throw OperationCancelled;\n    }\n}\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (arg) => {\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err) => {\n                reject(err);\n                return this;\n            };\n        });\n    }\n}\n//# sourceMappingURL=promise-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvcHJvbWlzZS11dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSwyRUFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLHFFQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXHByb21pc2UtdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4sIENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgdGhlIGN1cnJlbnQgY29kZSB0byB0aGUgbmV4dCB0aWNrIG9mIHRoZSBldmVudCBsb29wLlxuICogRG9uJ3QgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSBpbiBhIHRpZ2h0IGxvb3AgdG8gcHJldmVudCB0b28gbWFueSBwcm9taXNlcyBmcm9tIGJlaW5nIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxheU5leHRUaWNrKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgLy8gSW4gY2FzZSB3ZSBhcmUgcnVubmluZyBpbiBhIG5vbi1ub2RlIGVudmlyb25tZW50LCBgc2V0SW1tZWRpYXRlYCBpc24ndCBhdmFpbGFibGUuXG4gICAgICAgIC8vIFVzaW5nIGBzZXRUaW1lb3V0YCBvZiB0aGUgYnJvd3NlciBBUEkgYWNjb21wbGlzaGVzIHRoZSBzYW1lIHJlc3VsdC5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5sZXQgbGFzdFRpY2sgPSAwO1xubGV0IGdsb2JhbEludGVycnVwdGlvblBlcmlvZCA9IDEwO1xuLyoqXG4gKiBSZXNldCB0aGUgZ2xvYmFsIGludGVycnVwdGlvbiBwZXJpb2QgYW5kIGNyZWF0ZSBhIGNhbmNlbGxhdGlvbiB0b2tlbiBzb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydENhbmNlbGFibGVPcGVyYXRpb24oKSB7XG4gICAgbGFzdFRpY2sgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICByZXR1cm4gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG59XG4vKipcbiAqIENoYW5nZSB0aGUgcGVyaW9kIGR1cmF0aW9uIGZvciBgaW50ZXJydXB0QW5kQ2hlY2tgIHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgMTBtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEludGVycnVwdGlvblBlcmlvZChwZXJpb2QpIHtcbiAgICBnbG9iYWxJbnRlcnJ1cHRpb25QZXJpb2QgPSBwZXJpb2Q7XG59XG4vKipcbiAqIFRoaXMgc3ltYm9sIG1heSBiZSB0aHJvd24gaW4gYW4gYXN5bmNocm9ub3VzIGNvbnRleHQgYnkgYW55IExhbmdpdW0gc2VydmljZSB0aGF0IHJlY2VpdmVzXG4gKiBhIGBDYW5jZWxsYXRpb25Ub2tlbmAuIFRoaXMgbWVhbnMgdGhhdCB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSBzdWNoIGEgc2VydmljZSBpcyByZWplY3RlZCB3aXRoXG4gKiB0aGlzIHN5bWJvbCBhcyByZWplY3Rpb24gcmVhc29uLlxuICovXG5leHBvcnQgY29uc3QgT3BlcmF0aW9uQ2FuY2VsbGVkID0gU3ltYm9sKCdPcGVyYXRpb25DYW5jZWxsZWQnKTtcbi8qKlxuICogVXNlIHRoaXMgaW4gYSBgY2F0Y2hgIGJsb2NrIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHRocm93biBvYmplY3QgaW5kaWNhdGVzIHRoYXQgdGhlIG9wZXJhdGlvblxuICogaGFzIGJlZW4gY2FuY2VsbGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYXRpb25DYW5jZWxsZWQoZXJyKSB7XG4gICAgcmV0dXJuIGVyciA9PT0gT3BlcmF0aW9uQ2FuY2VsbGVkO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgdHdvIHRoaW5nczpcbiAqICAxLiBDaGVjayB0aGUgZWxhcHNlZCB0aW1lIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhpcyBmdW5jdGlvbiBvciB0byBgc3RhcnRDYW5jZWxhYmxlT3BlcmF0aW9uYC4gSWYgdGhlIHByZWRlZmluZWRcbiAqICAgICBwZXJpb2QgKGNvbmZpZ3VyZWQgd2l0aCBgc2V0SW50ZXJydXB0aW9uUGVyaW9kYCkgaXMgZXhjZWVkZWQsIGV4ZWN1dGlvbiBpcyBkZWxheWVkIHdpdGggYGRlbGF5TmV4dFRpY2tgLlxuICogIDIuIElmIHRoZSBwcmVkZWZpbmVkIHBlcmlvZCBpcyBub3QgbWV0IHlldCBvciBleGVjdXRpb24gaXMgcmVzdW1lZCBhZnRlciBhbiBpbnRlcnJ1cHRpb24sIHRoZSBnaXZlbiBjYW5jZWxsYXRpb25cbiAqICAgICB0b2tlbiBpcyBjaGVja2VkLCBhbmQgaWYgY2FuY2VsbGF0aW9uIGlzIHJlcXVlc3RlZCwgYE9wZXJhdGlvbkNhbmNlbGVkYCBpcyB0aHJvd24uXG4gKlxuICogQWxsIHNlcnZpY2VzIGluIExhbmdpdW0gdGhhdCByZWNlaXZlIGEgYENhbmNlbGxhdGlvblRva2VuYCBtYXkgcG90ZW50aWFsbHkgY2FsbCB0aGlzIGZ1bmN0aW9uLCBzbyB0aGVcbiAqIGBDYW5jZWxsYXRpb25Ub2tlbmAgbXVzdCBiZSBjYXVnaHQgKHdpdGggYW4gYGFzeW5jYCB0cnktY2F0Y2ggYmxvY2sgb3IgYSBgY2F0Y2hgIGNhbGxiYWNrIGF0dGFjaGVkIHRvXG4gKiB0aGUgcHJvbWlzZSkgdG8gYXZvaWQgdGhhdCBldmVudCBiZWluZyBleHBvc2VkIGFzIGFuIGVycm9yLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW50ZXJydXB0QW5kQ2hlY2sodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgLy8gRWFybHkgZXhpdCBpbiBjYXNlIGNhbmNlbGxhdGlvbiB3YXMgZGlzYWJsZWQgYnkgdGhlIGNhbGxlclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoY3VycmVudCAtIGxhc3RUaWNrID49IGdsb2JhbEludGVycnVwdGlvblBlcmlvZCkge1xuICAgICAgICBsYXN0VGljayA9IGN1cnJlbnQ7XG4gICAgICAgIGF3YWl0IGRlbGF5TmV4dFRpY2soKTtcbiAgICAgICAgLy8gcHJldmVudCBjYWxsaW5nIGRlbGF5TmV4dFRpY2sgZXZlcnkgaXRlcmF0aW9uIG9mIGxvb3BcbiAgICAgICAgLy8gd2hlcmUgZGVsYXlOZXh0VGljayB0YWtlcyB1cCB0aGUgbWFqb3JpdHkgb3IgYWxsIG9mIHRoZVxuICAgICAgICAvLyBnbG9iYWxJbnRlcnJ1cHRpb25QZXJpb2QgaXRzZWxmXG4gICAgICAgIGxhc3RUaWNrID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIGlmICh0b2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xuICAgICAgICB0aHJvdyBPcGVyYXRpb25DYW5jZWxsZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBTaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGRlZmVycmVkIHBhdHRlcm4uXG4gKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIGEgcHJvbWlzZSBhbmQgZnVuY3Rpb25zIHRvIHJlc29sdmUgYW5kIHJlamVjdCBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYXJnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UtdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/promise-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/regexp-utils.js":
/*!********************************************************!*\
  !*** ./node_modules/langium/lib/utils/regexp-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NEWLINE_REGEXP: () => (/* binding */ NEWLINE_REGEXP),\n/* harmony export */   escapeRegExp: () => (/* binding */ escapeRegExp),\n/* harmony export */   getCaseInsensitivePattern: () => (/* binding */ getCaseInsensitivePattern),\n/* harmony export */   getTerminalParts: () => (/* binding */ getTerminalParts),\n/* harmony export */   isMultilineComment: () => (/* binding */ isMultilineComment),\n/* harmony export */   isWhitespace: () => (/* binding */ isWhitespace),\n/* harmony export */   partialMatches: () => (/* binding */ partialMatches),\n/* harmony export */   partialRegExp: () => (/* binding */ partialRegExp),\n/* harmony export */   whitespaceCharacters: () => (/* binding */ whitespaceCharacters)\n/* harmony export */ });\n/* harmony import */ var _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/regexp-to-ast */ \"(ssr)/./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nconst NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.RegExpParser();\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor {\n    constructor() {\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join('');\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n    visitChildren(node) {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\nconst visitor = new TerminalRegExpVisitor();\nfunction getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    }\n    catch (_a) {\n        return [];\n    }\n}\nfunction isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n/**\n * A set of all characters that are considered whitespace by the '\\s' RegExp character class.\n * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\n */\nconst whitespaceCharacters = ('\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007' +\n    '\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').split('');\nfunction isWhitespace(value) {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return whitespaceCharacters.some((ws) => regexp.test(ws));\n}\nfunction escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, letter => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');\n}\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nfunction partialMatches(regex, input) {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nfunction partialRegExp(regex) {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process() {\n        let result = '', tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        function appendOptional(nbChars) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                }\n                                else {\n                                    appendOptional(6);\n                                }\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n                case '[':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n                case '|':\n                case '^':\n                case '$':\n                case '*':\n                case '+':\n                case '?':\n                    appendRaw(1);\n                    break;\n                case '{':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    }\n                    else {\n                        appendOptional(1);\n                    }\n                    break;\n                case '(':\n                    if (source[i + 1] === '?') {\n                        switch (source[i + 2]) {\n                            case ':':\n                                result += '(?:';\n                                i += 3;\n                                result += process() + '|$)';\n                                break;\n                            case '=':\n                                result += '(?=';\n                                i += 3;\n                                result += process() + ')';\n                                break;\n                            case '!':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case '<':\n                                switch (source[i + 3]) {\n                                    case '=':\n                                    case '!':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf('>', i) - i + 1);\n                                        result += process() + '|$)';\n                                        break;\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        appendRaw(1);\n                        result += process() + '|$)';\n                    }\n                    break;\n                case ')':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n        return result;\n    }\n    return new RegExp(process(), regex.flags);\n}\n//# sourceMappingURL=regexp-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvcmVnZXhwLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRFO0FBQ3JFO0FBQ1AseUJBQXlCLG1FQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdFQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLG1DQUFtQztBQUNuQztBQUNPO0FBQ1AsK0VBQStFLHFCQUFxQixFQUFFLHFCQUFxQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXHJlZ2V4cC11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBSZWdFeHBQYXJzZXIsIEJhc2VSZWdFeHBWaXNpdG9yIH0gZnJvbSAnQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdCc7XG5leHBvcnQgY29uc3QgTkVXTElORV9SRUdFWFAgPSAvXFxyP1xcbi9nbTtcbmNvbnN0IHJlZ2V4cFBhcnNlciA9IG5ldyBSZWdFeHBQYXJzZXIoKTtcbi8qKlxuICogVGhpcyBjbGFzcyBpcyBpbiBjaGFyZ2Ugb2YgaGV1cmlzdGljYWxseSBpZGVudGlmeWluZyBzdGFydC9lbmQgdG9rZW5zIG9mIHRlcm1pbmFscy5cbiAqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAqIDEuIFRyYXZlcnNlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaW4gdGhlIFwic3RhcnQgc3RhdGVcIlxuICogMi4gQWRkIGFueSBlbmNvdW50ZXJlZCBzZXRzL3NpbmdsZSBjaGFyYWN0ZXJzIHRvIHRoZSBcInN0YXJ0IHJlZ2V4cFwiXG4gKiAzLiBPbmNlIHdlIGVuY291bnRlciBhbnkgdmFyaWFibGUtbGVuZ3RoIGNvbnRlbnQgKGkuZS4gd2l0aCBxdWFudGlmaWVycyBzdWNoIGFzICsvPy8qKSwgd2UgZW50ZXIgdGhlIFwiZW5kIHN0YXRlXCJcbiAqIDQuIEluIHRoZSBlbmQgc3RhdGUsIGFueSBzZXRzL3NpbmdsZSBjaGFyYWN0ZXJzIGFyZSBhZGRlZCB0byBhbiBcImVuZCBzdGFja1wiLlxuICogNS4gSWYgd2UgcmUtZW5jb3VudGVyIGFueSB2YXJpYWJsZS1sZW5ndGggY29udGVudCB3ZSByZXNldCB0aGUgZW5kIHN0YWNrXG4gKiA2LiBXZSBjb250aW51ZSB2aXNpdGluZyB0aGUgcmVnZXggdW50aWwgdGhlIGVuZCwgcmVzZXRpbmcgdGhlIGVuZCBzdGFjayBhbmQgcmVidWlsZGluZyBpdCBhcyBuZWNlc3NhcnlcbiAqXG4gKiBBZnRlciB0cmF2ZXJzaW5nIGEgcmVndWxhciBleHByZXNzaW9uIHRoZSBgc3RhcnRSZWdleHAvZW5kUmVnZXhwYCBwcm9wZXJ0aWVzIGFsbG93IGFjY2VzcyB0byB0aGUgc3RvcmVkIHN0YXJ0L2VuZCBvZiB0aGUgdGVybWluYWxcbiAqL1xuY2xhc3MgVGVybWluYWxSZWdFeHBWaXNpdG9yIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBlbmRSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUmVnZXhwU3RhY2suam9pbignJyk7XG4gICAgfVxuICAgIHJlc2V0KHJlZ2V4KSB7XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCA9ICcnO1xuICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgfVxuICAgIHZpc2l0R3JvdXAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdENoYXJhY3Rlcihub2RlKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlsaW5lICYmIGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucXVhbnRpZmllcikge1xuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVJlZ0V4cChjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sucHVzaChlc2NhcGVkQ2hhcik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCArPSBlc2NhcGVkQ2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFNldChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldCA9IHRoaXMucmVnZXguc3Vic3RyaW5nKG5vZGUubG9jLmJlZ2luLCBub2RlLmxvYy5lbmQpO1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNldCk7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZSA9IEJvb2xlYW4oJ1xcbicubWF0Y2gocmVnZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNldCA9IHRoaXMucmVnZXguc3Vic3RyaW5nKG5vZGUubG9jLmJlZ2luLCBub2RlLmxvYy5lbmQpO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWdleHBTdGFjay5wdXNoKHNldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCArPSBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdHcm91cCcpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBjaGlsZHJlbiBvZiBncm91cHMgd2l0aCBxdWFudGlmaWVyICgrLyovPylcbiAgICAgICAgICAgIC8vIFRoZXNlIGdyb3VwcyBhcmUgdW5yZWxhdGVkIHRvIHN0YXJ0L2VuZCB0b2tlbnMgb2YgdGVybWluYWxzXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoZ3JvdXAucXVhbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH1cbn1cbmNvbnN0IHZpc2l0b3IgPSBuZXcgVGVybWluYWxSZWdFeHBWaXNpdG9yKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVybWluYWxQYXJ0cyhyZWdleHApIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZ2V4cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlZ2V4cCA9IHJlZ2V4cC5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVnZXhwID0gYC8ke3JlZ2V4cH0vYDtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlZ2V4cFBhcnNlci5wYXR0ZXJuKHJlZ2V4cCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYWx0ZXJuYXRpdmUgb2YgcGF0dGVybi52YWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgdmlzaXRvci5yZXNldChyZWdleHApO1xuICAgICAgICAgICAgdmlzaXRvci52aXNpdChhbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogdmlzaXRvci5zdGFydFJlZ2V4cCxcbiAgICAgICAgICAgICAgICBlbmQ6IHZpc2l0b3IuZW5kUmVnZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNdWx0aWxpbmVDb21tZW50KHJlZ2V4cCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVnZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2V4cCA9IHJlZ2V4cC50b1N0cmluZygpO1xuICAgICAgICB2aXNpdG9yLnJlc2V0KHJlZ2V4cCk7XG4gICAgICAgIC8vIFBhcnNpbmcgdGhlIHBhdHRlcm4gbWlnaHQgZmFpbCAoc2luY2UgaXQncyB1c2VyIGNvZGUpXG4gICAgICAgIHZpc2l0b3IudmlzaXQocmVnZXhwUGFyc2VyLnBhdHRlcm4ocmVnZXhwKSk7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLm11bHRpbGluZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2V0IG9mIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNvbnNpZGVyZWQgd2hpdGVzcGFjZSBieSB0aGUgJ1xccycgUmVnRXhwIGNoYXJhY3RlciBjbGFzcy5cbiAqIFRha2VuIGZyb20gW01ETl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX2V4cHJlc3Npb25zL0NoYXJhY3Rlcl9jbGFzc2VzKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VDaGFyYWN0ZXJzID0gKCdcXGZcXG5cXHJcXHRcXHZcXHUwMDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwNycgK1xuICAgICdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmYnKS5zcGxpdCgnJyk7XG5leHBvcnQgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVnZXhwID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG5ldyBSZWdFeHAodmFsdWUpIDogdmFsdWU7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VDaGFyYWN0ZXJzLnNvbWUoKHdzKSA9PiByZWdleHAudGVzdCh3cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENhc2VJbnNlbnNpdGl2ZVBhdHRlcm4oa2V5d29yZCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoa2V5d29yZCwgbGV0dGVyID0+IC9cXHcvLnRlc3QobGV0dGVyKSA/IGBbJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX0ke2xldHRlci50b1VwcGVyQ2FzZSgpfV1gIDogZXNjYXBlUmVnRXhwKGxldHRlcikpLmpvaW4oJycpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGhhcyBhIHBhcnRpYWwgbWF0Y2ggd2l0aCB0aGUgc3BlY2lmaWVkIHJlZ2V4LlxuICogQHBhcmFtIHJlZ2V4IFRoZSByZWdleCB0byBwYXJ0aWFsbHkgbWF0Y2ggYWdhaW5zdFxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIFdoZXRoZXIgYW55IG1hdGNoIGV4aXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWxNYXRjaGVzKHJlZ2V4LCBpbnB1dCkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0aWFsUmVnRXhwKHJlZ2V4KTtcbiAgICBjb25zdCBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhcnRpYWwpO1xuICAgIHJldHVybiAhIW1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+IDA7XG59XG4vKipcbiAqIEJ1aWxkcyBhIHBhcnRpYWwgcmVnZXggZnJvbSB0aGUgaW5wdXQgcmVnZXguIEEgcGFydGlhbCByZWdleCBpcyBhYmxlIHRvIG1hdGNoIGluY29tcGxldGUgaW5wdXQgc3RyaW5ncy4gRS5nLlxuICogYSBwYXJ0aWFsIHJlZ2V4IGNvbnN0cnVjdGVkIGZyb20gYC9hYi9gIGlzIGFibGUgdG8gbWF0Y2ggdGhlIHN0cmluZyBgYWAgd2l0aG91dCBuZWVkaW5nIGEgZm9sbG93aW5nIGBiYCBjaGFyYWN0ZXIuIEhvd2V2ZXIgaXQgd29uJ3QgbWF0Y2ggYGJgIGFsb25lLlxuICogQHBhcmFtIHJlZ2V4IFRoZSBpbnB1dCByZWdleCB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyBBIHBhcnRpYWwgcmVnZXggY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5wdXQgcmVnZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsUmVnRXhwKHJlZ2V4KSB7XG4gICAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4KTtcbiAgICB9XG4gICAgY29uc3QgcmUgPSByZWdleCwgc291cmNlID0gcmVnZXguc291cmNlO1xuICAgIGxldCBpID0gMDtcbiAgICBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJycsIHRtcDtcbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kUmF3KG5iQ2hhcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzb3VyY2Uuc3Vic3RyKGksIG5iQ2hhcnMpO1xuICAgICAgICAgICAgaSArPSBuYkNoYXJzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZE9wdGlvbmFsKG5iQ2hhcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnKD86JyArIHNvdXJjZS5zdWJzdHIoaSwgbmJDaGFycykgKyAnfCQpJztcbiAgICAgICAgICAgIGkgKz0gbmJDaGFycztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZS51bmljb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaSArIDJdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKHNvdXJjZS5pbmRleE9mKCd9JywgaSkgLSBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmUudW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbChzb3VyY2UuaW5kZXhPZignfScsIGkpIC0gaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoc291cmNlLmluZGV4T2YoJz4nLCBpKSAtIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IC9cXFsoPzpcXFxcLnwuKSo/XFxdL2c7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sYXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAuZXhlYyhzb3VyY2UpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCh0bXBbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFJhdygxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IC9cXHtcXGQrLD9cXGQqXFx9L2c7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sYXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAuZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcodG1wWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpICsgMV0gPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzb3VyY2VbaSArIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnKD86JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyg/PSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHByb2Nlc3MoKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc291cmNlLnN1YnN0cih0bXAsIGkgLSB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzb3VyY2VbaSArIDNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc291cmNlLnN1YnN0cih0bXAsIGkgLSB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcoc291cmNlLmluZGV4T2YoJz4nLCBpKSAtIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocHJvY2VzcygpLCByZWdleC5mbGFncyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdleHAtdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/regexp-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/stream.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/utils/stream.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DONE_RESULT: () => (/* binding */ DONE_RESULT),\n/* harmony export */   EMPTY_STREAM: () => (/* binding */ EMPTY_STREAM),\n/* harmony export */   Reduction: () => (/* binding */ Reduction),\n/* harmony export */   StreamImpl: () => (/* binding */ StreamImpl),\n/* harmony export */   TreeStreamImpl: () => (/* binding */ TreeStreamImpl),\n/* harmony export */   stream: () => (/* binding */ stream)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nclass StreamImpl {\n    constructor(startFn, nextFn) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map(element => [\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state => {\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = state.iterator.next();\n                if (!result.done) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    join(separator = ',') {\n        const iterator = this.iterator();\n        let value = '';\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new StreamImpl(this.startFn, (state) => {\n            const { done, value } = this.nextFn(state);\n            if (done) {\n                return DONE_RESULT;\n            }\n            else {\n                return { done: false, value: callbackfn(value) };\n            }\n        });\n    }\n    filter(predicate) {\n        return new StreamImpl(this.startFn, state => {\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter(e => e !== undefined && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            }\n            else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if (isIterable(mapped)) {\n                        state.iterator = mapped[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: mapped };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === undefined) {\n            depth = 1;\n        }\n        if (depth <= 0) {\n            return this;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) : this;\n        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = stream.nextFn(state.this);\n                if (!done) {\n                    if (isIterable(value)) {\n                        state.iterator = value[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: value };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new StreamImpl(() => {\n            const state = this.startFn();\n            for (let i = 0; i < skipCount; i++) {\n                const next = this.nextFn(state);\n                if (next.done) {\n                    return state;\n                }\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {\n            state.size++;\n            if (state.size > maxSize) {\n                return DONE_RESULT;\n            }\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        return new StreamImpl(() => ({ set: new Set(), internalState: this.startFn() }), state => {\n            let result;\n            do {\n                result = this.nextFn(state.internalState);\n                if (!result.done) {\n                    const value = by ? by(result.value) : result.value;\n                    if (!state.set.has(value)) {\n                        state.set.add(value);\n                        return result;\n                    }\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = new Set();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\nfunction toString(item) {\n    if (typeof item === 'string') {\n        return item;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof item.toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return item.toString();\n    }\n    return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\n}\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nconst DONE_RESULT = Object.freeze({ done: true, value: undefined });\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nfunction stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl(() => ({ index: 0 }), (state) => {\n                if (state.index < collection.length) {\n                    return { done: false, value: collection[state.index++] };\n                }\n                else {\n                    return DONE_RESULT;\n                }\n            });\n        }\n    }\n    if (collections.length > 1) {\n        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (!next.done) {\n                        return next;\n                    }\n                    state.iterator = undefined;\n                }\n                if (state.array) {\n                    if (state.arrIndex < state.array.length) {\n                        return { done: false, value: state.array[state.arrIndex++] };\n                    }\n                    state.array = undefined;\n                    state.arrIndex = 0;\n                }\n                if (state.collIndex < collections.length) {\n                    const collection = collections[state.collIndex++];\n                    if (isIterable(collection)) {\n                        state.iterator = collection[Symbol.iterator]();\n                    }\n                    else if (collection && typeof collection.length === 'number') {\n                        state.array = collection;\n                    }\n                }\n            } while (state.iterator || state.array || state.collIndex < collections.length);\n            return DONE_RESULT;\n        });\n    }\n    return EMPTY_STREAM;\n}\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nclass TreeStreamImpl extends StreamImpl {\n    constructor(root, children, options) {\n        super(() => ({\n            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n            pruned: false\n        }), state => {\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while (state.iterators.length > 0) {\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) {\n                    state.iterators.pop();\n                }\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nvar Reduction;\n(function (Reduction) {\n    /**\n     * Compute the sum of a number stream.\n     */\n    function sum(stream) {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n    Reduction.sum = sum;\n    /**\n     * Compute the product of a number stream.\n     */\n    function product(stream) {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n    Reduction.product = product;\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function min(stream) {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n    Reduction.min = min;\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function max(stream) {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n    Reduction.max = max;\n})(Reduction || (Reduction = {}));\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZFQUE2RTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ08sb0NBQW9DLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHV0aWxzXFxzdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgU3RyZWFtYCB3b3JrcyB3aXRoIHR3byBpbnB1dCBmdW5jdGlvbnM6XG4gKiAgLSBUaGUgZmlyc3QgZnVuY3Rpb24gY3JlYXRlcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBhbiBpdGVyYXRpb24uXG4gKiAgLSBUaGUgc2Vjb25kIGZ1bmN0aW9uIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gYEl0ZXJhdG9yUmVzdWx0YC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0Rm4sIG5leHRGbikge1xuICAgICAgICB0aGlzLnN0YXJ0Rm4gPSBzdGFydEZuO1xuICAgICAgICB0aGlzLm5leHRGbiA9IG5leHRGbjtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IGl0ZXJhdG9yXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVyYXRvci5uZXh0KCkuZG9uZSk7XG4gICAgfVxuICAgIGNvdW50KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCFuZXh0LmRvbmUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1NldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcyk7XG4gICAgfVxuICAgIHRvTWFwKGtleUZuLCB2YWx1ZUZuKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5U3RyZWFtID0gdGhpcy5tYXAoZWxlbWVudCA9PiBbXG4gICAgICAgICAgICBrZXlGbiA/IGtleUZuKGVsZW1lbnQpIDogZWxlbWVudCxcbiAgICAgICAgICAgIHZhbHVlRm4gPyB2YWx1ZUZuKGVsZW1lbnQpIDogZWxlbWVudFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoZW50cnlTdHJlYW0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbigpO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IGZpcnN0OiB0aGlzLnN0YXJ0Rm4oKSwgZmlyc3REb25lOiBmYWxzZSwgaXRlcmF0b3I6IG90aGVyW1N5bWJvbC5pdGVyYXRvcl0oKSB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuZmlyc3REb25lKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm5leHRGbihzdGF0ZS5maXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpcnN0RG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgam9pbihzZXBhcmF0b3IgPSAnLCcpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgYWRkU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9TdHJpbmcocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIH0gd2hpbGUgKCFyZXN1bHQuZG9uZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBmcm9tSW5kZXggJiYgbmV4dC52YWx1ZSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlKG5leHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc29tZShwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBjYWxsYmFja2ZuKG5leHQudmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcChjYWxsYmFja2ZuKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLnN0YXJ0Rm4sIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gdGhpcy5uZXh0Rm4oc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGNhbGxiYWNrZm4odmFsdWUpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLnN0YXJ0Rm4sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0Rm4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUgJiYgcHJlZGljYXRlKHJlc3VsdC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCAmJiBlICE9PSBudWxsKTtcbiAgICB9XG4gICAgcmVkdWNlKGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrZm4ocHJldmlvdXNWYWx1ZSwgbmV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgICByZWR1Y2VSaWdodChjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlUmVkdWNlKHRoaXMuaXRlcmF0b3IoKSwgY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlUmVkdWNlKGl0ZXJhdG9yLCBjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5yZWN1cnNpdmVSZWR1Y2UoaXRlcmF0b3IsIGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja2ZuKHByZXZpb3VzVmFsdWUsIG5leHQudmFsdWUpO1xuICAgIH1cbiAgICBmaW5kKHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5leHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaW5jbHVkZXMoc2VhcmNoRWxlbWVudCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsYXRNYXAoY2FsbGJhY2tmbikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgdGhpczogdGhpcy5zdGFydEZuKCkgfSksIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pdGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHRoaXMubmV4dEZuKHN0YXRlLnRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWQgPSBjYWxsYmFja2ZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUobWFwcGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3IgPSBtYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBtYXBwZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXRlLml0ZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZsYXQoZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlcHRoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gZGVwdGggPiAxID8gdGhpcy5mbGF0KGRlcHRoIC0gMSkgOiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgdGhpczogc3RyZWFtLnN0YXJ0Rm4oKSB9KSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gc3RyZWFtLm5leHRGbihzdGF0ZS50aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXRlLml0ZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhlYWQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICB0YWlsKHNraXBDb3VudCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGFydEZuKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraXBDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dEZuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sIHRoaXMubmV4dEZuKTtcbiAgICB9XG4gICAgbGltaXQobWF4U2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgc2l6ZTogMCwgc3RhdGU6IHRoaXMuc3RhcnRGbigpIH0pLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zaXplKys7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Rm4oc3RhdGUuc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzdGluY3QoYnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IHNldDogbmV3IFNldCgpLCBpbnRlcm5hbFN0YXRlOiB0aGlzLnN0YXJ0Rm4oKSB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm5leHRGbihzdGF0ZS5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnkgPyBieShyZXN1bHQudmFsdWUpIDogcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLnNldC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZShvdGhlciwga2V5KSB7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ga2V5ID8ga2V5KGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgIG90aGVyS2V5U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3duS2V5ID0ga2V5ID8ga2V5KGUpIDogZTtcbiAgICAgICAgICAgIHJldHVybiAhb3RoZXJLZXlTZXQuaGFzKG93bktleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAodHlwZW9mIGl0ZW0udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQW4gZW1wdHkgc3RyZWFtIG9mIGFueSB0eXBlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUkVBTSA9IG5ldyBTdHJlYW1JbXBsKCgpID0+IHVuZGVmaW5lZCwgKCkgPT4gRE9ORV9SRVNVTFQpO1xuLyoqXG4gKiBVc2UgdGhpcyBgSXRlcmF0b3JSZXN1bHRgIHdoZW4gaW1wbGVtZW50aW5nIGEgYFN0cmVhbUltcGxgIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmUgZWxlbWVudHMgaW4gdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNvbnN0IERPTkVfUkVTVUxUID0gT2JqZWN0LmZyZWV6ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBmcm9tIG9uZSBvciBtb3JlIGl0ZXJhYmxlcyBvciBhcnJheS1saWtlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbSguLi5jb2xsZWN0aW9ucykge1xuICAgIGlmIChjb2xsZWN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zWzBdO1xuICAgICAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFN0cmVhbUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCksIChpdGVyYXRvcikgPT4gaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IGluZGV4OiAwIH0pLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5kZXggPCBjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGNvbGxlY3Rpb25bc3RhdGUuaW5kZXgrK10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgY29sbEluZGV4OiAwLCBhcnJJbmRleDogMCB9KSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hcnJJbmRleCA8IHN0YXRlLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzdGF0ZS5hcnJheVtzdGF0ZS5hcnJJbmRleCsrXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFycmF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zW3N0YXRlLmNvbGxJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJheSA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5pdGVyYXRvciB8fCBzdGF0ZS5hcnJheSB8fCBzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX1NUUkVBTTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYFRyZWVTdHJlYW1gIHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZCBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG4gKiBjaGlsZHJlbiBvZiBpdHMgYXJndW1lbnQuIFdoZXRoZXIgdGhlIHJvb3Qgbm9kZSBpbmNsdWRlZCBpbiB0aGUgc3RyZWFtIGlzIGNvbnRyb2xsZWQgd2l0aCB0aGVcbiAqIGBpbmNsdWRlUm9vdGAgb3B0aW9uLCB3aGljaCBkZWZhdWx0cyB0byBgZmFsc2VgLlxuICovXG5leHBvcnQgY2xhc3MgVHJlZVN0cmVhbUltcGwgZXh0ZW5kcyBTdHJlYW1JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigoKSA9PiAoe1xuICAgICAgICAgICAgaXRlcmF0b3JzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVSb290KSA/IFtbcm9vdF1bU3ltYm9sLml0ZXJhdG9yXSgpXSA6IFtjaGlsZHJlbihyb290KVtTeW1ib2wuaXRlcmF0b3JdKCldLFxuICAgICAgICAgICAgcHJ1bmVkOiBmYWxzZVxuICAgICAgICB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnBydW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcnVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5pdGVyYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3JzW3N0YXRlLml0ZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnB1c2goY2hpbGRyZW4obmV4dC52YWx1ZSlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgcHJ1bmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zdGF0ZS5wcnVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiBpdGVyYXRvclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHJlZHVjZSBhIHN0cmVhbSB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IHZhciBSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKFJlZHVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHN1bSBvZiBhIG51bWJlciBzdHJlYW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIH1cbiAgICBSZWR1Y3Rpb24uc3VtID0gc3VtO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYSBudW1iZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2R1Y3Qoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMCk7XG4gICAgfVxuICAgIFJlZHVjdGlvbi5wcm9kdWN0ID0gcHJvZHVjdDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtaW5pbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1pbiA9IG1pbjtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1heCA9IG1heDtcbn0pKFJlZHVjdGlvbiB8fCAoUmVkdWN0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/utils/uri-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/uri-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   URI: () => (/* reexport safe */ vscode_uri__WEBPACK_IMPORTED_MODULE_0__.URI),\n/* harmony export */   UriUtils: () => (/* binding */ UriUtils)\n/* harmony export */ });\n/* harmony import */ var vscode_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-uri */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nvar UriUtils;\n(function (UriUtils) {\n    UriUtils.basename = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.basename;\n    UriUtils.dirname = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.dirname;\n    UriUtils.extname = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.extname;\n    UriUtils.joinPath = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.joinPath;\n    UriUtils.resolvePath = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    UriUtils.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === 'string' ? from : from.path;\n        const toPath = typeof to === 'string' ? to : to.path;\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\n        const toParts = toPath.split('/').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = '../'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join('/');\n        return backPart + toPart;\n    }\n    UriUtils.relative = relative;\n    function normalize(uri) {\n        return vscode_uri__WEBPACK_IMPORTED_MODULE_0__.URI.parse(uri.toString()).toString();\n    }\n    UriUtils.normalize = normalize;\n})(UriUtils || (UriUtils = {}));\n//# sourceMappingURL=uri-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvdXJpLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDekI7QUFDUjtBQUNQO0FBQ0Esd0JBQXdCLDZDQUFLO0FBQzdCLHVCQUF1Qiw2Q0FBSztBQUM1Qix1QkFBdUIsNkNBQUs7QUFDNUIsd0JBQXdCLDZDQUFLO0FBQzdCLDJCQUEyQiw2Q0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBRztBQUNsQjtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0IiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdXRpbHNcXHVyaS11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBVUkksIFV0aWxzIH0gZnJvbSAndnNjb2RlLXVyaSc7XG5leHBvcnQgeyBVUkkgfTtcbmV4cG9ydCB2YXIgVXJpVXRpbHM7XG4oZnVuY3Rpb24gKFVyaVV0aWxzKSB7XG4gICAgVXJpVXRpbHMuYmFzZW5hbWUgPSBVdGlscy5iYXNlbmFtZTtcbiAgICBVcmlVdGlscy5kaXJuYW1lID0gVXRpbHMuZGlybmFtZTtcbiAgICBVcmlVdGlscy5leHRuYW1lID0gVXRpbHMuZXh0bmFtZTtcbiAgICBVcmlVdGlscy5qb2luUGF0aCA9IFV0aWxzLmpvaW5QYXRoO1xuICAgIFVyaVV0aWxzLnJlc29sdmVQYXRoID0gVXRpbHMucmVzb2x2ZVBhdGg7XG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEudG9TdHJpbmcoKSkgPT09IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIFVyaVV0aWxzLmVxdWFscyA9IGVxdWFscztcbiAgICBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgICAgICBjb25zdCBmcm9tUGF0aCA9IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGZyb20gOiBmcm9tLnBhdGg7XG4gICAgICAgIGNvbnN0IHRvUGF0aCA9IHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IHRvLnBhdGg7XG4gICAgICAgIGNvbnN0IGZyb21QYXJ0cyA9IGZyb21QYXRoLnNwbGl0KCcvJykuZmlsdGVyKGUgPT4gZS5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3QgdG9QYXJ0cyA9IHRvUGF0aC5zcGxpdCgnLycpLmZpbHRlcihlID0+IGUubGVuZ3RoID4gMCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrUGFydCA9ICcuLi8nLnJlcGVhdChmcm9tUGFydHMubGVuZ3RoIC0gaSk7XG4gICAgICAgIGNvbnN0IHRvUGFydCA9IHRvUGFydHMuc2xpY2UoaSkuam9pbignLycpO1xuICAgICAgICByZXR1cm4gYmFja1BhcnQgKyB0b1BhcnQ7XG4gICAgfVxuICAgIFVyaVV0aWxzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHVyaSkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHVyaS50b1N0cmluZygpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBVcmlVdGlscy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG59KShVcmlVdGlscyB8fCAoVXJpVXRpbHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/utils/uri-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/validation/document-validator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langium/lib/validation/document-validator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultDocumentValidator: () => (/* binding */ DefaultDocumentValidator),\n/* harmony export */   DocumentValidator: () => (/* binding */ DocumentValidator),\n/* harmony export */   getDiagnosticRange: () => (/* binding */ getDiagnosticRange),\n/* harmony export */   toDiagnosticData: () => (/* binding */ toDiagnosticData),\n/* harmony export */   toDiagnosticSeverity: () => (/* binding */ toDiagnosticSeverity)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/grammar-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/grammar-utils.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _validation_registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validation-registry.js */ \"(ssr)/./node_modules/langium/lib/validation/validation-registry.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultDocumentValidator {\n    constructor(services) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);\n        if (!options.categories || options.categories.includes('built-in')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {\n                return diagnostics;\n            }\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {\n                return diagnostics;\n            }\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {\n                return diagnostics;\n            }\n        }\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        }\n        catch (err) {\n            if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.isOperationCancelled)(err)) {\n                throw err;\n            }\n            console.error('An error occurred during validation:', err);\n        }\n        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        var _a, _b, _c;\n        const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null && _b !== void 0 ? _b : []];\n        for (const lexerDiagnostic of lexerDiagnostics) {\n            const severity = (_c = lexerDiagnostic.severity) !== null && _c !== void 0 ? _c : 'error';\n            const diagnostic = {\n                severity: toDiagnosticSeverity(severity),\n                range: {\n                    start: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column - 1\n                    },\n                    end: {\n                        line: lexerDiagnostic.line - 1,\n                        character: lexerDiagnostic.column + lexerDiagnostic.length - 1\n                    }\n                },\n                message: lexerDiagnostic.message,\n                data: toDiagnosticData(severity),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors) {\n            let range = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if ('previousToken' in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = { line: token.endLine - 1, character: token.endColumn };\n                        range = { start: position, end: position };\n                    }\n                    else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position = { line: 0, character: 0 };\n                        range = { start: position, end: position };\n                    }\n                }\n            }\n            else {\n                range = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.tokenToRange)(parserError.token);\n            }\n            if (range) {\n                const diagnostic = {\n                    severity: toDiagnosticSeverity('error'),\n                    range,\n                    message: parserError.message,\n                    data: (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        const validationItems = [];\n        const acceptor = (severity, message, info) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\n        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\n        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\n        return validationItems;\n    }\n    async validateAstBefore(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        var _a;\n        const checksBefore = this.validationRegistry.checksBefore;\n        for (const checkBefore of checksBefore) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);\n            await checkBefore(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    async validateAstNodes(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        await Promise.all((0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_4__.streamAst)(rootNode).map(async (node) => {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n    }\n    async validateAstAfter(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        var _a;\n        const checksAfter = this.validationRegistry.checksAfter;\n        for (const checkAfter of checksAfter) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);\n            await checkAfter(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);\n        }\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n}\nfunction getDiagnosticRange(info) {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode;\n    if (typeof info.property === 'string') {\n        cstNode = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__.findNodeForProperty)(info.node.$cstNode, info.property, info.index);\n    }\n    else if (typeof info.keyword === 'string') {\n        cstNode = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__.findNodeForKeyword)(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\n/**\n * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.\n *\n * @param severity The lexing diagnostic severity\n * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`\n */\nfunction toDiagnosticSeverity(severity) {\n    switch (severity) {\n        case 'error':\n            return 1;\n        case 'warning':\n            return 2;\n        case 'info':\n            return 3;\n        case 'hint':\n            return 4;\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nfunction toDiagnosticData(severity) {\n    switch (severity) {\n        case 'error':\n            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingError);\n        case 'warning':\n            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingWarning);\n        case 'info':\n            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingInfo);\n        case 'hint':\n            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingHint);\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\nvar DocumentValidator;\n(function (DocumentValidator) {\n    DocumentValidator.LexingError = 'lexing-error';\n    DocumentValidator.LexingWarning = 'lexing-warning';\n    DocumentValidator.LexingInfo = 'lexing-info';\n    DocumentValidator.LexingHint = 'lexing-hint';\n    DocumentValidator.ParsingError = 'parsing-error';\n    DocumentValidator.LinkingError = 'linking-error';\n})(DocumentValidator || (DocumentValidator = {}));\n//# sourceMappingURL=document-validator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdmFsaWRhdGlvbi9kb2N1bWVudC12YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ3VCO0FBQ2xDO0FBQ0c7QUFDK0I7QUFDMUI7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0IscUVBQWlCO0FBQ2xGO0FBQ0E7QUFDQSxjQUFjLDBFQUFpQjtBQUMvQjtBQUNBO0FBQ0EseUVBQXlFLFFBQVEsd0dBQXdHO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRLHlHQUF5RztBQUMzTDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUSx5R0FBeUc7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBFQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0Msa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1RUFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxRUFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHFFQUFpQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEVBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxxRUFBaUI7QUFDdkYsMEJBQTBCLDhEQUFTO0FBQ25DLGtCQUFrQiwwRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzRUFBc0UscUVBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0RUFBbUI7QUFDckM7QUFDQTtBQUNBLGtCQUFrQiwyRUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsdUVBQWM7QUFDakM7QUFDQSxtQkFBbUIsdUVBQWM7QUFDakM7QUFDQSxtQkFBbUIsdUVBQWM7QUFDakM7QUFDQSxtQkFBbUIsdUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0MiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcdmFsaWRhdGlvblxcZG9jdW1lbnQtdmFsaWRhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IGZpbmROb2RlRm9yS2V5d29yZCwgZmluZE5vZGVGb3JQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtQXN0IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHRva2VuVG9SYW5nZSB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpbnRlcnJ1cHRBbmRDaGVjaywgaXNPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IGRpYWdub3N0aWNEYXRhIH0gZnJvbSAnLi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RG9jdW1lbnRWYWxpZGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvblJlZ2lzdHJ5ID0gc2VydmljZXMudmFsaWRhdGlvbi5WYWxpZGF0aW9uUmVnaXN0cnk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBzZXJ2aWNlcy5MYW5ndWFnZU1ldGFEYXRhO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZURvY3VtZW50KGRvY3VtZW50LCBvcHRpb25zID0ge30sIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGRvY3VtZW50LnBhcnNlUmVzdWx0O1xuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IFtdO1xuICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYXRlZ29yaWVzIHx8IG9wdGlvbnMuY2F0ZWdvcmllcy5pbmNsdWRlcygnYnVpbHQtaW4nKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJMZXhpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdFcnJvcjsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJQYXJzaW5nRXJyb3JzICYmIGRpYWdub3N0aWNzLnNvbWUoZCA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBkLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gRG9jdW1lbnRWYWxpZGF0b3IuUGFyc2luZ0Vycm9yOyB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0b3BBZnRlckxpbmtpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MaW5raW5nRXJyb3I7IH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgY3VzdG9tIHZhbGlkYXRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLmF3YWl0IHRoaXMudmFsaWRhdGVBc3QocGFyc2VSZXN1bHQudmFsdWUsIG9wdGlvbnMsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdmFsaWRhdGlvbjonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgIH1cbiAgICBwcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGxleGVyRGlhZ25vc3RpY3MgPSBbLi4ucGFyc2VSZXN1bHQubGV4ZXJFcnJvcnMsIC4uLihfYiA9IChfYSA9IHBhcnNlUmVzdWx0LmxleGVyUmVwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlhZ25vc3RpY3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdXTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlckRpYWdub3N0aWMgb2YgbGV4ZXJEaWFnbm9zdGljcykge1xuICAgICAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSAoX2MgPSBsZXhlckRpYWdub3N0aWMuc2V2ZXJpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdlcnJvcic7XG4gICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgIHNldmVyaXR5OiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eSksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyRGlhZ25vc3RpYy5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbGV4ZXJEaWFnbm9zdGljLmNvbHVtbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlckRpYWdub3N0aWMubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGxleGVyRGlhZ25vc3RpYy5jb2x1bW4gKyBsZXhlckRpYWdub3N0aWMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsZXhlckRpYWdub3N0aWMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0b0RpYWdub3N0aWNEYXRhKHNldmVyaXR5KSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKGRpYWdub3N0aWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJzZXJFcnJvciBvZiBwYXJzZVJlc3VsdC5wYXJzZXJFcnJvcnMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBydW4gaW50byB0aGUgY2hldnJvdGFpbiBlcnJvciByZWNvdmVyeSBoZXJlXG4gICAgICAgICAgICAvLyBUaGUgdG9rZW4gY29udGFpbmVkIGluIHRoZSBwYXJzZXIgZXJyb3IgbWlnaHQgYmUgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGV2ZXJ5IHBvc2l0aW9uIHZhbHVlIHdpbGwgYmUgYE5hTmBcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZXJFcnJvci50b2tlbi5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHNwZWNpYWwgcGFyc2VyIGVycm9yIHR5cGVzIGNvbnRhaW4gYSBgcHJldmlvdXNUb2tlbmBcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2ltcGx5IGFwcGVuZCBvdXIgZGlhZ25vc3RpYyB0byB0aGF0IHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKCdwcmV2aW91c1Rva2VuJyBpbiBwYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnNlckVycm9yLnByZXZpb3VzVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odG9rZW4uc3RhcnRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogdG9rZW4uZW5kTGluZSAtIDEsIGNoYXJhY3RlcjogdG9rZW4uZW5kQ29sdW1uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB2YWxpZCBwcmV2IHRva2VuLiBNaWdodCBiZSBlbXB0eSBkb2N1bWVudCBvciBjb250YWluaW5nIG9ubHkgaGlkZGVuIHRva2Vucy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvaW50IHRvIGRvY3VtZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRva2VuVG9SYW5nZShwYXJzZXJFcnJvci50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogdG9EaWFnbm9zdGljU2V2ZXJpdHkoJ2Vycm9yJyksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkaWFnbm9zdGljRGF0YShEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBfb3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiBkb2N1bWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5raW5nRXJyb3IgPSByZWZlcmVuY2UuZXJyb3I7XG4gICAgICAgICAgICBpZiAobGlua2luZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGxpbmtpbmdFcnJvci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmtpbmdFcnJvci5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyVHlwZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lci4kdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBsaW5raW5nRXJyb3IucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUZXh0OiBsaW5raW5nRXJyb3IucmVmZXJlbmNlLiRyZWZUZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2godGhpcy50b0RpYWdub3N0aWMoJ2Vycm9yJywgbGlua2luZ0Vycm9yLm1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZUFzdChyb290Tm9kZSwgb3B0aW9ucywgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25JdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRvciA9IChzZXZlcml0eSwgbWVzc2FnZSwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkl0ZW1zLnB1c2godGhpcy50b0RpYWdub3N0aWMoc2V2ZXJpdHksIG1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUFzdEJlZm9yZShyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUFzdE5vZGVzKHJvb3ROb2RlLCBvcHRpb25zLCBhY2NlcHRvciwgY2FuY2VsVG9rZW4pO1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQXN0QWZ0ZXIocm9vdE5vZGUsIG9wdGlvbnMsIGFjY2VwdG9yLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uSXRlbXM7XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkYXRlQXN0QmVmb3JlKHJvb3ROb2RlLCBvcHRpb25zLCBhY2NlcHRvciwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2hlY2tzQmVmb3JlID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuY2hlY2tzQmVmb3JlO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrQmVmb3JlIG9mIGNoZWNrc0JlZm9yZSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tCZWZvcmUocm9vdE5vZGUsIGFjY2VwdG9yLCAoX2EgPSBvcHRpb25zLmNhdGVnb3JpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBc3ROb2Rlcyhyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdHJlYW1Bc3Qocm9vdE5vZGUpLm1hcChhc3luYyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuZ2V0Q2hlY2tzKG5vZGUuJHR5cGUsIG9wdGlvbnMuY2F0ZWdvcmllcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGNoZWNrcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrKG5vZGUsIGFjY2VwdG9yLCBjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBc3RBZnRlcihyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoZWNrc0FmdGVyID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuY2hlY2tzQWZ0ZXI7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2tBZnRlciBvZiBjaGVja3NBZnRlcikge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tBZnRlcihyb290Tm9kZSwgYWNjZXB0b3IsIChfYSA9IG9wdGlvbnMuY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RpYWdub3N0aWMoc2V2ZXJpdHksIG1lc3NhZ2UsIGluZm8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByYW5nZTogZ2V0RGlhZ25vc3RpY1JhbmdlKGluZm8pLFxuICAgICAgICAgICAgc2V2ZXJpdHk6IHRvRGlhZ25vc3RpY1NldmVyaXR5KHNldmVyaXR5KSxcbiAgICAgICAgICAgIGNvZGU6IGluZm8uY29kZSxcbiAgICAgICAgICAgIGNvZGVEZXNjcmlwdGlvbjogaW5mby5jb2RlRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB0YWdzOiBpbmZvLnRhZ3MsXG4gICAgICAgICAgICByZWxhdGVkSW5mb3JtYXRpb246IGluZm8ucmVsYXRlZEluZm9ybWF0aW9uLFxuICAgICAgICAgICAgZGF0YTogaW5mby5kYXRhLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmdldFNvdXJjZSgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEubGFuZ3VhZ2VJZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY1JhbmdlKGluZm8pIHtcbiAgICBpZiAoaW5mby5yYW5nZSkge1xuICAgICAgICByZXR1cm4gaW5mby5yYW5nZTtcbiAgICB9XG4gICAgbGV0IGNzdE5vZGU7XG4gICAgaWYgKHR5cGVvZiBpbmZvLnByb3BlcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjc3ROb2RlID0gZmluZE5vZGVGb3JQcm9wZXJ0eShpbmZvLm5vZGUuJGNzdE5vZGUsIGluZm8ucHJvcGVydHksIGluZm8uaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5mby5rZXl3b3JkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjc3ROb2RlID0gZmluZE5vZGVGb3JLZXl3b3JkKGluZm8ubm9kZS4kY3N0Tm9kZSwgaW5mby5rZXl3b3JkLCBpbmZvLmluZGV4KTtcbiAgICB9XG4gICAgY3N0Tm9kZSAhPT0gbnVsbCAmJiBjc3ROb2RlICE9PSB2b2lkIDAgPyBjc3ROb2RlIDogKGNzdE5vZGUgPSBpbmZvLm5vZGUuJGNzdE5vZGUpO1xuICAgIGlmICghY3N0Tm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH0sXG4gICAgICAgICAgICBlbmQ6IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNzdE5vZGUucmFuZ2U7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGRpYWdub3N0aWMgc2V2ZXJpdHkgZnJvbSB0aGUge0BsaW5rIExleGluZ0RpYWdub3N0aWNTZXZlcml0eX0gZm9ybWF0IHRvIExTUCdzIGBEaWFnbm9zdGljU2V2ZXJpdHlgIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gc2V2ZXJpdHkgVGhlIGxleGluZyBkaWFnbm9zdGljIHNldmVyaXR5XG4gKiBAcmV0dXJucyBEaWFnbm9zdGljIHNldmVyaXR5IGFjY29yZGluZyB0byBgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyNEaWFnbm9zdGljU2V2ZXJpdHlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eSkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgJ2hpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlhZ25vc3RpYyBzZXZlcml0eTogJyArIHNldmVyaXR5KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9EaWFnbm9zdGljRGF0YShzZXZlcml0eSkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNEYXRhKERvY3VtZW50VmFsaWRhdG9yLkxleGluZ0Vycm9yKTtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY0RhdGEoRG9jdW1lbnRWYWxpZGF0b3IuTGV4aW5nV2FybmluZyk7XG4gICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNEYXRhKERvY3VtZW50VmFsaWRhdG9yLkxleGluZ0luZm8pO1xuICAgICAgICBjYXNlICdoaW50JzpcbiAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljRGF0YShEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdIaW50KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWFnbm9zdGljIHNldmVyaXR5OiAnICsgc2V2ZXJpdHkpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgRG9jdW1lbnRWYWxpZGF0b3I7XG4oZnVuY3Rpb24gKERvY3VtZW50VmFsaWRhdG9yKSB7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGV4aW5nRXJyb3IgPSAnbGV4aW5nLWVycm9yJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdXYXJuaW5nID0gJ2xleGluZy13YXJuaW5nJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdJbmZvID0gJ2xleGluZy1pbmZvJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdIaW50ID0gJ2xleGluZy1oaW50JztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IgPSAncGFyc2luZy1lcnJvcic7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yID0gJ2xpbmtpbmctZXJyb3InO1xufSkoRG9jdW1lbnRWYWxpZGF0b3IgfHwgKERvY3VtZW50VmFsaWRhdG9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50LXZhbGlkYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/validation/document-validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/validation/validation-registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/validation/validation-registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationCategory: () => (/* binding */ ValidationCategory),\n/* harmony export */   ValidationRegistry: () => (/* binding */ ValidationRegistry),\n/* harmony export */   diagnosticData: () => (/* binding */ diagnosticData)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"(ssr)/./node_modules/langium/lib/utils/errors.js\");\n/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ \"(ssr)/./node_modules/langium/lib/utils/collections.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nfunction diagnosticData(code) {\n    return { code };\n}\nvar ValidationCategory;\n(function (ValidationCategory) {\n    ValidationCategory.all = ['fast', 'slow', 'built-in'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nclass ValidationRegistry {\n    constructor(services) {\n        this.entries = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();\n        this.entriesBefore = [];\n        this.entriesAfter = [];\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register(checksRecord, thisObj = this, category = 'fast') {\n        if (category === 'built-in') {\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            }\n            else if (typeof callbacks === 'function') {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n            else {\n                (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.assertUnreachable)(callbacks);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\n        };\n    }\n    async handleException(functionality, messageContext, accept, node) {\n        try {\n            await functionality();\n        }\n        catch (err) {\n            if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.isOperationCancelled)(err)) {\n                throw err;\n            }\n            console.error(`${messageContext}:`, err);\n            if (err instanceof Error && err.stack) {\n                console.error(err.stack);\n            }\n            const messageDetails = err instanceof Error ? err.message : String(err);\n            accept('error', `${messageContext}: ${messageDetails}`, { node });\n        }\n    }\n    addEntry(type, entry) {\n        if (type === 'AstNode') {\n            this.entries.add('AstNode', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n    getChecks(type, categories) {\n        let checks = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.entries.get(type))\n            .concat(this.entries.get('AstNode'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n    /**\n     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map for mapping names to nodes could be established.\n     * During the usual checks on the nodes, they are put into this map with their name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerBeforeDocument(checkBefore, thisObj = this) {\n        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\n    }\n    /**\n     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n     * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n     *\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\n     * here the map with all the collected nodes and their names is checked\n     * and validation hints are created for all nodes with the same name.\n     *\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n     * Therefore it is recommended to clear stored information\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\n     * AND _after_ validating the AST to free memory by information which are no longer used.\n     *\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    registerAfterDocument(checkAfter, thisObj = this) {\n        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\n    }\n    wrapPreparationException(check, messageContext, thisObj) {\n        return async (rootNode, accept, categories, cancelToken) => {\n            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n        };\n    }\n    get checksBefore() {\n        return this.entriesBefore;\n    }\n    get checksAfter() {\n        return this.entriesAfter;\n    }\n}\n//# sourceMappingURL=validation-registry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdmFsaWRhdGlvbi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ0c7QUFDYztBQUNyQjtBQUM1QztBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkIsMkRBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkVBQW9CO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlLElBQUksZUFBZSxLQUFLLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx2YWxpZGF0aW9uXFx2YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGFzc2VydFVucmVhY2hhYmxlIH0gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICcuLi91dGlscy9jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBpc09wZXJhdGlvbkNhbmNlbGxlZCB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbi8qKlxuICogQ3JlYXRlIERpYWdub3N0aWNEYXRhIGZvciBhIGdpdmVuIGRpYWdub3N0aWMgY29kZS4gVGhlIHJlc3VsdCBjYW4gYmUgcHV0IGludG8gdGhlIGBkYXRhYCBmaWVsZCBvZiBhIERpYWdub3N0aWNJbmZvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlhZ25vc3RpY0RhdGEoY29kZSkge1xuICAgIHJldHVybiB7IGNvZGUgfTtcbn1cbmV4cG9ydCB2YXIgVmFsaWRhdGlvbkNhdGVnb3J5O1xuKGZ1bmN0aW9uIChWYWxpZGF0aW9uQ2F0ZWdvcnkpIHtcbiAgICBWYWxpZGF0aW9uQ2F0ZWdvcnkuYWxsID0gWydmYXN0JywgJ3Nsb3cnLCAnYnVpbHQtaW4nXTtcbn0pKFZhbGlkYXRpb25DYXRlZ29yeSB8fCAoVmFsaWRhdGlvbkNhdGVnb3J5ID0ge30pKTtcbi8qKlxuICogTWFuYWdlcyBhIHNldCBvZiBgVmFsaWRhdGlvbkNoZWNrYHMgdG8gYmUgYXBwbGllZCB3aGVuIGRvY3VtZW50cyBhcmUgdmFsaWRhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvblJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXcgTXVsdGlNYXAoKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzQmVmb3JlID0gW107XG4gICAgICAgIHRoaXMuZW50cmllc0FmdGVyID0gW107XG4gICAgICAgIHRoaXMucmVmbGVjdGlvbiA9IHNlcnZpY2VzLnNoYXJlZC5Bc3RSZWZsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHNldCBvZiB2YWxpZGF0aW9uIGNoZWNrcy4gRWFjaCB2YWx1ZSBpbiB0aGUgcmVjb3JkIGNhbiBiZSBlaXRoZXIgYSBzaW5nbGUgdmFsaWRhdGlvbiBjaGVjayAoaS5lLiBhIGZ1bmN0aW9uKVxuICAgICAqIG9yIGFuIGFycmF5IG9mIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoZWNrc1JlY29yZCBTZXQgb2YgdmFsaWRhdGlvbiBjaGVja3MgdG8gcmVnaXN0ZXIuXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IE9wdGlvbmFsIGNhdGVnb3J5IGZvciB0aGUgdmFsaWRhdGlvbiBjaGVja3MgKGRlZmF1bHRzIHRvIGAnZmFzdCdgKS5cbiAgICAgKiBAcGFyYW0gdGhpc09iaiBPcHRpb25hbCBvYmplY3QgdG8gYmUgdXNlZCBhcyBgdGhpc2Agd2hlbiBjYWxsaW5nIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICByZWdpc3RlcihjaGVja3NSZWNvcmQsIHRoaXNPYmogPSB0aGlzLCBjYXRlZ29yeSA9ICdmYXN0Jykge1xuICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdidWlsdC1pbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnYnVpbHQtaW4nIGNhdGVnb3J5IGlzIHJlc2VydmVkIGZvciBsZXhlciwgcGFyc2VyLCBhbmQgbGlua2VyIGVycm9ycy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgY2hdIG9mIE9iamVjdC5lbnRyaWVzKGNoZWNrc1JlY29yZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNoO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2s6IHRoaXMud3JhcFZhbGlkYXRpb25FeGNlcHRpb24oY2hlY2ssIHRoaXNPYmopLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbnRyeSh0eXBlLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBjaGVjazogdGhpcy53cmFwVmFsaWRhdGlvbkV4Y2VwdGlvbihjYWxsYmFja3MsIHRoaXNPYmopLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbnRyeSh0eXBlLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShjYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHdyYXBWYWxpZGF0aW9uRXhjZXB0aW9uKGNoZWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAobm9kZSwgYWNjZXB0LCBjYW5jZWxUb2tlbikgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFeGNlcHRpb24oKCkgPT4gY2hlY2suY2FsbCh0aGlzT2JqLCBub2RlLCBhY2NlcHQsIGNhbmNlbFRva2VuKSwgJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyB2YWxpZGF0aW9uJywgYWNjZXB0LCBub2RlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRXhjZXB0aW9uKGZ1bmN0aW9uYWxpdHksIG1lc3NhZ2VDb250ZXh0LCBhY2NlcHQsIG5vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZ1bmN0aW9uYWxpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoaXNPcGVyYXRpb25DYW5jZWxsZWQoZXJyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bWVzc2FnZUNvbnRleHR9OmAsIGVycik7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVycik7XG4gICAgICAgICAgICBhY2NlcHQoJ2Vycm9yJywgYCR7bWVzc2FnZUNvbnRleHR9OiAke21lc3NhZ2VEZXRhaWxzfWAsIHsgbm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFbnRyeSh0eXBlLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0FzdE5vZGUnKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuYWRkKCdBc3ROb2RlJywgZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiB0aGlzLnJlZmxlY3Rpb24uZ2V0QWxsU3ViVHlwZXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5hZGQoc3VidHlwZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoZWNrcyh0eXBlLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGxldCBjaGVja3MgPSBzdHJlYW0odGhpcy5lbnRyaWVzLmdldCh0eXBlKSlcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5lbnRyaWVzLmdldCgnQXN0Tm9kZScpKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIGNoZWNrcyA9IGNoZWNrcy5maWx0ZXIoZW50cnkgPT4gY2F0ZWdvcmllcy5pbmNsdWRlcyhlbnRyeS5jYXRlZ29yeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja3MubWFwKGVudHJ5ID0+IGVudHJ5LmNoZWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbG9naWMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIGJlZm9yZSB2YWxpZGF0aW5nIGFsbCB0aGUgbm9kZXMgb2YgYW4gQVNUL0xhbmdpdW0gZG9jdW1lbnQuXG4gICAgICogVGhpcyBoZWxwcyB0byBwcmVwYXJlIG9yIGluaXRpYWxpemUgc29tZSBpbmZvcm1hdGlvbiB3aGljaCBhcmUgcmVxdWlyZWQgb3IgcmV1c2FibGUgZm9yIHRoZSBmb2xsb3dpbmcgY2hlY2tzIG9uIHRoZSBBc3ROb2Rlcy5cbiAgICAgKlxuICAgICAqIEFzIGFuIGV4YW1wbGUsIGZvciB2YWxpZGF0aW5nIHVuaXF1ZSBmdWxseS1xdWFsaWZpZWQgbmFtZXMgb2Ygbm9kZXMgaW4gdGhlIEFTVCxcbiAgICAgKiBoZXJlIHRoZSBtYXAgZm9yIG1hcHBpbmcgbmFtZXMgdG8gbm9kZXMgY291bGQgYmUgZXN0YWJsaXNoZWQuXG4gICAgICogRHVyaW5nIHRoZSB1c3VhbCBjaGVja3Mgb24gdGhlIG5vZGVzLCB0aGV5IGFyZSBwdXQgaW50byB0aGlzIG1hcCB3aXRoIHRoZWlyIG5hbWUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBhcHByb2FjaCBtYWtlcyB2YWxpZGF0aW9ucyBzdGF0ZWZ1bCwgd2hpY2ggaXMgcmVsZXZhbnQgZS5nLiB3aGVuIGNhbmNlbGxpbmcgdGhlIHZhbGlkYXRpb24uXG4gICAgICogVGhlcmVmb3JlIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNsZWFyIHN0b3JlZCBpbmZvcm1hdGlvblxuICAgICAqIF9iZWZvcmVfIHZhbGlkYXRpbmcgYW4gQVNUIHRvIHZhbGlkYXRlIGVhY2ggQVNUIHVuYWZmZWN0ZWQgZnJvbSBvdGhlciBBU1RzXG4gICAgICogQU5EIF9hZnRlcl8gdmFsaWRhdGluZyB0aGUgQVNUIHRvIGZyZWUgbWVtb3J5IGJ5IGluZm9ybWF0aW9uIHdoaWNoIGFyZSBubyBsb25nZXIgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGVja0JlZm9yZSBhIHNldC11cCBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbmNlIGJlZm9yZSBhY3R1YWxseSB2YWxpZGF0aW5nIGFuIEFTVFxuICAgICAqIEBwYXJhbSB0aGlzT2JqIE9wdGlvbmFsIG9iamVjdCB0byBiZSB1c2VkIGFzIGB0aGlzYCB3aGVuIGNhbGxpbmcgdGhlIHZhbGlkYXRpb24gY2hlY2sgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQmVmb3JlRG9jdW1lbnQoY2hlY2tCZWZvcmUsIHRoaXNPYmogPSB0aGlzKSB7XG4gICAgICAgIHRoaXMuZW50cmllc0JlZm9yZS5wdXNoKHRoaXMud3JhcFByZXBhcmF0aW9uRXhjZXB0aW9uKGNoZWNrQmVmb3JlLCAnQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHNldC11cCBvZiB0aGUgdmFsaWRhdGlvbicsIHRoaXNPYmopKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbG9naWMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIGFmdGVyIHZhbGlkYXRpbmcgYWxsIHRoZSBub2RlcyBvZiBhbiBBU1QvTGFuZ2l1bSBkb2N1bWVudC5cbiAgICAgKiBUaGlzIGhlbHBzIHRvIGZpbmFsbHkgZXZhbHVhdGUgaW5mb3JtYXRpb24gd2hpY2ggYXJlIGNvbGxlY3RlZCBkdXJpbmcgdGhlIGNoZWNrcyBvbiB0aGUgQXN0Tm9kZXMuXG4gICAgICpcbiAgICAgKiBBcyBhbiBleGFtcGxlLCBmb3IgdmFsaWRhdGluZyB1bmlxdWUgZnVsbHktcXVhbGlmaWVkIG5hbWVzIG9mIG5vZGVzIGluIHRoZSBBU1QsXG4gICAgICogaGVyZSB0aGUgbWFwIHdpdGggYWxsIHRoZSBjb2xsZWN0ZWQgbm9kZXMgYW5kIHRoZWlyIG5hbWVzIGlzIGNoZWNrZWRcbiAgICAgKiBhbmQgdmFsaWRhdGlvbiBoaW50cyBhcmUgY3JlYXRlZCBmb3IgYWxsIG5vZGVzIHdpdGggdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGFwcHJvYWNoIG1ha2VzIHZhbGlkYXRpb25zIHN0YXRlZnVsLCB3aGljaCBpcyByZWxldmFudCBlLmcuIHdoZW4gY2FuY2VsbGluZyB0aGUgdmFsaWRhdGlvbi5cbiAgICAgKiBUaGVyZWZvcmUgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2xlYXIgc3RvcmVkIGluZm9ybWF0aW9uXG4gICAgICogX2JlZm9yZV8gdmFsaWRhdGluZyBhbiBBU1QgdG8gdmFsaWRhdGUgZWFjaCBBU1QgdW5hZmZlY3RlZCBmcm9tIG90aGVyIEFTVHNcbiAgICAgKiBBTkQgX2FmdGVyXyB2YWxpZGF0aW5nIHRoZSBBU1QgdG8gZnJlZSBtZW1vcnkgYnkgaW5mb3JtYXRpb24gd2hpY2ggYXJlIG5vIGxvbmdlciB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoZWNrQmVmb3JlIGEgc2V0LXVwIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgYmVmb3JlIGFjdHVhbGx5IHZhbGlkYXRpbmcgYW4gQVNUXG4gICAgICogQHBhcmFtIHRoaXNPYmogT3B0aW9uYWwgb2JqZWN0IHRvIGJlIHVzZWQgYXMgYHRoaXNgIHdoZW4gY2FsbGluZyB0aGUgdmFsaWRhdGlvbiBjaGVjayBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJBZnRlckRvY3VtZW50KGNoZWNrQWZ0ZXIsIHRoaXNPYmogPSB0aGlzKSB7XG4gICAgICAgIHRoaXMuZW50cmllc0FmdGVyLnB1c2godGhpcy53cmFwUHJlcGFyYXRpb25FeGNlcHRpb24oY2hlY2tBZnRlciwgJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0ZWFyLWRvd24gb2YgdGhlIHZhbGlkYXRpb24nLCB0aGlzT2JqKSk7XG4gICAgfVxuICAgIHdyYXBQcmVwYXJhdGlvbkV4Y2VwdGlvbihjaGVjaywgbWVzc2FnZUNvbnRleHQsIHRoaXNPYmopIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jIChyb290Tm9kZSwgYWNjZXB0LCBjYXRlZ29yaWVzLCBjYW5jZWxUb2tlbikgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFeGNlcHRpb24oKCkgPT4gY2hlY2suY2FsbCh0aGlzT2JqLCByb290Tm9kZSwgYWNjZXB0LCBjYXRlZ29yaWVzLCBjYW5jZWxUb2tlbiksIG1lc3NhZ2VDb250ZXh0LCBhY2NlcHQsIHJvb3ROb2RlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNoZWNrc0JlZm9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc0JlZm9yZTtcbiAgICB9XG4gICAgZ2V0IGNoZWNrc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzQWZ0ZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi1yZWdpc3RyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/validation/validation-registry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/ast-descriptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/ast-descriptions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultAstNodeDescriptionProvider: () => (/* binding */ DefaultAstNodeDescriptionProvider),\n/* harmony export */   DefaultReferenceDescriptionProvider: () => (/* binding */ DefaultReferenceDescriptionProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../syntax-tree.js */ \"(ssr)/./node_modules/langium/lib/syntax-tree.js\");\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/cst-utils.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/uri-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultAstNodeDescriptionProvider {\n    constructor(services) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document) {\n        const doc = document !== null && document !== void 0 ? document : (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);\n        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment;\n        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)(node.$cstNode),\n            type: node.$type,\n            documentUri: doc.uri,\n            path\n        };\n    }\n}\nclass DefaultReferenceDescriptionProvider {\n    constructor(services) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.streamAst)(rootNode)) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_3__.interruptAndCheck)(cancelToken);\n            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.streamReferences)(astNode).filter(refInfo => !(0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_4__.isLinkingError)(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)(refCstNode),\n            local: _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_5__.UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n}\n//# sourceMappingURL=ast-descriptions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2FzdC1kZXNjcmlwdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1Y7QUFDOEI7QUFDdkI7QUFDSTtBQUNiO0FBQzFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnRUFBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDLFFBQVEscUdBQXFHLHNFQUFpQjtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QixzRUFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUVBQWlCO0FBQ3RFO0FBQ0E7QUFDQSw4QkFBOEIsOERBQVM7QUFDdkMsa0JBQWtCLDBFQUFpQjtBQUNuQyxZQUFZLHFFQUFnQiw2QkFBNkIsK0RBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzRUFBaUI7QUFDdEMsbUJBQW1CLHlEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHdvcmtzcGFjZVxcYXN0LWRlc2NyaXB0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBpc0xpbmtpbmdFcnJvciB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IGdldERvY3VtZW50LCBzdHJlYW1Bc3QsIHN0cmVhbVJlZmVyZW5jZXMgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgdG9Eb2N1bWVudFNlZ21lbnQgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaW50ZXJydXB0QW5kQ2hlY2sgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuYXN0Tm9kZUxvY2F0b3IgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZUxvY2F0b3I7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgfVxuICAgIGNyZWF0ZURlc2NyaXB0aW9uKG5vZGUsIG5hbWUsIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50ICE9PSBudWxsICYmIGRvY3VtZW50ICE9PSB2b2lkIDAgPyBkb2N1bWVudCA6IGdldERvY3VtZW50KG5vZGUpO1xuICAgICAgICBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiAobmFtZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWUobm9kZSkpO1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5hc3ROb2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aChub2RlKTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYXQgcGF0aCAke3BhdGh9IGhhcyBubyBuYW1lLmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lTm9kZVNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IG5hbWVTZWdtZW50R2V0dGVyID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiBuYW1lTm9kZVNlZ21lbnQgIT09IG51bGwgJiYgbmFtZU5vZGVTZWdtZW50ICE9PSB2b2lkIDAgPyBuYW1lTm9kZVNlZ21lbnQgOiAobmFtZU5vZGVTZWdtZW50ID0gdG9Eb2N1bWVudFNlZ21lbnQoKF9hID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZU5vZGUobm9kZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5vZGUuJGNzdE5vZGUpKTsgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZ2V0IG5hbWVTZWdtZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lU2VnbWVudEdldHRlcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblNlZ21lbnQ6IHRvRG9jdW1lbnRTZWdtZW50KG5vZGUuJGNzdE5vZGUpLFxuICAgICAgICAgICAgdHlwZTogbm9kZS4kdHlwZSxcbiAgICAgICAgICAgIGRvY3VtZW50VXJpOiBkb2MudXJpLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGVzY3JpcHRpb25zKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3QgZGVzY3IgPSBbXTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBhc3ROb2RlIG9mIHN0cmVhbUFzdChyb290Tm9kZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHN0cmVhbVJlZmVyZW5jZXMoYXN0Tm9kZSkuZmlsdGVyKHJlZkluZm8gPT4gIWlzTGlua2luZ0Vycm9yKHJlZkluZm8pKS5mb3JFYWNoKHJlZkluZm8gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGxvZ2dpbmcgYSB3YXJuaW5nIG9yIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIERvY3VtZW50U3RhdGUgaXMgPCB0aGFuIExpbmtlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5jcmVhdGVEZXNjcmlwdGlvbihyZWZJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3IucHVzaChkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyO1xuICAgIH1cbiAgICBjcmVhdGVEZXNjcmlwdGlvbihyZWZJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGVEZXNjciA9IHJlZkluZm8ucmVmZXJlbmNlLiRub2RlRGVzY3JpcHRpb247XG4gICAgICAgIGNvbnN0IHJlZkNzdE5vZGUgPSByZWZJbmZvLnJlZmVyZW5jZS4kcmVmTm9kZTtcbiAgICAgICAgaWYgKCF0YXJnZXROb2RlRGVzY3IgfHwgIXJlZkNzdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jVXJpID0gZ2V0RG9jdW1lbnQocmVmSW5mby5jb250YWluZXIpLnVyaTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZVVyaTogZG9jVXJpLFxuICAgICAgICAgICAgc291cmNlUGF0aDogdGhpcy5ub2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aChyZWZJbmZvLmNvbnRhaW5lciksXG4gICAgICAgICAgICB0YXJnZXRVcmk6IHRhcmdldE5vZGVEZXNjci5kb2N1bWVudFVyaSxcbiAgICAgICAgICAgIHRhcmdldFBhdGg6IHRhcmdldE5vZGVEZXNjci5wYXRoLFxuICAgICAgICAgICAgc2VnbWVudDogdG9Eb2N1bWVudFNlZ21lbnQocmVmQ3N0Tm9kZSksXG4gICAgICAgICAgICBsb2NhbDogVXJpVXRpbHMuZXF1YWxzKHRhcmdldE5vZGVEZXNjci5kb2N1bWVudFVyaSwgZG9jVXJpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC1kZXNjcmlwdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/ast-descriptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/ast-node-locator.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/ast-node-locator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultAstNodeLocator: () => (/* binding */ DefaultAstNodeLocator)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass DefaultAstNodeLocator {\n    constructor() {\n        this.segmentSeparator = '/';\n        this.indexSeparator = '@';\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return '';\n    }\n    getPathSegment({ $containerProperty, $containerIndex }) {\n        if (!$containerProperty) {\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n}\n//# sourceMappingURL=ast-node-locator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2FzdC1ub2RlLWxvY2F0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcd29ya3NwYWNlXFxhc3Qtbm9kZS1sb2NhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRTZXBhcmF0b3IgPSAnLyc7XG4gICAgICAgIHRoaXMuaW5kZXhTZXBhcmF0b3IgPSAnQCc7XG4gICAgfVxuICAgIGdldEFzdE5vZGVQYXRoKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuJGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyUGF0aCA9IHRoaXMuZ2V0QXN0Tm9kZVBhdGgobm9kZS4kY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnQgPSB0aGlzLmdldFBhdGhTZWdtZW50KG5vZGUpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVBhdGggPSBjb250YWluZXJQYXRoICsgdGhpcy5zZWdtZW50U2VwYXJhdG9yICsgbmV3U2VnbWVudDtcbiAgICAgICAgICAgIHJldHVybiBub2RlUGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldFBhdGhTZWdtZW50KHsgJGNvbnRhaW5lclByb3BlcnR5LCAkY29udGFpbmVySW5kZXggfSkge1xuICAgICAgICBpZiAoISRjb250YWluZXJQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAnJGNvbnRhaW5lclByb3BlcnR5JyBpbiBBU1Qgbm9kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRjb250YWluZXJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lclByb3BlcnR5ICsgdGhpcy5pbmRleFNlcGFyYXRvciArICRjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGNvbnRhaW5lclByb3BlcnR5O1xuICAgIH1cbiAgICBnZXRBc3ROb2RlKG5vZGUsIHBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KHRoaXMuc2VnbWVudFNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBzZWdtZW50cy5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c1ZhbHVlIHx8IGN1cnJlbnRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5SW5kZXggPSBjdXJyZW50VmFsdWUuaW5kZXhPZih0aGlzLmluZGV4U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBwcm9wZXJ0eUluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUluZGV4ID0gcGFyc2VJbnQoY3VycmVudFZhbHVlLnN1YnN0cmluZyhwcm9wZXJ0eUluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gcHJldmlvdXNWYWx1ZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5ID09PSBudWxsIHx8IGFycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJheVthcnJheUluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlW2N1cnJlbnRWYWx1ZV07XG4gICAgICAgIH0sIG5vZGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC1ub2RlLWxvY2F0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/ast-node-locator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/configuration.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/configuration.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultConfigurationProvider: () => (/* binding */ DefaultConfigurationProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/event.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/events.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Base configuration provider for building up other configuration providers\n */\nclass DefaultConfigurationProvider {\n    constructor(services) {\n        this._ready = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.onConfigurationSectionUpdateEmitter = new _utils_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter();\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => ({\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                }));\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change) {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            const configuration = change.settings[section];\n            this.updateSectionConfiguration(section, configuration);\n            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n    get onConfigurationSectionUpdate() {\n        return this.onConfigurationSectionUpdateEmitter.event;\n    }\n}\n//# sourceMappingURL=configuration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQkFBMEIsNkRBQVE7QUFDbEM7QUFDQTtBQUNBLHVEQUF1RCxvREFBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx3b3Jrc3BhY2VcXGNvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uL3V0aWxzL2V2ZW50LmpzJztcbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG4vKipcbiAqIEJhc2UgY29uZmlndXJhdGlvbiBwcm92aWRlciBmb3IgYnVpbGRpbmcgdXAgb3RoZXIgY29uZmlndXJhdGlvbiBwcm92aWRlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy53b3Jrc3BhY2VDb25maWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgIH1cbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLndvcmtzcGFjZUNvbmZpZyA9IChfYiA9IChfYSA9IHBhcmFtcy5jYXBhYmlsaXRpZXMud29ya3NwYWNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlndXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy53b3Jrc3BhY2VDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMucmVnaXN0ZXIoLi4uKSBpcyBhIGZ1bmN0aW9uIHRvIGJlIHByb3ZpZGVkIGJ5IHRoZSBjYWxsaW5nIGxhbmd1YWdlIHNlcnZlciBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyAgZGVjb3VwbGluZyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gdGhlIGNvbmNyZXRlIExTUCBpbXBsZW1lbnRhdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgTFNQIENvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5hbGw7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyBmb3IgYWxsIGxhbmd1YWdlc1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uOiBsYW5ndWFnZXMubWFwKGxhbmcgPT4gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZmV0Y2hDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbiguLi4pIGlzIGEgZnVuY3Rpb24gdG8gYmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxpbmcgbGFuZ3VhZ2Ugc2VydmVyIGZvciB0aGUgc2FrZSBvZlxuICAgICAgICAgICAgICAgIC8vICBkZWNvdXBsaW5nIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSB0aGUgY29uY3JldGUgTFNQIGltcGxlbWVudGF0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBMU1AgQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1RvVXBkYXRlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuYWxsLm1hcChsYW5nID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjb25maWd1cmF0aW9uIGNoYW5nZXMgZm9yIGFsbCBsYW5ndWFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgd29ya3NwYWNlIGNvbmZpZ3VyYXRpb25zIChkZWZhdWx0IHNjb3BlIFVSSSlcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWdzID0gYXdhaXQgcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbihjb25maWdUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uZmlnVG9VcGRhdGUuZm9yRWFjaCgoY29uZiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbkNvbmZpZ3VyYXRpb24oY29uZi5zZWN0aW9uLCBjb25maWdzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVwZGF0ZXMgdGhlIGNhY2hlZCBjb25maWd1cmF0aW9ucyB1c2luZyB0aGUgYGNoYW5nZWAgbm90aWZpY2F0aW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlIFRoZSBwYXJhbWV0ZXJzIG9mIGEgY2hhbmdlIGNvbmZpZ3VyYXRpb24gbm90aWZpY2F0aW9uLlxuICAgICAqIGBzZXR0aW5nc2AgcHJvcGVydHkgb2YgdGhlIGNoYW5nZSBvYmplY3QgY291bGQgYmUgZXhwcmVzc2VkIGFzIGBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBhbnk+PmBcbiAgICAgKi9cbiAgICB1cGRhdGVDb25maWd1cmF0aW9uKGNoYW5nZSkge1xuICAgICAgICBpZiAoIWNoYW5nZS5zZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZS5zZXR0aW5ncykuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjaGFuZ2Uuc2V0dGluZ3Nbc2VjdGlvbl07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlY3Rpb25Db25maWd1cmF0aW9uKHNlY3Rpb24sIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlci5maXJlKHsgc2VjdGlvbiwgY29uZmlndXJhdGlvbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlY3Rpb25Db25maWd1cmF0aW9uKHNlY3Rpb24sIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1tzZWN0aW9uXSA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UuXG4gICAgKlxuICAgICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZFxuICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gQ29uZmlndXJhdGlvbiBuYW1lXG4gICAgKi9cbiAgICBhc3luYyBnZXRDb25maWd1cmF0aW9uKGxhbmd1YWdlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZHk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25OYW1lID0gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Nbc2VjdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1tzZWN0aW9uTmFtZV1bY29uZmlndXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TZWN0aW9uTmFtZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiBgJHtsYW5ndWFnZUlkfWA7XG4gICAgfVxuICAgIGdldCBvbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlci5ldmVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWd1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/configuration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/document-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/document-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultDocumentBuilder: () => (/* binding */ DefaultDocumentBuilder)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/disposable.js */ \"(ssr)/./node_modules/langium/lib/utils/disposable.js\");\n/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ \"(ssr)/./node_modules/langium/lib/utils/collections.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../validation/validation-registry.js */ \"(ssr)/./node_modules/langium/lib/validation/validation-registry.js\");\n/* harmony import */ var _documents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documents.js */ \"(ssr)/./node_modules/langium/lib/workspace/documents.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\nclass DefaultDocumentBuilder {\n    constructor(services) {\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: ['built-in', 'fast']\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();\n        this.documentPhaseListeners = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();\n        this.buildState = new Map();\n        this.documentBuildWaiters = new Map();\n        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {\n        var _a, _b;\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Validated) {\n                if (typeof options.validation === 'boolean' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                }\n                else if (typeof options.validation === 'object') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.ValidationCategory.all;\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), { categories })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            }\n            else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {\n        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\n                newDocument.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.stream)(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.ComputedScopes);\n            doc.diagnostics = undefined;\n        });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);\n        // Collect and sort all documents that we should rebuild\n        const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all\n            .filter(doc => {\n            var _a;\n            // This includes those that were reported as changed and those that we selected for relinking\n            return doc.state < _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        })\n            .toArray());\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n    /**\n     * Sort the given documents by priority. By default, documents with an open text document are prioritized.\n     * This is useful to ensure that visible documents show their diagnostics before all other documents.\n     *\n     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\n     * in files that are currently not opened in the editor.\n     */\n    sortDocuments(documents) {\n        let left = 0;\n        let right = documents.length - 1;\n        while (left < right) {\n            while (left < documents.length && this.hasTextDocument(documents[left])) {\n                left++;\n            }\n            while (right >= 0 && !this.hasTextDocument(documents[right])) {\n                right--;\n            }\n            if (left < right) {\n                [documents[left], documents[right]] = [documents[right], documents[left]];\n            }\n        }\n        return documents;\n    }\n    hasTextDocument(doc) {\n        var _a;\n        return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));\n    }\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    shouldRelink(document, changedUris) {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n    /**\n     * Build the given documents by stepping through all build phases. If a document's state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     *\n     * @param documents The documents to build.\n     * @param options the {@link BuildOptions} to use.\n     * @param cancelToken A cancellation token that can be used to cancel the build.\n     * @returns A promise that resolves when the build is done.\n     */\n    async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));\n        // 1. Index content\n        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));\n        // 2. Compute scopes\n        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.ComputedScopes, cancelToken, async (doc) => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n    /**\n     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\n     *\n     * @param documents collection of documents to be built\n     * @param options the {@link BuildOptions} to use\n     */\n    prepareBuild(documents, options) {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state === null || state === void 0 ? void 0 : state.result\n                });\n            }\n        }\n    }\n    /**\n     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\n     *\n     * @param documents The array of documents to process.\n     * @param targetState The target {@link DocumentState} to bring the documents to.\n     * @param cancelToken A token that can be used to cancel the operation.\n     * @param callback A function to be called for each document.\n     * @returns A promise that resolves when all documents have been processed or the operation is canceled.\n     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\n     */\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter(doc => doc.state < targetState);\n        for (const document of filtered) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);\n            await callback(document);\n            document.state = targetState;\n            await this.notifyDocumentPhase(document, targetState, cancelToken);\n        }\n        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state\n        // For example, this happens in case the cancellation triggers between the processing of two documents\n        // Or files that were picked up during the workspace initialization\n        const targetStateDocs = documents.filter(doc => doc.state === targetState);\n        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    onDocumentPhase(targetState, callback) {\n        this.documentPhaseListeners.add(targetState, callback);\n        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {\n            this.documentPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = undefined;\n        if (uriOrToken && 'path' in uriOrToken) {\n            uri = uriOrToken;\n        }\n        else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None);\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        }\n        else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.OperationCancelled);\n            });\n        });\n    }\n    async notifyDocumentPhase(document, state, cancelToken) {\n        const listeners = this.documentPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            try {\n                await listener(document, cancelToken);\n            }\n            catch (err) {\n                // Ignore cancellation errors\n                // We want to finish the listeners before throwing\n                if (!(0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.isOperationCancelled)(err)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) {\n            // Don't notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        const listenersCopy = listeners.slice();\n        for (const listener of listenersCopy) {\n            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it's set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        }\n        else {\n            document.diagnostics = diagnostics;\n        }\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            }\n            else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n}\n//# sourceMappingURL=document-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2RvY3VtZW50LWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1Q7QUFDRDtBQUNxRDtBQUM1RDtBQUM4QjtBQUMzQjtBQUN4QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVE7QUFDL0MsMENBQTBDLDJEQUFRO0FBQ2xEO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQixxRUFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdEQUFhO0FBQ2hEO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILGtGQUFrQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHlCQUF5QixZQUFZO0FBQ25ILGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3Qiw2Q0FBNkMsd0RBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxRUFBaUI7QUFDbEUsNEJBQTRCLHdEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGtCQUFrQjtBQUM5RixvQ0FBb0Msd0RBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEVBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQWE7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQWE7QUFDekQ7QUFDQSw0Q0FBNEMsd0RBQWE7QUFDekQ7QUFDQSw0Q0FBNEMsd0RBQWE7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0Qyx3REFBYTtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNENBQTRDLHdEQUFhO0FBQ3pEO0FBQ0E7QUFDQSxnREFBZ0Qsd0RBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDBCQUEwQjtBQUMxRjtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixvQkFBb0I7QUFDM0c7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFVO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQVU7QUFDekI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHFFQUFpQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1RUFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBa0I7QUFDekMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZFQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwRUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLCtJQUErSSxrRkFBa0I7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx3b3Jrc3BhY2VcXGRvY3VtZW50LWJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL3V0aWxzL2Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICcuLi91dGlscy9jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25DYW5jZWxsZWQsIGludGVycnVwdEFuZENoZWNrLCBpc09wZXJhdGlvbkNhbmNlbGxlZCB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFZhbGlkYXRpb25DYXRlZ29yeSB9IGZyb20gJy4uL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudFN0YXRlIH0gZnJvbSAnLi9kb2N1bWVudHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHREb2N1bWVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQnVpbGRPcHRpb25zID0ge1xuICAgICAgICAgICAgLy8gRGVmYXVsdDogcnVuIG9ubHkgdGhlIGJ1aWx0LWluIHZhbGlkYXRpb24gY2hlY2tzIGFuZCB0aG9zZSBpbiB0aGUgX2Zhc3RfIGNhdGVnb3J5IChpbmNsdWRlcyB0aG9zZSB3aXRob3V0IGNhdGVnb3J5KVxuICAgICAgICAgICAgdmFsaWRhdGlvbjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IFsnYnVpbHQtaW4nLCAnZmFzdCddXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycyA9IG5ldyBNdWx0aU1hcCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50UGhhc2VMaXN0ZW5lcnMgPSBuZXcgTXVsdGlNYXAoKTtcbiAgICAgICAgdGhpcy5idWlsZFN0YXRlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50QnVpbGRXYWl0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzID0gc2VydmljZXMud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeSA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRGYWN0b3J5O1xuICAgICAgICB0aGlzLnRleHREb2N1bWVudHMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuVGV4dERvY3VtZW50cztcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuSW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGQoZG9jdW1lbnRzLCBvcHRpb25zID0ge30sIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuc3RhdGUgPT09IERvY3VtZW50U3RhdGUuVmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZhbGlkYXRpb24gPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgcmUtcnVubmluZyBhbGwgdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSBEb2N1bWVudFN0YXRlLkluZGV4ZWRSZWZlcmVuY2VzO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaWFnbm9zdGljcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy52YWxpZGF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWlsZFN0YXRlID0gdGhpcy5idWlsZFN0YXRlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NhdGVnb3JpZXMgPSAoX2EgPSBidWlsZFN0YXRlID09PSBudWxsIHx8IGJ1aWxkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1aWxkU3RhdGUucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsaWRhdGlvbkNoZWNrcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGlvbiB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgd2FzIHJlcXVlc3RlZCBmb3IgYSBkb2N1bWVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcGFydGx5IHZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBtZXJnZSB0aGUgcHJldmlvdXMgdmFsaWRhdGlvbiBjYXRlZ29yaWVzIHdpdGggdGhlIG5ldyBvbmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcmllcyA9IChfYiA9IG9wdGlvbnMudmFsaWRhdGlvbi5jYXRlZ29yaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBWYWxpZGF0aW9uQ2F0ZWdvcnkuYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXMuZmlsdGVyKGMgPT4gIXByZXZpb3VzQ2F0ZWdvcmllcy5pbmNsdWRlcyhjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnZhbGlkYXRpb24pLCB7IGNhdGVnb3JpZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBidWlsZFN0YXRlLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5JbmRleGVkUmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQ6IGZvcmdldCBhbnkgcHJldmlvdXMgYnVpbGQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0VXBkYXRlKGRvY3VtZW50cy5tYXAoZSA9PiBlLnVyaSksIFtdKTtcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZERvY3VtZW50cyhkb2N1bWVudHMsIG9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKGNoYW5nZWQsIGRlbGV0ZWQsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBtZXRhZGF0YSBvZiBkb2N1bWVudHMgdGhhdCBhcmUgcmVwb3J0ZWQgYXMgZGVsZXRlZFxuICAgICAgICBmb3IgKGNvbnN0IGRlbGV0ZWRVcmkgb2YgZGVsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmRlbGV0ZURvY3VtZW50KGRlbGV0ZWRVcmkpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLmRlbGV0ZShkZWxldGVkVXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIucmVtb3ZlKGRlbGV0ZWRVcmkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc3RhdGUgb2YgYWxsIGNoYW5nZWQgZG9jdW1lbnRzIHRvIGBDaGFuZ2VkYCBzbyB0aGV5IGFyZSBjb21wbGV0ZWx5IHJlYnVpbHRcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2VkVXJpIG9mIGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRhdGVkID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmludmFsaWRhdGVEb2N1bWVudChjaGFuZ2VkVXJpKTtcbiAgICAgICAgICAgIGlmICghaW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjcmVhdGUgYW4gdW5wYXJzZWQsIGludmFsaWQgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHBhcnNlZCBhcyBzb29uIGFzIHdlIHJlYWNoIHRoZSBmaXJzdCBkb2N1bWVudCBidWlsZGVyIHBoYXNlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRvIGNhbmNlbCB0aGUgcGFyc2luZyBwcm9jZXNzIGxhdGVyIGluIGNhc2Ugd2UgbmVlZCBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEb2N1bWVudCA9IHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeS5mcm9tTW9kZWwoeyAkdHlwZTogJ0lOVkFMSUQnIH0sIGNoYW5nZWRVcmkpO1xuICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50LnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5DaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cy5hZGREb2N1bWVudChuZXdEb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1aWxkU3RhdGUuZGVsZXRlKGNoYW5nZWRVcmkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHRoYXQgc2hvdWxkIGJlIHJlbGlua2VkIHRvIGBDb21wdXRlZFNjb3Blc2AgKGlmIG5vdCBhbHJlYWR5IGxvd2VyKVxuICAgICAgICBjb25zdCBhbGxDaGFuZ2VkVXJpcyA9IHN0cmVhbShjaGFuZ2VkKS5jb25jYXQoZGVsZXRlZCkubWFwKHVyaSA9PiB1cmkudG9TdHJpbmcoKSkudG9TZXQoKTtcbiAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmFsbFxuICAgICAgICAgICAgLmZpbHRlcihkb2MgPT4gIWFsbENoYW5nZWRVcmlzLmhhcyhkb2MudXJpLnRvU3RyaW5nKCkpICYmIHRoaXMuc2hvdWxkUmVsaW5rKGRvYywgYWxsQ2hhbmdlZFVyaXMpKVxuICAgICAgICAgICAgLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvYy51cmkpLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICAgICAgbGlua2VyLnVubGluayhkb2MpO1xuICAgICAgICAgICAgZG9jLnN0YXRlID0gTWF0aC5taW4oZG9jLnN0YXRlLCBEb2N1bWVudFN0YXRlLkNvbXB1dGVkU2NvcGVzKTtcbiAgICAgICAgICAgIGRvYy5kaWFnbm9zdGljcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgb2YgdGhlIHVwZGF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXRVcGRhdGUoY2hhbmdlZCwgZGVsZXRlZCk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgaW50ZXJydXB0aW5nIHRoZSBleGVjdXRpb24gYWZ0ZXIgYWxsIHN0YXRlIGNoYW5nZXMgYXJlIGRvbmVcbiAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAvLyBDb2xsZWN0IGFuZCBzb3J0IGFsbCBkb2N1bWVudHMgdGhhdCB3ZSBzaG91bGQgcmVidWlsZFxuICAgICAgICBjb25zdCByZWJ1aWxkRG9jdW1lbnRzID0gdGhpcy5zb3J0RG9jdW1lbnRzKHRoaXMubGFuZ2l1bURvY3VtZW50cy5hbGxcbiAgICAgICAgICAgIC5maWx0ZXIoZG9jID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhvc2UgdGhhdCB3ZXJlIHJlcG9ydGVkIGFzIGNoYW5nZWQgYW5kIHRob3NlIHRoYXQgd2Ugc2VsZWN0ZWQgZm9yIHJlbGlua2luZ1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5zdGF0ZSA8IERvY3VtZW50U3RhdGUuTGlua2VkXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyB0aG9zZSBmb3Igd2hpY2ggYSBwcmV2aW91cyBidWlsZCBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICAgICAgICAgICAgICB8fCAhKChfYSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoZG9jLnVyaS50b1N0cmluZygpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbXBsZXRlZCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudG9BcnJheSgpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZERvY3VtZW50cyhyZWJ1aWxkRG9jdW1lbnRzLCB0aGlzLnVwZGF0ZUJ1aWxkT3B0aW9ucywgY2FuY2VsVG9rZW4pO1xuICAgIH1cbiAgICBhc3luYyBlbWl0VXBkYXRlKGNoYW5nZWQsIGRlbGV0ZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy51cGRhdGVMaXN0ZW5lcnMubWFwKGxpc3RlbmVyID0+IGxpc3RlbmVyKGNoYW5nZWQsIGRlbGV0ZWQpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnQgdGhlIGdpdmVuIGRvY3VtZW50cyBieSBwcmlvcml0eS4gQnkgZGVmYXVsdCwgZG9jdW1lbnRzIHdpdGggYW4gb3BlbiB0ZXh0IGRvY3VtZW50IGFyZSBwcmlvcml0aXplZC5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBlbnN1cmUgdGhhdCB2aXNpYmxlIGRvY3VtZW50cyBzaG93IHRoZWlyIGRpYWdub3N0aWNzIGJlZm9yZSBhbGwgb3RoZXIgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBpbXByb3ZlcyB0aGUgcmVzcG9uc2l2ZW5lc3MgaW4gbGFyZ2Ugd29ya3NwYWNlcyBhcyB1c2VycyB1c3VhbGx5IGRvbid0IGNhcmUgYWJvdXQgZGlhZ25vc3RpY3NcbiAgICAgKiBpbiBmaWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgbm90IG9wZW5lZCBpbiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIHNvcnREb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0ID0gZG9jdW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0IDwgZG9jdW1lbnRzLmxlbmd0aCAmJiB0aGlzLmhhc1RleHREb2N1bWVudChkb2N1bWVudHNbbGVmdF0pKSB7XG4gICAgICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHJpZ2h0ID49IDAgJiYgIXRoaXMuaGFzVGV4dERvY3VtZW50KGRvY3VtZW50c1tyaWdodF0pKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBbZG9jdW1lbnRzW2xlZnRdLCBkb2N1bWVudHNbcmlnaHRdXSA9IFtkb2N1bWVudHNbcmlnaHRdLCBkb2N1bWVudHNbbGVmdF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudHM7XG4gICAgfVxuICAgIGhhc1RleHREb2N1bWVudChkb2MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoX2EgPSB0aGlzLnRleHREb2N1bWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZG9jLnVyaSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBkb2N1bWVudCBzaG91bGQgYmUgcmVsaW5rZWQgYWZ0ZXIgY2hhbmdlcyB3ZXJlIGZvdW5kIGluIHRoZSBnaXZlbiBVUklzLlxuICAgICAqL1xuICAgIHNob3VsZFJlbGluayhkb2N1bWVudCwgY2hhbmdlZFVyaXMpIHtcbiAgICAgICAgLy8gUmVsaW5rIGRvY3VtZW50cyB3aXRoIGxpbmtpbmcgZXJyb3JzIC0tIG1heWJlIHRob3NlIHJlZmVyZW5jZXMgY2FuIGJlIHJlc29sdmVkIG5vd1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVmZXJlbmNlcy5zb21lKHJlZiA9PiByZWYuZXJyb3IgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIGFmZmVjdGVkIGJ5IGFueSBvZiB0aGUgY2hhbmdlZCBVUklzXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5pc0FmZmVjdGVkKGRvY3VtZW50LCBjaGFuZ2VkVXJpcyk7XG4gICAgfVxuICAgIG9uVXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnVwZGF0ZUxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBnaXZlbiBkb2N1bWVudHMgYnkgc3RlcHBpbmcgdGhyb3VnaCBhbGwgYnVpbGQgcGhhc2VzLiBJZiBhIGRvY3VtZW50J3Mgc3RhdGUgaW5kaWNhdGVzXG4gICAgICogdGhhdCBhIGNlcnRhaW4gYnVpbGQgcGhhc2UgaXMgYWxyZWFkeSBkb25lLCB0aGUgcGhhc2UgaXMgc2tpcHBlZCBmb3IgdGhhdCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgVGhlIGRvY3VtZW50cyB0byBidWlsZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUge0BsaW5rIEJ1aWxkT3B0aW9uc30gdG8gdXNlLlxuICAgICAqIEBwYXJhbSBjYW5jZWxUb2tlbiBBIGNhbmNlbGxhdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYnVpbGQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYnVpbGQgaXMgZG9uZS5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZERvY3VtZW50cyhkb2N1bWVudHMsIG9wdGlvbnMsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZUJ1aWxkKGRvY3VtZW50cywgb3B0aW9ucyk7XG4gICAgICAgIC8vIDAuIFBhcnNlIGNvbnRlbnRcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5QYXJzZWQsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy5sYW5naXVtRG9jdW1lbnRGYWN0b3J5LnVwZGF0ZShkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIDEuIEluZGV4IGNvbnRlbnRcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5JbmRleGVkQ29udGVudCwgY2FuY2VsVG9rZW4sIGRvYyA9PiB0aGlzLmluZGV4TWFuYWdlci51cGRhdGVDb250ZW50KGRvYywgY2FuY2VsVG9rZW4pKTtcbiAgICAgICAgLy8gMi4gQ29tcHV0ZSBzY29wZXNcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3BlcywgY2FuY2VsVG9rZW4sIGFzeW5jIChkb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlQ29tcHV0YXRpb24gPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2MudXJpKS5yZWZlcmVuY2VzLlNjb3BlQ29tcHV0YXRpb247XG4gICAgICAgICAgICBkb2MucHJlY29tcHV0ZWRTY29wZXMgPSBhd2FpdCBzY29wZUNvbXB1dGF0aW9uLmNvbXB1dGVMb2NhbFNjb3Blcyhkb2MsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDMuIExpbmtpbmdcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5MaW5rZWQsIGNhbmNlbFRva2VuLCBkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlua2VyID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jLnVyaSkucmVmZXJlbmNlcy5MaW5rZXI7XG4gICAgICAgICAgICByZXR1cm4gbGlua2VyLmxpbmsoZG9jLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA0LiBJbmRleCByZWZlcmVuY2VzXG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuSW5kZXhlZFJlZmVyZW5jZXMsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy5pbmRleE1hbmFnZXIudXBkYXRlUmVmZXJlbmNlcyhkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIDUuIFZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdG9CZVZhbGlkYXRlZCA9IGRvY3VtZW50cy5maWx0ZXIoZG9jID0+IHRoaXMuc2hvdWxkVmFsaWRhdGUoZG9jKSk7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZSh0b0JlVmFsaWRhdGVkLCBEb2N1bWVudFN0YXRlLlZhbGlkYXRlZCwgY2FuY2VsVG9rZW4sIGRvYyA9PiB0aGlzLnZhbGlkYXRlKGRvYywgY2FuY2VsVG9rZW4pKTtcbiAgICAgICAgLy8gSWYgd2UndmUgbWFkZSBpdCB0byB0aGlzIHBvaW50IHdpdGhvdXQgYmVpbmcgY2FuY2VsbGVkLCB3ZSBjYW4gbWFyayB0aGUgYnVpbGQgc3RhdGUgYXMgY29tcGxldGVkLlxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5idWlsZFN0YXRlLmdldChkb2MudXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHByaW9yIHRvIGJlZ2lubmluZyB0aGUgYnVpbGQgcHJvY2VzcyB0byB1cGRhdGUgdGhlIHtAbGluayBEb2N1bWVudEJ1aWxkU3RhdGV9IGZvciBlYWNoIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIGNvbGxlY3Rpb24gb2YgZG9jdW1lbnRzIHRvIGJlIGJ1aWx0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIHtAbGluayBCdWlsZE9wdGlvbnN9IHRvIHVzZVxuICAgICAqL1xuICAgIHByZXBhcmVCdWlsZChkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBkb2MudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBoYXMgbm8gcHJldmlvdXMgYnVpbGQgc3RhdGUsIHdlIHNldCBpdC4gSWYgaXQgaGFzIG9uZSwgYnV0IGl0J3MgYWxyZWFkeSBtYXJrZWRcbiAgICAgICAgICAgIC8vIGFzIGNvbXBsZXRlZCwgd2Ugb3ZlcndyaXRlIGl0LiBJZiB0aGUgcHJldmlvdXMgYnVpbGQgd2FzIG5vdCBjb21wbGV0ZWQsIHdlIGtlZXAgaXRzIHN0YXRlXG4gICAgICAgICAgICAvLyBhbmQgY29udGludWUgd2hlcmUgaXQgd2FzIGNhbmNlbGxlZC5cbiAgICAgICAgICAgIGlmICghc3RhdGUgfHwgc3RhdGUuY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUucmVzdWx0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhIGNhbmNlbGFibGUgb3BlcmF0aW9uIG9uIGEgc2V0IG9mIGRvY3VtZW50cyB0byBicmluZyB0aGVtIHRvIGEgc3BlY2lmaWVkIHtAbGluayBEb2N1bWVudFN0YXRlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgVGhlIGFycmF5IG9mIGRvY3VtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSBUaGUgdGFyZ2V0IHtAbGluayBEb2N1bWVudFN0YXRlfSB0byBicmluZyB0aGUgZG9jdW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSBjYW5jZWxUb2tlbiBBIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGRvY3VtZW50cyBoYXZlIGJlZW4gcHJvY2Vzc2VkIG9yIHRoZSBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGBPcGVyYXRpb25DYW5jZWxsZWRgIGlmIHRoZSBvcGVyYXRpb24gaXMgY2FuY2VsZWQgdmlhIGEgYENhbmNlbGxhdGlvblRva2VuYC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgdGFyZ2V0U3RhdGUsIGNhbmNlbFRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGRvY3VtZW50cy5maWx0ZXIoZG9jID0+IGRvYy5zdGF0ZSA8IHRhcmdldFN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBmaWx0ZXJlZCkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2soZG9jdW1lbnQpO1xuICAgICAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5RG9jdW1lbnRQaGFzZShkb2N1bWVudCwgdGFyZ2V0U3RhdGUsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgdXNlIGBmaWx0ZXJlZGAgaGVyZSwgYXMgdGhhdCB3aWxsIG1pc3MgZG9jdW1lbnRzIHRoYXQgaGF2ZSBwcmV2aW91c2x5IHJlYWNoZWQgdGhlIGN1cnJlbnQgdGFyZ2V0IHN0YXRlXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCB0aGlzIGhhcHBlbnMgaW4gY2FzZSB0aGUgY2FuY2VsbGF0aW9uIHRyaWdnZXJzIGJldHdlZW4gdGhlIHByb2Nlc3Npbmcgb2YgdHdvIGRvY3VtZW50c1xuICAgICAgICAvLyBPciBmaWxlcyB0aGF0IHdlcmUgcGlja2VkIHVwIGR1cmluZyB0aGUgd29ya3NwYWNlIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlRG9jcyA9IGRvY3VtZW50cy5maWx0ZXIoZG9jID0+IGRvYy5zdGF0ZSA9PT0gdGFyZ2V0U3RhdGUpO1xuICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeUJ1aWxkUGhhc2UodGFyZ2V0U3RhdGVEb2NzLCB0YXJnZXRTdGF0ZSwgY2FuY2VsVG9rZW4pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgIH1cbiAgICBvbkJ1aWxkUGhhc2UodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycy5hZGQodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycy5kZWxldGUodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRG9jdW1lbnRQaGFzZSh0YXJnZXRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudFBoYXNlTGlzdGVuZXJzLmFkZCh0YXJnZXRTdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFBoYXNlTGlzdGVuZXJzLmRlbGV0ZSh0YXJnZXRTdGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FpdFVudGlsKHN0YXRlLCB1cmlPclRva2VuLCBjYW5jZWxUb2tlbikge1xuICAgICAgICBsZXQgdXJpID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodXJpT3JUb2tlbiAmJiAncGF0aCcgaW4gdXJpT3JUb2tlbikge1xuICAgICAgICAgICAgdXJpID0gdXJpT3JUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbFRva2VuID0gdXJpT3JUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxUb2tlbiAhPT0gbnVsbCAmJiBjYW5jZWxUb2tlbiAhPT0gdm9pZCAwID8gY2FuY2VsVG9rZW4gOiAoY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKTtcbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0RG9jdW1lbnQodXJpKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5zdGF0ZSA+IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA+PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbmNlbFRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoT3BlcmF0aW9uQ2FuY2VsbGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVpbGREaXNwb3NhYmxlID0gdGhpcy5vbkJ1aWxkUGhhc2Uoc3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZERpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGNhbmNlbERpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0RG9jdW1lbnQodXJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQudXJpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbERpc3Bvc2FibGUgPSBjYW5jZWxUb2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoT3BlcmF0aW9uQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbm90aWZ5RG9jdW1lbnRQaGFzZShkb2N1bWVudCwgc3RhdGUsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZG9jdW1lbnRQaGFzZUxpc3RlbmVycy5nZXQoc3RhdGUpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnNDb3B5ID0gbGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzQ29weSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBsaXN0ZW5lcihkb2N1bWVudCwgY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBmaW5pc2ggdGhlIGxpc3RlbmVycyBiZWZvcmUgdGhyb3dpbmdcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBub3RpZnlCdWlsZFBoYXNlKGRvY3VtZW50cywgc3RhdGUsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBub3RpZnkgd2hlbiBubyBkb2N1bWVudCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmJ1aWxkUGhhc2VMaXN0ZW5lcnMuZ2V0KHN0YXRlKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzQ29weSA9IGxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVyc0NvcHkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIGF3YWl0IGxpc3RlbmVyKGRvY3VtZW50cywgY2FuY2VsVG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBkb2N1bWVudCBzaG91bGQgYmUgdmFsaWRhdGVkIGR1cmluZyBhIGJ1aWxkLiBUaGUgZGVmYXVsdFxuICAgICAqIGltcGxlbWVudGF0aW9uIGNoZWNrcyB0aGUgYHZhbGlkYXRpb25gIHByb3BlcnR5IG9mIHRoZSBidWlsZCBvcHRpb25zLiBJZiBpdCdzIHNldCB0byBgdHJ1ZWBcbiAgICAgKiBvciBhIGBWYWxpZGF0aW9uT3B0aW9uc2Agb2JqZWN0LCB0aGUgZG9jdW1lbnQgaXMgaW5jbHVkZWQgaW4gdGhlIHZhbGlkYXRpb24gcGhhc2UuXG4gICAgICovXG4gICAgc2hvdWxkVmFsaWRhdGUoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRCdWlsZE9wdGlvbnMoZG9jdW1lbnQpLnZhbGlkYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdmFsaWRhdGlvbiBjaGVja3Mgb24gdGhlIGdpdmVuIGRvY3VtZW50IGFuZCBzdG9yZSB0aGUgcmVzdWx0aW5nIGRpYWdub3N0aWNzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKiBJZiB0aGUgZG9jdW1lbnQgYWxyZWFkeSBjb250YWlucyBkaWFnbm9zdGljcywgdGhlIG5ldyBvbmVzIGFyZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZShkb2N1bWVudCwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jdW1lbnQudXJpKS52YWxpZGF0aW9uLkRvY3VtZW50VmFsaWRhdG9yO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uU2V0dGluZyA9IHRoaXMuZ2V0QnVpbGRPcHRpb25zKGRvY3VtZW50KS52YWxpZGF0aW9uO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHZhbGlkYXRpb25TZXR0aW5nID09PSAnb2JqZWN0JyA/IHZhbGlkYXRpb25TZXR0aW5nIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZURvY3VtZW50KGRvY3VtZW50LCBvcHRpb25zLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIGlmIChkb2N1bWVudC5kaWFnbm9zdGljcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlhZ25vc3RpY3MucHVzaCguLi5kaWFnbm9zdGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBleGVjdXRlZCB2YWxpZGF0aW9uIGluIHRoZSBidWlsZCBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIChfYSA9IHN0YXRlLnJlc3VsdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHN0YXRlLnJlc3VsdCA9IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhdGVnb3JpZXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmFsaWRhdGlvbkNhdGVnb3J5LmFsbDtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXN1bHQudmFsaWRhdGlvbkNoZWNrcykge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlc3VsdC52YWxpZGF0aW9uQ2hlY2tzLnB1c2goLi4ubmV3Q2F0ZWdvcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZXN1bHQudmFsaWRhdGlvbkNoZWNrcyA9IFsuLi5uZXdDYXRlZ29yaWVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWlsZE9wdGlvbnMoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jdW1lbnQtYnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/document-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/documents.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/workspace/documents.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultLangiumDocumentFactory: () => (/* binding */ DefaultLangiumDocumentFactory),\n/* harmony export */   DefaultLangiumDocuments: () => (/* binding */ DefaultLangiumDocuments),\n/* harmony export */   DocumentState: () => (/* binding */ DocumentState),\n/* harmony export */   TextDocument: () => (/* reexport safe */ vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__.TextDocument)\n/* harmony export */ });\n/* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documents.js */ \"(ssr)/./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\");\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\n\n\n\n\n\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nvar DocumentState;\n(function (DocumentState) {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    DocumentState[DocumentState[\"Changed\"] = 0] = \"Changed\";\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    DocumentState[DocumentState[\"Parsed\"] = 1] = \"Parsed\";\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    DocumentState[DocumentState[\"IndexedContent\"] = 2] = \"IndexedContent\";\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    DocumentState[DocumentState[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    DocumentState[DocumentState[\"Linked\"] = 4] = \"Linked\";\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    DocumentState[DocumentState[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    DocumentState[DocumentState[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nclass DefaultLangiumDocumentFactory {\n    constructor(services) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, token) {\n        uri = uri !== null && uri !== void 0 ? uri : _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(textDocument.uri);\n        if (_utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.is(token)) {\n            return this.createAsync(uri, textDocument, token);\n        }\n        else {\n            return this.create(uri, textDocument, token);\n        }\n    }\n    fromString(text, uri, token) {\n        if (_utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.is(token)) {\n            return this.createAsync(uri, text, token);\n        }\n        else {\n            return this.create(uri, text, token);\n        }\n    }\n    fromModel(model, uri) {\n        return this.create(uri, { $model: model });\n    }\n    create(uri, content, options) {\n        if (typeof content === 'string') {\n            const parseResult = this.parse(uri, content, options);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else if ('$model' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument(parseResult, uri);\n        }\n        else {\n            const parseResult = this.parse(uri, content.getText(), options);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === 'string') {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) {\n            Object.defineProperty(document, 'textDocument', {\n                value: textDocument\n            });\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, 'textDocument', {\n                get: textDocumentGetter\n            });\n        }\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text, options) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text, options);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = undefined;\n        return () => {\n            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__.TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : ''));\n        };\n    }\n}\nclass DefaultLangiumDocuments {\n    constructor(services) {\n        this.documentMap = new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get all() {\n        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        }\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\n            linker.unlink(langiumDoc);\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n//# sourceMappingURL=documents.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2RvY3VtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRTtBQUNwQjtBQUNlO0FBQ2pCO0FBQ0E7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUNoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUVBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9EQUFHO0FBQ3hELFlBQVkscUVBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRFQUFZO0FBQzdGO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxIYW16YVdvcmtcXE5leHRKU1xcVW5pdmVyc2FsLUVuZ2luZWVyaW5nLUNPXFxub2RlX21vZHVsZXNcXGxhbmdpdW1cXGxpYlxcd29ya3NwYWNlXFxkb2N1bWVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBSZS1leHBvcnQgJ1RleHREb2N1bWVudCcgZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCcgZm9yIGNvbnZlbmllbmNlLFxuICogIGluY2x1ZGluZyBib3RoIHR5cGUgX2FuZF8gc3ltYm9sIChuYW1lc3BhY2UpLCBhcyB3ZSBoZXJlIGFuZCB0aGVyZSBhbHNvIHJlZmVyIHRvIHRoZSBzeW1ib2wsXG4gKiAgdGhlIG92ZXJoZWFkIGlzIHZlcnkgc21hbGwsIGp1c3QgYSBmZXcga2lsb2J5dGVzLlxuICogRXZlcnl0aGluZyBlbHNlIG9mIHRoYXQgcGFja2FnZSAoYXQgdGhlIHRpbWUgY29udHJpYnV0aW5nKSBpcyBhbHNvIGRlZmluZWRcbiAqICBpbiAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sJyBvciAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzJy5cbiAqL1xuZXhwb3J0IHsgVGV4dERvY3VtZW50IH0gZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCc7XG5pbXBvcnQgeyBUZXh0RG9jdW1lbnQgfSBmcm9tICcuL2RvY3VtZW50cy5qcyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbi8qKlxuICogQSBkb2N1bWVudCBpcyBzdWJqZWN0IHRvIHNldmVyYWwgcGhhc2VzIHRoYXQgYXJlIHJ1biBpbiBwcmVkZWZpbmVkIG9yZGVyLiBBbnkgc3RhdGUgdmFsdWUgaW1wbGllcyB0aGF0XG4gKiBzbWFsbGVyIHN0YXRlIHZhbHVlcyBhcmUgZmluaXNoZWQgYXMgd2VsbC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudFN0YXRlO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCBoYXMgY2hhbmdlZCBhbmQgbmVlZHMgdG8gYmUgcGFyc2VkIGFnYWluLiBUaGUgQVNUIGhlbGQgYnkgdGhpcyBvdXRkYXRlZFxuICAgICAqIGRvY3VtZW50IGluc3RhbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJDaGFuZ2VkXCJdID0gMF0gPSBcIkNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBBbiBBU1QgaGFzIGJlZW4gY3JlYXRlZCBmcm9tIHRoZSB0ZXh0IGNvbnRlbnQuIFRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgY2FuIGJlIHRyYXZlcnNlZCxcbiAgICAgKiBidXQgY3Jvc3MtcmVmZXJlbmNlcyBjYW5ub3QgYmUgcmVzb2x2ZWQgeWV0LiBJZiBuZWNlc3NhcnksIHRoZSBzdHJ1Y3R1cmUgY2FuIGJlIG1hbmlwdWxhdGVkXG4gICAgICogYXQgdGhpcyBzdGFnZSBhcyBhIHByZXByb2Nlc3Npbmcgc3RlcC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJQYXJzZWRcIl0gPSAxXSA9IFwiUGFyc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBJbmRleE1hbmFnZXJgIHNlcnZpY2UgaGFzIHByb2Nlc3NlZCBBU1Qgbm9kZXMgb2YgdGhpcyBkb2N1bWVudC4gVGhpcyBtZWFucyB0aGVcbiAgICAgKiBleHBvcnRlZCBzeW1ib2xzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGdsb2JhbCBzY29wZSBhbmQgY2FuIGJlIHJlc29sdmVkIGZyb20gb3RoZXIgZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkluZGV4ZWRDb250ZW50XCJdID0gMl0gPSBcIkluZGV4ZWRDb250ZW50XCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBTY29wZUNvbXB1dGF0aW9uYCBzZXJ2aWNlIGhhcyBwcm9jZXNzZWQgdGhpcyBkb2N1bWVudC4gVGhpcyBtZWFucyB0aGUgbG9jYWwgc3ltYm9sc1xuICAgICAqIGFyZSBzdG9yZWQgaW4gYSBNdWx0aU1hcCBzbyB0aGV5IGNhbiBiZSBsb29rZWQgdXAgYnkgdGhlIGBTY29wZVByb3ZpZGVyYCBzZXJ2aWNlLlxuICAgICAqIE9uY2UgYSBkb2N1bWVudCBoYXMgcmVhY2hlZCB0aGlzIHN0YXRlLCB5b3UgbWF5IGZvbGxvdyBldmVyeSByZWZlcmVuY2UgLSBpdCB3aWxsIGxhemlseVxuICAgICAqIHJlc29sdmUgaXRzIGByZWZgIHByb3BlcnR5IGFuZCB5aWVsZCBlaXRoZXIgdGhlIHRhcmdldCBBU1Qgbm9kZSBvciBgdW5kZWZpbmVkYCBpbiBjYXNlXG4gICAgICogdGhlIHRhcmdldCBpcyBub3QgaW4gc2NvcGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiQ29tcHV0ZWRTY29wZXNcIl0gPSAzXSA9IFwiQ29tcHV0ZWRTY29wZXNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYExpbmtlcmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIHRoaXMgZG9jdW1lbnQuIEFsbCBvdXRnb2luZyByZWZlcmVuY2VzIGhhdmUgYmVlblxuICAgICAqIHJlc29sdmVkIG9yIG1hcmtlZCBhcyBlcnJvbmVvdXMuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiTGlua2VkXCJdID0gNF0gPSBcIkxpbmtlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgSW5kZXhNYW5hZ2VyYCBzZXJ2aWNlIGhhcyBwcm9jZXNzZWQgQVNUIG5vZGUgcmVmZXJlbmNlcyBvZiB0aGlzIGRvY3VtZW50LiBUaGlzIGlzXG4gICAgICogbmVjZXNzYXJ5IHRvIGRldGVybWluZSB3aGljaCBkb2N1bWVudHMgYXJlIGFmZmVjdGVkIGJ5IGEgY2hhbmdlIGluIG9uZSBvZiB0aGUgd29ya3NwYWNlXG4gICAgICogZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkluZGV4ZWRSZWZlcmVuY2VzXCJdID0gNV0gPSBcIkluZGV4ZWRSZWZlcmVuY2VzXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBEb2N1bWVudFZhbGlkYXRvcmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIHRoaXMgZG9jdW1lbnQuIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgbGlzdGVuc1xuICAgICAqIHRvIHRoZSByZXN1bHRzIG9mIHRoaXMgcGhhc2UgYW5kIHNlbmRzIGRpYWdub3N0aWNzIHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiVmFsaWRhdGVkXCJdID0gNl0gPSBcIlZhbGlkYXRlZFwiO1xufSkoRG9jdW1lbnRTdGF0ZSB8fCAoRG9jdW1lbnRTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgRGVmYXVsdExhbmdpdW1Eb2N1bWVudEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLnRleHREb2N1bWVudHMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuVGV4dERvY3VtZW50cztcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuRmlsZVN5c3RlbVByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBmcm9tVXJpKHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpbGVTeXN0ZW1Qcm92aWRlci5yZWFkRmlsZSh1cmkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIGNvbnRlbnQsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZnJvbVRleHREb2N1bWVudCh0ZXh0RG9jdW1lbnQsIHVyaSwgdG9rZW4pIHtcbiAgICAgICAgdXJpID0gdXJpICE9PSBudWxsICYmIHVyaSAhPT0gdm9pZCAwID8gdXJpIDogVVJJLnBhcnNlKHRleHREb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoQ2FuY2VsbGF0aW9uVG9rZW4uaXModG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIHRleHREb2N1bWVudCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVyaSwgdGV4dERvY3VtZW50LCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmluZyh0ZXh0LCB1cmksIHRva2VuKSB7XG4gICAgICAgIGlmIChDYW5jZWxsYXRpb25Ub2tlbi5pcyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFzeW5jKHVyaSwgdGV4dCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVyaSwgdGV4dCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21Nb2RlbChtb2RlbCwgdXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh1cmksIHsgJG1vZGVsOiBtb2RlbCB9KTtcbiAgICB9XG4gICAgY3JlYXRlKHVyaSwgY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2UodXJpLCBjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCB1bmRlZmluZWQsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCckbW9kZWwnIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0geyB2YWx1ZTogY29udGVudC4kbW9kZWwsIHBhcnNlckVycm9yczogW10sIGxleGVyRXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlKHVyaSwgY29udGVudC5nZXRUZXh0KCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmksIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUFzeW5jKHVyaSwgY29udGVudCwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCB0aGlzLnBhcnNlQXN5bmModXJpLCBjb250ZW50LCBjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdW5kZWZpbmVkLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKHVyaSwgY29udGVudC5nZXRUZXh0KCksIGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMYW5naXVtRG9jdW1lbnQgZnJvbSBhIGdpdmVuIHBhcnNlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEEgVGV4dERvY3VtZW50IGlzIGNyZWF0ZWQgb24gZGVtYW5kIGlmIGl0IGlzIG5vdCBwcm92aWRlZCBhcyBhcmd1bWVudCBoZXJlLiBVc3VhbGx5IHRoaXNcbiAgICAgKiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBtYWluIHB1cnBvc2Ugb2YgdGhlIFRleHREb2N1bWVudCBpcyB0byBjb252ZXJ0IGJldHdlZW5cbiAgICAgKiB0ZXh0IHJhbmdlcyBhbmQgb2Zmc2V0cywgd2hpY2ggaXMgZG9uZSBzb2xlbHkgaW4gTFNQIHJlcXVlc3QgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBpbnRyb2R1Y3Rpb24gb2Yge0BsaW5rIHVwZGF0ZX0gYmVsb3cgdGhpcyBtZXRob2QgaXMgc3VwcG9zZWQgdG8gYmUgbWFpbmx5IGNhbGxlZFxuICAgICAqIGR1cmluZyB3b3Jrc3BhY2UgaW5pdGlhbGl6YXRpb24gYW5kIG9uIGFkZGl0aW9uL3JlY29nbml0aW9uIG9mIG5ldyBmaWxlcywgd2hpbGUgY2hhbmdlcyBpblxuICAgICAqIGV4aXN0aW5nIGRvY3VtZW50cyBhcmUgcHJvY2Vzc2VkIHZpYSB7QGxpbmsgdXBkYXRlfS5cbiAgICAgKi9cbiAgICBjcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdGV4dERvY3VtZW50LCB0ZXh0KSB7XG4gICAgICAgIGxldCBkb2N1bWVudDtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRHZXR0ZXIgPSB0aGlzLmNyZWF0ZVRleHREb2N1bWVudEdldHRlcih1cmksIHRleHQpO1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBnZXQgdGV4dERvY3VtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dERvY3VtZW50R2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZS4kZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUoZG9jdW1lbnQsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIFRoZSBDU1QgZnVsbCB0ZXh0IHByb3BlcnR5IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRoZSBBU1QuXG4gICAgICAgIGNvbnN0IG9sZFRleHQgPSAoX2EgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3QuZnVsbFRleHQ7XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudCA9IChfYiA9IHRoaXMudGV4dERvY3VtZW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQgPyB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpIDogYXdhaXQgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIucmVhZEZpbGUoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAndGV4dERvY3VtZW50Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50R2V0dGVyID0gdGhpcy5jcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIoZG9jdW1lbnQudXJpLCB0ZXh0KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ3RleHREb2N1bWVudCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IHRleHREb2N1bWVudEdldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBkb2N1bWVudHMgY2FuIGJlIHByZXR0eSBsYXJnZSwgc28gcGFyc2luZyB0aGVtIGFnYWluIGNhbiBiZSBxdWl0ZSBleHBlbnNpdmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugb25seSBwYXJzZSBpZiB0aGUgdGV4dCBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKGRvY3VtZW50LnVyaSwgdGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUuJGRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSBEb2N1bWVudFN0YXRlLlBhcnNlZDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBwYXJzZSh1cmksIHRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpO1xuICAgICAgICByZXR1cm4gc2VydmljZXMucGFyc2VyLkxhbmdpdW1QYXJzZXIucGFyc2UodGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlQXN5bmModXJpLCB0ZXh0LCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKHVyaSk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5wYXJzZXIuQXN5bmNQYXJzZXIucGFyc2UodGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIodXJpLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VSZWdpc3RyeSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICBsZXQgdGV4dERvYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RG9jICE9PSBudWxsICYmIHRleHREb2MgIT09IHZvaWQgMCA/IHRleHREb2MgOiAodGV4dERvYyA9IFRleHREb2N1bWVudC5jcmVhdGUodXJpLnRvU3RyaW5nKCksIHNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpLkxhbmd1YWdlTWV0YURhdGEubGFuZ3VhZ2VJZCwgMCwgdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdExhbmdpdW1Eb2N1bWVudHMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeSA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRGYWN0b3J5O1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICB9XG4gICAgZ2V0IGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLmRvY3VtZW50TWFwLnZhbHVlcygpKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gZG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50TWFwLmhhcyh1cmlTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZG9jdW1lbnQgd2l0aCB0aGUgVVJJICcke3VyaVN0cmluZ30nIGlzIGFscmVhZHkgcHJlc2VudC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY3VtZW50TWFwLnNldCh1cmlTdHJpbmcsIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIGNvbnN0IHVyaVN0cmluZyA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE1hcC5nZXQodXJpU3RyaW5nKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVEb2N1bWVudCh1cmksIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQodXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQgPSBhd2FpdCB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbVVyaSh1cmksIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgdGhpcy5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgY3JlYXRlRG9jdW1lbnQodXJpLCB0ZXh0LCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbVN0cmluZyh0ZXh0LCB1cmksIGNhbmNlbGxhdGlvblRva2VuKS50aGVuKGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRGYWN0b3J5LmZyb21TdHJpbmcodGV4dCwgdXJpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0RvY3VtZW50KHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE1hcC5oYXModXJpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlRG9jdW1lbnQodXJpKSB7XG4gICAgICAgIGNvbnN0IHVyaVN0cmluZyA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsYW5naXVtRG9jID0gdGhpcy5kb2N1bWVudE1hcC5nZXQodXJpU3RyaW5nKTtcbiAgICAgICAgaWYgKGxhbmdpdW1Eb2MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKHVyaSkucmVmZXJlbmNlcy5MaW5rZXI7XG4gICAgICAgICAgICBsaW5rZXIudW5saW5rKGxhbmdpdW1Eb2MpO1xuICAgICAgICAgICAgbGFuZ2l1bURvYy5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgIGxhbmdpdW1Eb2MucHJlY29tcHV0ZWRTY29wZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYW5naXVtRG9jLmRpYWdub3N0aWNzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYW5naXVtRG9jO1xuICAgIH1cbiAgICBkZWxldGVEb2N1bWVudCh1cmkpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxhbmdpdW1Eb2MgPSB0aGlzLmRvY3VtZW50TWFwLmdldCh1cmlTdHJpbmcpO1xuICAgICAgICBpZiAobGFuZ2l1bURvYykge1xuICAgICAgICAgICAgbGFuZ2l1bURvYy5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNYXAuZGVsZXRlKHVyaVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhbmdpdW1Eb2M7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jdW1lbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/documents.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/file-system-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/file-system-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmptyFileSystem: () => (/* binding */ EmptyFileSystem),\n/* harmony export */   EmptyFileSystemProvider: () => (/* binding */ EmptyFileSystemProvider)\n/* harmony export */ });\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass EmptyFileSystemProvider {\n    readFile() {\n        throw new Error('No file system is available.');\n    }\n    async readDirectory() {\n        return [];\n    }\n}\nconst EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n//# sourceMappingURL=file-system-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2ZpbGUtc3lzdGVtLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx3b3Jrc3BhY2VcXGZpbGUtc3lzdGVtLXByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBjbGFzcyBFbXB0eUZpbGVTeXN0ZW1Qcm92aWRlciB7XG4gICAgcmVhZEZpbGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlLicpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGlyZWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEVtcHR5RmlsZVN5c3RlbSA9IHtcbiAgICBmaWxlU3lzdGVtUHJvdmlkZXI6ICgpID0+IG5ldyBFbXB0eUZpbGVTeXN0ZW1Qcm92aWRlcigpXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1zeXN0ZW0tcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/file-system-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/index-manager.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/index-manager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultIndexManager: () => (/* binding */ DefaultIndexManager)\n/* harmony export */ });\n/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/ast-utils.js\");\n/* harmony import */ var _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/caching.js */ \"(ssr)/./node_modules/langium/lib/utils/caching.js\");\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ \"(ssr)/./node_modules/langium/lib/utils/stream.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/uri-utils.js\");\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nclass DefaultIndexManager {\n    constructor(services) {\n        /**\n         * The symbol index stores all `AstNodeDescription` items exported by a document.\n         * The key used in this map is the string representation of the specific document URI.\n         */\n        this.symbolIndex = new Map();\n        /**\n         * This is a cache for the `allElements()` method.\n         * It caches the descriptions from `symbolIndex` grouped by types.\n         */\n        this.symbolByTypeIndex = new _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__.ContextCache();\n        /**\n         * This index keeps track of all `ReferenceDescription` items exported by a document.\n         * This is used to compute which elements are affected by a document change\n         * and for finding references to an AST node.\n         */\n        this.referenceIndex = new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (_utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) {\n            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            var _a;\n            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__.CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__.CancellationToken.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n}\n//# sourceMappingURL=index-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2luZGV4LW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRDtBQUNEO0FBQ1U7QUFDakI7QUFDSztBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFRO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBLDJCQUEyQix3REFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFFQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUVBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcSGFtemFXb3JrXFxOZXh0SlNcXFVuaXZlcnNhbC1FbmdpbmVlcmluZy1DT1xcbm9kZV9tb2R1bGVzXFxsYW5naXVtXFxsaWJcXHdvcmtzcGFjZVxcaW5kZXgtbWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBDb250ZXh0Q2FjaGUgfSBmcm9tICcuLi91dGlscy9jYWNoaW5nLmpzJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBVcmlVdGlscyB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdEluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzeW1ib2wgaW5kZXggc3RvcmVzIGFsbCBgQXN0Tm9kZURlc2NyaXB0aW9uYCBpdGVtcyBleHBvcnRlZCBieSBhIGRvY3VtZW50LlxuICAgICAgICAgKiBUaGUga2V5IHVzZWQgaW4gdGhpcyBtYXAgaXMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWMgZG9jdW1lbnQgVVJJLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW1ib2xJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYSBjYWNoZSBmb3IgdGhlIGBhbGxFbGVtZW50cygpYCBtZXRob2QuXG4gICAgICAgICAqIEl0IGNhY2hlcyB0aGUgZGVzY3JpcHRpb25zIGZyb20gYHN5bWJvbEluZGV4YCBncm91cGVkIGJ5IHR5cGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zeW1ib2xCeVR5cGVJbmRleCA9IG5ldyBDb250ZXh0Q2FjaGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaW5kZXgga2VlcHMgdHJhY2sgb2YgYWxsIGBSZWZlcmVuY2VEZXNjcmlwdGlvbmAgaXRlbXMgZXhwb3J0ZWQgYnkgYSBkb2N1bWVudC5cbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIGNvbXB1dGUgd2hpY2ggZWxlbWVudHMgYXJlIGFmZmVjdGVkIGJ5IGEgZG9jdW1lbnQgY2hhbmdlXG4gICAgICAgICAqIGFuZCBmb3IgZmluZGluZyByZWZlcmVuY2VzIHRvIGFuIEFTVCBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50cztcbiAgICAgICAgdGhpcy5zZXJ2aWNlUmVnaXN0cnkgPSBzZXJ2aWNlcy5TZXJ2aWNlUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuYXN0UmVmbGVjdGlvbiA9IHNlcnZpY2VzLkFzdFJlZmxlY3Rpb247XG4gICAgfVxuICAgIGZpbmRBbGxSZWZlcmVuY2VzKHRhcmdldE5vZGUsIGFzdE5vZGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERvY1VyaSA9IGdldERvY3VtZW50KHRhcmdldE5vZGUpLnVyaTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMucmVmZXJlbmNlSW5kZXguZm9yRWFjaChkb2NSZWZzID0+IHtcbiAgICAgICAgICAgIGRvY1JlZnMuZm9yRWFjaChyZWZEZXNjciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFVyaVV0aWxzLmVxdWFscyhyZWZEZXNjci50YXJnZXRVcmksIHRhcmdldERvY1VyaSkgJiYgcmVmRGVzY3IudGFyZ2V0UGF0aCA9PT0gYXN0Tm9kZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVmRGVzY3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbShyZXN1bHQpO1xuICAgIH1cbiAgICBhbGxFbGVtZW50cyhub2RlVHlwZSwgdXJpcykge1xuICAgICAgICBsZXQgZG9jdW1lbnRVcmlzID0gc3RyZWFtKHRoaXMuc3ltYm9sSW5kZXgua2V5cygpKTtcbiAgICAgICAgaWYgKHVyaXMpIHtcbiAgICAgICAgICAgIGRvY3VtZW50VXJpcyA9IGRvY3VtZW50VXJpcy5maWx0ZXIodXJpID0+ICF1cmlzIHx8IHVyaXMuaGFzKHVyaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudFVyaXNcbiAgICAgICAgICAgIC5tYXAodXJpID0+IHRoaXMuZ2V0RmlsZURlc2NyaXB0aW9ucyh1cmksIG5vZGVUeXBlKSlcbiAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgfVxuICAgIGdldEZpbGVEZXNjcmlwdGlvbnModXJpLCBub2RlVHlwZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghbm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN5bWJvbEluZGV4LmdldCh1cmkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbnMgPSB0aGlzLnN5bWJvbEJ5VHlwZUluZGV4LmdldCh1cmksIG5vZGVUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBhbGxGaWxlRGVzY3JpcHRpb25zID0gKF9hID0gdGhpcy5zeW1ib2xJbmRleC5nZXQodXJpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICByZXR1cm4gYWxsRmlsZURlc2NyaXB0aW9ucy5maWx0ZXIoZSA9PiB0aGlzLmFzdFJlZmxlY3Rpb24uaXNTdWJ0eXBlKGUudHlwZSwgbm9kZVR5cGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIHJlbW92ZSh1cmkpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sSW5kZXguZGVsZXRlKHVyaVN0cmluZyk7XG4gICAgICAgIHRoaXMuc3ltYm9sQnlUeXBlSW5kZXguY2xlYXIodXJpU3RyaW5nKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VJbmRleC5kZWxldGUodXJpU3RyaW5nKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQ29udGVudChkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgY29uc3QgZXhwb3J0cyA9IGF3YWl0IHNlcnZpY2VzLnJlZmVyZW5jZXMuU2NvcGVDb21wdXRhdGlvbi5jb21wdXRlRXhwb3J0cyhkb2N1bWVudCwgY2FuY2VsVG9rZW4pO1xuICAgICAgICBjb25zdCB1cmkgPSBkb2N1bWVudC51cmkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xJbmRleC5zZXQodXJpLCBleHBvcnRzKTtcbiAgICAgICAgdGhpcy5zeW1ib2xCeVR5cGVJbmRleC5jbGVhcih1cmkpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVSZWZlcmVuY2VzKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2N1bWVudC51cmkpO1xuICAgICAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCBzZXJ2aWNlcy53b3Jrc3BhY2UuUmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlci5jcmVhdGVEZXNjcmlwdGlvbnMoZG9jdW1lbnQsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VJbmRleC5zZXQoZG9jdW1lbnQudXJpLnRvU3RyaW5nKCksIGluZGV4RGF0YSk7XG4gICAgfVxuICAgIGlzQWZmZWN0ZWQoZG9jdW1lbnQsIGNoYW5nZWRVcmlzKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSB0aGlzLnJlZmVyZW5jZUluZGV4LmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VzLnNvbWUocmVmID0+ICFyZWYubG9jYWwgJiYgY2hhbmdlZFVyaXMuaGFzKHJlZi50YXJnZXRVcmkudG9TdHJpbmcoKSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/index-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/workspace-lock.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/workspace-lock.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultWorkspaceLock: () => (/* binding */ DefaultWorkspaceLock)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultWorkspaceLock {\n    constructor() {\n        this.previousTokenSource = new _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.startCancelableOperation)();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {\n        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.Deferred();\n        const entry = {\n            action,\n            deferred,\n            cancellationToken\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) {\n            return;\n        }\n        const entries = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift());\n        }\n        else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        }\n        else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            }\n            catch (err) {\n                if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.isOperationCancelled)(err)) {\n                    // If the operation was cancelled, we don't want to reject the promise\n                    deferred.resolve(undefined);\n                }\n                else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n}\n//# sourceMappingURL=workspace-lock.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL3dvcmtzcGFjZS1sb2NrLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7QUFDZTtBQUM5RjtBQUNQO0FBQ0EsdUNBQXVDLDJFQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUZBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxRUFBaUI7QUFDaEUsNkJBQTZCLDZEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx3b3Jrc3BhY2VcXHdvcmtzcGFjZS1sb2NrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCwgaXNPcGVyYXRpb25DYW5jZWxsZWQsIHN0YXJ0Q2FuY2VsYWJsZU9wZXJhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRXb3Jrc3BhY2VMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Rva2VuU291cmNlID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH1cbiAgICB3cml0ZShhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYW5jZWxXcml0ZSgpO1xuICAgICAgICBjb25zdCB0b2tlblNvdXJjZSA9IHN0YXJ0Q2FuY2VsYWJsZU9wZXJhdGlvbigpO1xuICAgICAgICB0aGlzLnByZXZpb3VzVG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZSh0aGlzLndyaXRlUXVldWUsIGFjdGlvbiwgdG9rZW5Tb3VyY2UudG9rZW4pO1xuICAgIH1cbiAgICByZWFkKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlKHRoaXMucmVhZFF1ZXVlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBlbnF1ZXVlKHF1ZXVlLCBhY3Rpb24sIGNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcXVldWUucHVzaChlbnRyeSk7XG4gICAgICAgIHRoaXMucGVyZm9ybU5leHRPcGVyYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIHBlcmZvcm1OZXh0T3BlcmF0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBKdXN0IHBlcmZvcm0gdGhlIG5leHQgd3JpdGUgYWN0aW9uXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy53cml0ZVF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVhZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSByZWFkIHF1ZXVlIGFuZCBwZXJmb3JtIGFsbCBhY3Rpb25zIGluIHBhcmFsbGVsXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goLi4udGhpcy5yZWFkUXVldWUuc3BsaWNlKDAsIHRoaXMucmVhZFF1ZXVlLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChlbnRyaWVzLm1hcChhc3luYyAoeyBhY3Rpb24sIGRlZmVycmVkLCBjYW5jZWxsYXRpb25Ub2tlbiB9KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYWN0aW9uIHRvIHRoZSBuZXh0IGV2ZW50IGxvb3AgdGljayB2aWEgYFByb21pc2UucmVzb2x2ZSgpYFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYWN0aW9uKGNhbmNlbGxhdGlvblRva2VuKSk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCwgd2UgZG9uJ3Qgd2FudCB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGVyZm9ybU5leHRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgY2FuY2VsV3JpdGUoKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNUb2tlblNvdXJjZS5jYW5jZWwoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3Jrc3BhY2UtbG9jay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/workspace-lock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/langium/lib/workspace/workspace-manager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/workspace-manager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultWorkspaceManager: () => (/* binding */ DefaultWorkspaceManager)\n/* harmony export */ });\n/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cancellation.js */ \"(ssr)/./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\n/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/promise-utils.js\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/vscode-uri/lib/esm/index.mjs\");\n/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/uri-utils.js */ \"(ssr)/./node_modules/langium/lib/utils/uri-utils.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nclass DefaultWorkspaceManager {\n    constructor(services) {\n        this.initialBuildOptions = {};\n        this._ready = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    get workspaceFolders() {\n        return this.folders;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;\n    }\n    initialized(_params) {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });\n    }\n    async initializeWorkspace(folders, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.None) {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.interruptAndCheck)(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = (document) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don't await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])\n            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    getRootFolder(workspaceFolder) {\n        return _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(workspaceFolder.uri);\n    }\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry) => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                }\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.basename(entry.uri);\n        if (name.startsWith('.')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== 'node_modules' && name !== 'out';\n        }\n        else if (entry.isFile) {\n            const extname = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=workspace-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL3dvcmtzcGFjZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNXO0FBQ2xCO0FBQy9DO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQiw2REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLGtHQUFrRztBQUNySjtBQUNBLHFEQUFxRCxxRUFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsY0FBYywwRUFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXEhhbXphV29ya1xcTmV4dEpTXFxVbml2ZXJzYWwtRW5naW5lZXJpbmctQ09cXG5vZGVfbW9kdWxlc1xcbGFuZ2l1bVxcbGliXFx3b3Jrc3BhY2VcXHdvcmtzcGFjZS1tYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IERlZmVycmVkLCBpbnRlcnJ1cHRBbmRDaGVjayB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuaW1wb3J0IHsgVVJJLCBVcmlVdGlscyB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFdvcmtzcGFjZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbEJ1aWxkT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9yZWFkeSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzID0gc2VydmljZXMud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRCdWlsZGVyID0gc2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlcjtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuRmlsZVN5c3RlbVByb3ZpZGVyO1xuICAgICAgICB0aGlzLm11dGV4ID0gc2VydmljZXMud29ya3NwYWNlLldvcmtzcGFjZUxvY2s7XG4gICAgfVxuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5LnByb21pc2U7XG4gICAgfVxuICAgIGdldCB3b3Jrc3BhY2VGb2xkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xkZXJzO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZm9sZGVycyA9IChfYSA9IHBhcmFtcy53b3Jrc3BhY2VGb2xkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGluaXRpYWxpemVkKF9wYXJhbXMpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd29ya3NwYWNlIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHdvcmtzcGFjZSBmb2xkZXJzXG4gICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gbG9hZCBhZGRpdGlvbmFsIGRvY3VtZW50cyAobGFuZ3VhZ2UgbGlicmFyeSBvciBzaW1pbGFyKSBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMubXV0ZXgud3JpdGUodG9rZW4gPT4geyB2YXIgX2E7IHJldHVybiB0aGlzLmluaXRpYWxpemVXb3Jrc3BhY2UoKF9hID0gdGhpcy5mb2xkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgdG9rZW4pOyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdGlhbGl6ZVdvcmtzcGFjZShmb2xkZXJzLCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgdGhpcy5wZXJmb3JtU3RhcnR1cChmb2xkZXJzKTtcbiAgICAgICAgLy8gT25seSBhZnRlciBjcmVhdGluZyBhbGwgZG9jdW1lbnRzIGRvIHdlIGNoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBjYW5jZWwgdGhlIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCBidWlsZGVyIHdpbGwgbGF0ZXIgcGljayB1cCBvbiBhbGwgdW5wcm9jZXNzZWQgZG9jdW1lbnRzXG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kb2N1bWVudEJ1aWxkZXIuYnVpbGQoZG9jdW1lbnRzLCB0aGlzLmluaXRpYWxCdWlsZE9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHVuaW50ZXJydXB0YWJsZSBzdGFydHVwIHNlcXVlbmNlIG9mIHRoZSB3b3Jrc3BhY2UgbWFuYWdlci5cbiAgICAgKiBUaGlzIG1ldGhvZHMgbG9hZHMgYWxsIGRvY3VtZW50cyBpbiB0aGUgd29ya3NwYWNlIGFuZCBvdGhlciBkb2N1bWVudHMgYW5kIHJldHVybnMgdGhlbS5cbiAgICAgKi9cbiAgICBhc3luYyBwZXJmb3JtU3RhcnR1cChmb2xkZXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb25zID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuYWxsLmZsYXRNYXAoZSA9PiBlLkxhbmd1YWdlTWV0YURhdGEuZmlsZUV4dGVuc2lvbnMpO1xuICAgICAgICBjb25zdCBkb2N1bWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yID0gKGRvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudHMucHVzaChkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGFuZ2l1bURvY3VtZW50cy5oYXNEb2N1bWVudChkb2N1bWVudC51cmkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UgZG9uJ3QgYXdhaXQgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSB3b3Jrc3BhY2UgbWFuYWdlcixcbiAgICAgICAgLy8gd2UgY2FuIHN0aWxsIGFzc3VtZSB0aGF0IGFsbCBsaWJyYXJ5IGRvY3VtZW50cyBhbmQgZmlsZSBkb2N1bWVudHMgYXJlIGxvYWRlZCBieSB0aGUgdGltZSB3ZSBzdGFydCBidWlsZGluZyBkb2N1bWVudHMuXG4gICAgICAgIC8vIFRoZSBtdXRleCBwcmV2ZW50cyBhbnl0aGluZyBmcm9tIHBlcmZvcm1pbmcgYSB3b3Jrc3BhY2UgYnVpbGQgdW50aWwgd2UgY2hlY2sgdGhlIGNhbmNlbGxhdGlvbiB0b2tlblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRBZGRpdGlvbmFsRG9jdW1lbnRzKGZvbGRlcnMsIGNvbGxlY3Rvcik7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGZvbGRlcnMubWFwKHdmID0+IFt3ZiwgdGhpcy5nZXRSb290Rm9sZGVyKHdmKV0pXG4gICAgICAgICAgICAubWFwKGFzeW5jIChlbnRyeSkgPT4gdGhpcy50cmF2ZXJzZUZvbGRlciguLi5lbnRyeSwgZmlsZUV4dGVuc2lvbnMsIGNvbGxlY3RvcikpKTtcbiAgICAgICAgdGhpcy5fcmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGFsbCBhZGRpdGlvbmFsIGRvY3VtZW50cyB0aGF0IHNoYWxsIGJlIHZpc2libGUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGdpdmVuIHdvcmtzcGFjZVxuICAgICAqIGZvbGRlcnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBjb2xsZWN0b3IuIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5jbHVkZSBidWlsdC1pbiBsaWJyYXJpZXMgb2ZcbiAgICAgKiB5b3VyIGxhbmd1YWdlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGxvYWRlZCBmcm9tIHByb3ZpZGVkIGZpbGVzIG9yIGNvbnN0cnVjdGVkIGluIG1lbW9yeS5cbiAgICAgKi9cbiAgICBsb2FkQWRkaXRpb25hbERvY3VtZW50cyhfZm9sZGVycywgX2NvbGxlY3Rvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgcm9vdCBmb2xkZXIgb2YgdGhlIHNvdXJjZSBkb2N1bWVudHMgaW4gdGhlIGdpdmVuIHdvcmtzcGFjZSBmb2xkZXIuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgVVJJIG9mIHRoZSB3b3Jrc3BhY2UgZm9sZGVyLCBidXQgeW91IGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgdG8gcmV0dXJuIGEgc3ViZm9sZGVyIGxpa2UgYHNyY2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXRSb290Rm9sZGVyKHdvcmtzcGFjZUZvbGRlcikge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHdvcmtzcGFjZUZvbGRlci51cmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSB0aGUgZmlsZSBzeXN0ZW0gZm9sZGVyIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIFVSSSBhbmQgaXRzIHN1YmZvbGRlcnMuIEFsbFxuICAgICAqIGNvbnRhaW5lZCBmaWxlcyB0aGF0IG1hdGNoIHRoZSBmaWxlIGV4dGVuc2lvbnMgYXJlIGFkZGVkIHRvIHRoZSBjb2xsZWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgdHJhdmVyc2VGb2xkZXIod29ya3NwYWNlRm9sZGVyLCBmb2xkZXJQYXRoLCBmaWxlRXh0ZW5zaW9ucywgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpbGVTeXN0ZW1Qcm92aWRlci5yZWFkRGlyZWN0b3J5KGZvbGRlclBhdGgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb250ZW50Lm1hcChhc3luYyAoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluY2x1ZGVFbnRyeSh3b3Jrc3BhY2VGb2xkZXIsIGVudHJ5LCBmaWxlRXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmF2ZXJzZUZvbGRlcih3b3Jrc3BhY2VGb2xkZXIsIGVudHJ5LnVyaSwgZmlsZUV4dGVuc2lvbnMsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMubGFuZ2l1bURvY3VtZW50cy5nZXRPckNyZWF0ZURvY3VtZW50KGVudHJ5LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvcihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBmb2xkZXIgZW50cnkgc2hhbGwgYmUgaW5jbHVkZWQgd2hpbGUgaW5kZXhpbmcgdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBpbmNsdWRlRW50cnkoX3dvcmtzcGFjZUZvbGRlciwgZW50cnksIGZpbGVFeHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBVcmlVdGlscy5iYXNlbmFtZShlbnRyeS51cmkpO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lICE9PSAnbm9kZV9tb2R1bGVzJyAmJiBuYW1lICE9PSAnb3V0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dG5hbWUgPSBVcmlVdGlscy5leHRuYW1lKGVudHJ5LnVyaSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZUV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtzcGFjZS1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/langium/lib/workspace/workspace-manager.js\n");

/***/ })

};
;